// This file is generated by rust-protobuf 2.25.2. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `google/container/v1/cluster_service.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_25_2;

#[derive(PartialEq,Clone,Default)]
pub struct NodeConfig {
    // message fields
    pub machine_type: ::std::string::String,
    pub disk_size_gb: i32,
    pub oauth_scopes: ::protobuf::RepeatedField<::std::string::String>,
    pub service_account: ::std::string::String,
    pub metadata: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub image_type: ::std::string::String,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub local_ssd_count: i32,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub preemptible: bool,
    pub accelerators: ::protobuf::RepeatedField<AcceleratorConfig>,
    pub disk_type: ::std::string::String,
    pub min_cpu_platform: ::std::string::String,
    pub taints: ::protobuf::RepeatedField<NodeTaint>,
    pub shielded_instance_config: ::protobuf::SingularPtrField<ShieldedInstanceConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeConfig {
    fn default() -> &'a NodeConfig {
        <NodeConfig as ::protobuf::Message>::default_instance()
    }
}

impl NodeConfig {
    pub fn new() -> NodeConfig {
        ::std::default::Default::default()
    }

    // string machine_type = 1;


    pub fn get_machine_type(&self) -> &str {
        &self.machine_type
    }
    pub fn clear_machine_type(&mut self) {
        self.machine_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_machine_type(&mut self, v: ::std::string::String) {
        self.machine_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machine_type(&mut self) -> &mut ::std::string::String {
        &mut self.machine_type
    }

    // Take field
    pub fn take_machine_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.machine_type, ::std::string::String::new())
    }

    // int32 disk_size_gb = 2;


    pub fn get_disk_size_gb(&self) -> i32 {
        self.disk_size_gb
    }
    pub fn clear_disk_size_gb(&mut self) {
        self.disk_size_gb = 0;
    }

    // Param is passed by value, moved
    pub fn set_disk_size_gb(&mut self, v: i32) {
        self.disk_size_gb = v;
    }

    // repeated string oauth_scopes = 3;


    pub fn get_oauth_scopes(&self) -> &[::std::string::String] {
        &self.oauth_scopes
    }
    pub fn clear_oauth_scopes(&mut self) {
        self.oauth_scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_oauth_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.oauth_scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_oauth_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.oauth_scopes
    }

    // Take field
    pub fn take_oauth_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.oauth_scopes, ::protobuf::RepeatedField::new())
    }

    // string service_account = 9;


    pub fn get_service_account(&self) -> &str {
        &self.service_account
    }
    pub fn clear_service_account(&mut self) {
        self.service_account.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_account(&mut self, v: ::std::string::String) {
        self.service_account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_account(&mut self) -> &mut ::std::string::String {
        &mut self.service_account
    }

    // Take field
    pub fn take_service_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_account, ::std::string::String::new())
    }

    // repeated .google.container.v1.NodeConfig.MetadataEntry metadata = 4;


    pub fn get_metadata(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.metadata
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.metadata = v;
    }

    // Mutable pointer to the field.
    pub fn mut_metadata(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.metadata
    }

    // Take field
    pub fn take_metadata(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.metadata, ::std::collections::HashMap::new())
    }

    // string image_type = 5;


    pub fn get_image_type(&self) -> &str {
        &self.image_type
    }
    pub fn clear_image_type(&mut self) {
        self.image_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_type(&mut self, v: ::std::string::String) {
        self.image_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_type(&mut self) -> &mut ::std::string::String {
        &mut self.image_type
    }

    // Take field
    pub fn take_image_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image_type, ::std::string::String::new())
    }

    // repeated .google.container.v1.NodeConfig.LabelsEntry labels = 6;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // int32 local_ssd_count = 7;


    pub fn get_local_ssd_count(&self) -> i32 {
        self.local_ssd_count
    }
    pub fn clear_local_ssd_count(&mut self) {
        self.local_ssd_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_local_ssd_count(&mut self, v: i32) {
        self.local_ssd_count = v;
    }

    // repeated string tags = 8;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // bool preemptible = 10;


    pub fn get_preemptible(&self) -> bool {
        self.preemptible
    }
    pub fn clear_preemptible(&mut self) {
        self.preemptible = false;
    }

    // Param is passed by value, moved
    pub fn set_preemptible(&mut self, v: bool) {
        self.preemptible = v;
    }

    // repeated .google.container.v1.AcceleratorConfig accelerators = 11;


    pub fn get_accelerators(&self) -> &[AcceleratorConfig] {
        &self.accelerators
    }
    pub fn clear_accelerators(&mut self) {
        self.accelerators.clear();
    }

    // Param is passed by value, moved
    pub fn set_accelerators(&mut self, v: ::protobuf::RepeatedField<AcceleratorConfig>) {
        self.accelerators = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accelerators(&mut self) -> &mut ::protobuf::RepeatedField<AcceleratorConfig> {
        &mut self.accelerators
    }

    // Take field
    pub fn take_accelerators(&mut self) -> ::protobuf::RepeatedField<AcceleratorConfig> {
        ::std::mem::replace(&mut self.accelerators, ::protobuf::RepeatedField::new())
    }

    // string disk_type = 12;


    pub fn get_disk_type(&self) -> &str {
        &self.disk_type
    }
    pub fn clear_disk_type(&mut self) {
        self.disk_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_disk_type(&mut self, v: ::std::string::String) {
        self.disk_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_disk_type(&mut self) -> &mut ::std::string::String {
        &mut self.disk_type
    }

    // Take field
    pub fn take_disk_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.disk_type, ::std::string::String::new())
    }

    // string min_cpu_platform = 13;


    pub fn get_min_cpu_platform(&self) -> &str {
        &self.min_cpu_platform
    }
    pub fn clear_min_cpu_platform(&mut self) {
        self.min_cpu_platform.clear();
    }

    // Param is passed by value, moved
    pub fn set_min_cpu_platform(&mut self, v: ::std::string::String) {
        self.min_cpu_platform = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_min_cpu_platform(&mut self) -> &mut ::std::string::String {
        &mut self.min_cpu_platform
    }

    // Take field
    pub fn take_min_cpu_platform(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.min_cpu_platform, ::std::string::String::new())
    }

    // repeated .google.container.v1.NodeTaint taints = 15;


    pub fn get_taints(&self) -> &[NodeTaint] {
        &self.taints
    }
    pub fn clear_taints(&mut self) {
        self.taints.clear();
    }

    // Param is passed by value, moved
    pub fn set_taints(&mut self, v: ::protobuf::RepeatedField<NodeTaint>) {
        self.taints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_taints(&mut self) -> &mut ::protobuf::RepeatedField<NodeTaint> {
        &mut self.taints
    }

    // Take field
    pub fn take_taints(&mut self) -> ::protobuf::RepeatedField<NodeTaint> {
        ::std::mem::replace(&mut self.taints, ::protobuf::RepeatedField::new())
    }

    // .google.container.v1.ShieldedInstanceConfig shielded_instance_config = 20;


    pub fn get_shielded_instance_config(&self) -> &ShieldedInstanceConfig {
        self.shielded_instance_config.as_ref().unwrap_or_else(|| <ShieldedInstanceConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_shielded_instance_config(&mut self) {
        self.shielded_instance_config.clear();
    }

    pub fn has_shielded_instance_config(&self) -> bool {
        self.shielded_instance_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shielded_instance_config(&mut self, v: ShieldedInstanceConfig) {
        self.shielded_instance_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shielded_instance_config(&mut self) -> &mut ShieldedInstanceConfig {
        if self.shielded_instance_config.is_none() {
            self.shielded_instance_config.set_default();
        }
        self.shielded_instance_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_shielded_instance_config(&mut self) -> ShieldedInstanceConfig {
        self.shielded_instance_config.take().unwrap_or_else(|| ShieldedInstanceConfig::new())
    }
}

impl ::protobuf::Message for NodeConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.accelerators {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.taints {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.shielded_instance_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.machine_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.disk_size_gb = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.oauth_scopes)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_account)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.metadata)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image_type)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.local_ssd_count = tmp;
                },
                8 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.preemptible = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.accelerators)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.disk_type)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.min_cpu_platform)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.taints)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.shielded_instance_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.machine_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.machine_type);
        }
        if self.disk_size_gb != 0 {
            my_size += ::protobuf::rt::value_size(2, self.disk_size_gb, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.oauth_scopes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.service_account.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.service_account);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.metadata);
        if !self.image_type.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.image_type);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(6, &self.labels);
        if self.local_ssd_count != 0 {
            my_size += ::protobuf::rt::value_size(7, self.local_ssd_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(8, &value);
        };
        if self.preemptible != false {
            my_size += 2;
        }
        for value in &self.accelerators {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.disk_type.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.disk_type);
        }
        if !self.min_cpu_platform.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.min_cpu_platform);
        }
        for value in &self.taints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.shielded_instance_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.machine_type.is_empty() {
            os.write_string(1, &self.machine_type)?;
        }
        if self.disk_size_gb != 0 {
            os.write_int32(2, self.disk_size_gb)?;
        }
        for v in &self.oauth_scopes {
            os.write_string(3, &v)?;
        };
        if !self.service_account.is_empty() {
            os.write_string(9, &self.service_account)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.metadata, os)?;
        if !self.image_type.is_empty() {
            os.write_string(5, &self.image_type)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(6, &self.labels, os)?;
        if self.local_ssd_count != 0 {
            os.write_int32(7, self.local_ssd_count)?;
        }
        for v in &self.tags {
            os.write_string(8, &v)?;
        };
        if self.preemptible != false {
            os.write_bool(10, self.preemptible)?;
        }
        for v in &self.accelerators {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.disk_type.is_empty() {
            os.write_string(12, &self.disk_type)?;
        }
        if !self.min_cpu_platform.is_empty() {
            os.write_string(13, &self.min_cpu_platform)?;
        }
        for v in &self.taints {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.shielded_instance_config.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeConfig {
        NodeConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "machine_type",
                |m: &NodeConfig| { &m.machine_type },
                |m: &mut NodeConfig| { &mut m.machine_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "disk_size_gb",
                |m: &NodeConfig| { &m.disk_size_gb },
                |m: &mut NodeConfig| { &mut m.disk_size_gb },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "oauth_scopes",
                |m: &NodeConfig| { &m.oauth_scopes },
                |m: &mut NodeConfig| { &mut m.oauth_scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_account",
                |m: &NodeConfig| { &m.service_account },
                |m: &mut NodeConfig| { &mut m.service_account },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "metadata",
                |m: &NodeConfig| { &m.metadata },
                |m: &mut NodeConfig| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image_type",
                |m: &NodeConfig| { &m.image_type },
                |m: &mut NodeConfig| { &mut m.image_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &NodeConfig| { &m.labels },
                |m: &mut NodeConfig| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "local_ssd_count",
                |m: &NodeConfig| { &m.local_ssd_count },
                |m: &mut NodeConfig| { &mut m.local_ssd_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &NodeConfig| { &m.tags },
                |m: &mut NodeConfig| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "preemptible",
                |m: &NodeConfig| { &m.preemptible },
                |m: &mut NodeConfig| { &mut m.preemptible },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AcceleratorConfig>>(
                "accelerators",
                |m: &NodeConfig| { &m.accelerators },
                |m: &mut NodeConfig| { &mut m.accelerators },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "disk_type",
                |m: &NodeConfig| { &m.disk_type },
                |m: &mut NodeConfig| { &mut m.disk_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "min_cpu_platform",
                |m: &NodeConfig| { &m.min_cpu_platform },
                |m: &mut NodeConfig| { &mut m.min_cpu_platform },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeTaint>>(
                "taints",
                |m: &NodeConfig| { &m.taints },
                |m: &mut NodeConfig| { &mut m.taints },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ShieldedInstanceConfig>>(
                "shielded_instance_config",
                |m: &NodeConfig| { &m.shielded_instance_config },
                |m: &mut NodeConfig| { &mut m.shielded_instance_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeConfig>(
                "NodeConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeConfig {
        static instance: ::protobuf::rt::LazyV2<NodeConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeConfig::new)
    }
}

impl ::protobuf::Clear for NodeConfig {
    fn clear(&mut self) {
        self.machine_type.clear();
        self.disk_size_gb = 0;
        self.oauth_scopes.clear();
        self.service_account.clear();
        self.metadata.clear();
        self.image_type.clear();
        self.labels.clear();
        self.local_ssd_count = 0;
        self.tags.clear();
        self.preemptible = false;
        self.accelerators.clear();
        self.disk_type.clear();
        self.min_cpu_platform.clear();
        self.taints.clear();
        self.shielded_instance_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ShieldedInstanceConfig {
    // message fields
    pub enable_secure_boot: bool,
    pub enable_integrity_monitoring: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ShieldedInstanceConfig {
    fn default() -> &'a ShieldedInstanceConfig {
        <ShieldedInstanceConfig as ::protobuf::Message>::default_instance()
    }
}

impl ShieldedInstanceConfig {
    pub fn new() -> ShieldedInstanceConfig {
        ::std::default::Default::default()
    }

    // bool enable_secure_boot = 1;


    pub fn get_enable_secure_boot(&self) -> bool {
        self.enable_secure_boot
    }
    pub fn clear_enable_secure_boot(&mut self) {
        self.enable_secure_boot = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_secure_boot(&mut self, v: bool) {
        self.enable_secure_boot = v;
    }

    // bool enable_integrity_monitoring = 2;


    pub fn get_enable_integrity_monitoring(&self) -> bool {
        self.enable_integrity_monitoring
    }
    pub fn clear_enable_integrity_monitoring(&mut self) {
        self.enable_integrity_monitoring = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_integrity_monitoring(&mut self, v: bool) {
        self.enable_integrity_monitoring = v;
    }
}

impl ::protobuf::Message for ShieldedInstanceConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_secure_boot = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_integrity_monitoring = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enable_secure_boot != false {
            my_size += 2;
        }
        if self.enable_integrity_monitoring != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enable_secure_boot != false {
            os.write_bool(1, self.enable_secure_boot)?;
        }
        if self.enable_integrity_monitoring != false {
            os.write_bool(2, self.enable_integrity_monitoring)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ShieldedInstanceConfig {
        ShieldedInstanceConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_secure_boot",
                |m: &ShieldedInstanceConfig| { &m.enable_secure_boot },
                |m: &mut ShieldedInstanceConfig| { &mut m.enable_secure_boot },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_integrity_monitoring",
                |m: &ShieldedInstanceConfig| { &m.enable_integrity_monitoring },
                |m: &mut ShieldedInstanceConfig| { &mut m.enable_integrity_monitoring },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ShieldedInstanceConfig>(
                "ShieldedInstanceConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ShieldedInstanceConfig {
        static instance: ::protobuf::rt::LazyV2<ShieldedInstanceConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ShieldedInstanceConfig::new)
    }
}

impl ::protobuf::Clear for ShieldedInstanceConfig {
    fn clear(&mut self) {
        self.enable_secure_boot = false;
        self.enable_integrity_monitoring = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ShieldedInstanceConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ShieldedInstanceConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeTaint {
    // message fields
    pub key: ::std::string::String,
    pub value: ::std::string::String,
    pub effect: NodeTaint_Effect,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeTaint {
    fn default() -> &'a NodeTaint {
        <NodeTaint as ::protobuf::Message>::default_instance()
    }
}

impl NodeTaint {
    pub fn new() -> NodeTaint {
        ::std::default::Default::default()
    }

    // string key = 1;


    pub fn get_key(&self) -> &str {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key, ::std::string::String::new())
    }

    // string value = 2;


    pub fn get_value(&self) -> &str {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.value, ::std::string::String::new())
    }

    // .google.container.v1.NodeTaint.Effect effect = 3;


    pub fn get_effect(&self) -> NodeTaint_Effect {
        self.effect
    }
    pub fn clear_effect(&mut self) {
        self.effect = NodeTaint_Effect::EFFECT_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: NodeTaint_Effect) {
        self.effect = v;
    }
}

impl ::protobuf::Message for NodeTaint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.effect, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        if self.effect != NodeTaint_Effect::EFFECT_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.effect);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        if self.effect != NodeTaint_Effect::EFFECT_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.effect))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeTaint {
        NodeTaint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &NodeTaint| { &m.key },
                |m: &mut NodeTaint| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &NodeTaint| { &m.value },
                |m: &mut NodeTaint| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NodeTaint_Effect>>(
                "effect",
                |m: &NodeTaint| { &m.effect },
                |m: &mut NodeTaint| { &mut m.effect },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeTaint>(
                "NodeTaint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeTaint {
        static instance: ::protobuf::rt::LazyV2<NodeTaint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeTaint::new)
    }
}

impl ::protobuf::Clear for NodeTaint {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.effect = NodeTaint_Effect::EFFECT_UNSPECIFIED;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeTaint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeTaint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NodeTaint_Effect {
    EFFECT_UNSPECIFIED = 0,
    NO_SCHEDULE = 1,
    PREFER_NO_SCHEDULE = 2,
    NO_EXECUTE = 3,
}

impl ::protobuf::ProtobufEnum for NodeTaint_Effect {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NodeTaint_Effect> {
        match value {
            0 => ::std::option::Option::Some(NodeTaint_Effect::EFFECT_UNSPECIFIED),
            1 => ::std::option::Option::Some(NodeTaint_Effect::NO_SCHEDULE),
            2 => ::std::option::Option::Some(NodeTaint_Effect::PREFER_NO_SCHEDULE),
            3 => ::std::option::Option::Some(NodeTaint_Effect::NO_EXECUTE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NodeTaint_Effect] = &[
            NodeTaint_Effect::EFFECT_UNSPECIFIED,
            NodeTaint_Effect::NO_SCHEDULE,
            NodeTaint_Effect::PREFER_NO_SCHEDULE,
            NodeTaint_Effect::NO_EXECUTE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NodeTaint_Effect>("NodeTaint.Effect", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NodeTaint_Effect {
}

impl ::std::default::Default for NodeTaint_Effect {
    fn default() -> Self {
        NodeTaint_Effect::EFFECT_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeTaint_Effect {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MasterAuth {
    // message fields
    pub username: ::std::string::String,
    pub password: ::std::string::String,
    pub client_certificate_config: ::protobuf::SingularPtrField<ClientCertificateConfig>,
    pub cluster_ca_certificate: ::std::string::String,
    pub client_certificate: ::std::string::String,
    pub client_key: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MasterAuth {
    fn default() -> &'a MasterAuth {
        <MasterAuth as ::protobuf::Message>::default_instance()
    }
}

impl MasterAuth {
    pub fn new() -> MasterAuth {
        ::std::default::Default::default()
    }

    // string username = 1;


    pub fn get_username(&self) -> &str {
        &self.username
    }
    pub fn clear_username(&mut self) {
        self.username.clear();
    }

    // Param is passed by value, moved
    pub fn set_username(&mut self, v: ::std::string::String) {
        self.username = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_username(&mut self) -> &mut ::std::string::String {
        &mut self.username
    }

    // Take field
    pub fn take_username(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.username, ::std::string::String::new())
    }

    // string password = 2;


    pub fn get_password(&self) -> &str {
        &self.password
    }
    pub fn clear_password(&mut self) {
        self.password.clear();
    }

    // Param is passed by value, moved
    pub fn set_password(&mut self, v: ::std::string::String) {
        self.password = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_password(&mut self) -> &mut ::std::string::String {
        &mut self.password
    }

    // Take field
    pub fn take_password(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.password, ::std::string::String::new())
    }

    // .google.container.v1.ClientCertificateConfig client_certificate_config = 3;


    pub fn get_client_certificate_config(&self) -> &ClientCertificateConfig {
        self.client_certificate_config.as_ref().unwrap_or_else(|| <ClientCertificateConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_client_certificate_config(&mut self) {
        self.client_certificate_config.clear();
    }

    pub fn has_client_certificate_config(&self) -> bool {
        self.client_certificate_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_certificate_config(&mut self, v: ClientCertificateConfig) {
        self.client_certificate_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_certificate_config(&mut self) -> &mut ClientCertificateConfig {
        if self.client_certificate_config.is_none() {
            self.client_certificate_config.set_default();
        }
        self.client_certificate_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_client_certificate_config(&mut self) -> ClientCertificateConfig {
        self.client_certificate_config.take().unwrap_or_else(|| ClientCertificateConfig::new())
    }

    // string cluster_ca_certificate = 100;


    pub fn get_cluster_ca_certificate(&self) -> &str {
        &self.cluster_ca_certificate
    }
    pub fn clear_cluster_ca_certificate(&mut self) {
        self.cluster_ca_certificate.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_ca_certificate(&mut self, v: ::std::string::String) {
        self.cluster_ca_certificate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_ca_certificate(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_ca_certificate
    }

    // Take field
    pub fn take_cluster_ca_certificate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_ca_certificate, ::std::string::String::new())
    }

    // string client_certificate = 101;


    pub fn get_client_certificate(&self) -> &str {
        &self.client_certificate
    }
    pub fn clear_client_certificate(&mut self) {
        self.client_certificate.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_certificate(&mut self, v: ::std::string::String) {
        self.client_certificate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_certificate(&mut self) -> &mut ::std::string::String {
        &mut self.client_certificate
    }

    // Take field
    pub fn take_client_certificate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_certificate, ::std::string::String::new())
    }

    // string client_key = 102;


    pub fn get_client_key(&self) -> &str {
        &self.client_key
    }
    pub fn clear_client_key(&mut self) {
        self.client_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_client_key(&mut self, v: ::std::string::String) {
        self.client_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_client_key(&mut self) -> &mut ::std::string::String {
        &mut self.client_key
    }

    // Take field
    pub fn take_client_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.client_key, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MasterAuth {
    fn is_initialized(&self) -> bool {
        for v in &self.client_certificate_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.username)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.password)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.client_certificate_config)?;
                },
                100 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_ca_certificate)?;
                },
                101 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_certificate)?;
                },
                102 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.client_key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.username.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.username);
        }
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.password);
        }
        if let Some(ref v) = self.client_certificate_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.cluster_ca_certificate.is_empty() {
            my_size += ::protobuf::rt::string_size(100, &self.cluster_ca_certificate);
        }
        if !self.client_certificate.is_empty() {
            my_size += ::protobuf::rt::string_size(101, &self.client_certificate);
        }
        if !self.client_key.is_empty() {
            my_size += ::protobuf::rt::string_size(102, &self.client_key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.username.is_empty() {
            os.write_string(1, &self.username)?;
        }
        if !self.password.is_empty() {
            os.write_string(2, &self.password)?;
        }
        if let Some(ref v) = self.client_certificate_config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.cluster_ca_certificate.is_empty() {
            os.write_string(100, &self.cluster_ca_certificate)?;
        }
        if !self.client_certificate.is_empty() {
            os.write_string(101, &self.client_certificate)?;
        }
        if !self.client_key.is_empty() {
            os.write_string(102, &self.client_key)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MasterAuth {
        MasterAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "username",
                |m: &MasterAuth| { &m.username },
                |m: &mut MasterAuth| { &mut m.username },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "password",
                |m: &MasterAuth| { &m.password },
                |m: &mut MasterAuth| { &mut m.password },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientCertificateConfig>>(
                "client_certificate_config",
                |m: &MasterAuth| { &m.client_certificate_config },
                |m: &mut MasterAuth| { &mut m.client_certificate_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_ca_certificate",
                |m: &MasterAuth| { &m.cluster_ca_certificate },
                |m: &mut MasterAuth| { &mut m.cluster_ca_certificate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_certificate",
                |m: &MasterAuth| { &m.client_certificate },
                |m: &mut MasterAuth| { &mut m.client_certificate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "client_key",
                |m: &MasterAuth| { &m.client_key },
                |m: &mut MasterAuth| { &mut m.client_key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MasterAuth>(
                "MasterAuth",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MasterAuth {
        static instance: ::protobuf::rt::LazyV2<MasterAuth> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MasterAuth::new)
    }
}

impl ::protobuf::Clear for MasterAuth {
    fn clear(&mut self) {
        self.username.clear();
        self.password.clear();
        self.client_certificate_config.clear();
        self.cluster_ca_certificate.clear();
        self.client_certificate.clear();
        self.client_key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MasterAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MasterAuth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientCertificateConfig {
    // message fields
    pub issue_client_certificate: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientCertificateConfig {
    fn default() -> &'a ClientCertificateConfig {
        <ClientCertificateConfig as ::protobuf::Message>::default_instance()
    }
}

impl ClientCertificateConfig {
    pub fn new() -> ClientCertificateConfig {
        ::std::default::Default::default()
    }

    // bool issue_client_certificate = 1;


    pub fn get_issue_client_certificate(&self) -> bool {
        self.issue_client_certificate
    }
    pub fn clear_issue_client_certificate(&mut self) {
        self.issue_client_certificate = false;
    }

    // Param is passed by value, moved
    pub fn set_issue_client_certificate(&mut self, v: bool) {
        self.issue_client_certificate = v;
    }
}

impl ::protobuf::Message for ClientCertificateConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.issue_client_certificate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.issue_client_certificate != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.issue_client_certificate != false {
            os.write_bool(1, self.issue_client_certificate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientCertificateConfig {
        ClientCertificateConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "issue_client_certificate",
                |m: &ClientCertificateConfig| { &m.issue_client_certificate },
                |m: &mut ClientCertificateConfig| { &mut m.issue_client_certificate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientCertificateConfig>(
                "ClientCertificateConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientCertificateConfig {
        static instance: ::protobuf::rt::LazyV2<ClientCertificateConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientCertificateConfig::new)
    }
}

impl ::protobuf::Clear for ClientCertificateConfig {
    fn clear(&mut self) {
        self.issue_client_certificate = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientCertificateConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientCertificateConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddonsConfig {
    // message fields
    pub http_load_balancing: ::protobuf::SingularPtrField<HttpLoadBalancing>,
    pub horizontal_pod_autoscaling: ::protobuf::SingularPtrField<HorizontalPodAutoscaling>,
    pub kubernetes_dashboard: ::protobuf::SingularPtrField<KubernetesDashboard>,
    pub network_policy_config: ::protobuf::SingularPtrField<NetworkPolicyConfig>,
    pub cloud_run_config: ::protobuf::SingularPtrField<CloudRunConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddonsConfig {
    fn default() -> &'a AddonsConfig {
        <AddonsConfig as ::protobuf::Message>::default_instance()
    }
}

impl AddonsConfig {
    pub fn new() -> AddonsConfig {
        ::std::default::Default::default()
    }

    // .google.container.v1.HttpLoadBalancing http_load_balancing = 1;


    pub fn get_http_load_balancing(&self) -> &HttpLoadBalancing {
        self.http_load_balancing.as_ref().unwrap_or_else(|| <HttpLoadBalancing as ::protobuf::Message>::default_instance())
    }
    pub fn clear_http_load_balancing(&mut self) {
        self.http_load_balancing.clear();
    }

    pub fn has_http_load_balancing(&self) -> bool {
        self.http_load_balancing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_http_load_balancing(&mut self, v: HttpLoadBalancing) {
        self.http_load_balancing = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_http_load_balancing(&mut self) -> &mut HttpLoadBalancing {
        if self.http_load_balancing.is_none() {
            self.http_load_balancing.set_default();
        }
        self.http_load_balancing.as_mut().unwrap()
    }

    // Take field
    pub fn take_http_load_balancing(&mut self) -> HttpLoadBalancing {
        self.http_load_balancing.take().unwrap_or_else(|| HttpLoadBalancing::new())
    }

    // .google.container.v1.HorizontalPodAutoscaling horizontal_pod_autoscaling = 2;


    pub fn get_horizontal_pod_autoscaling(&self) -> &HorizontalPodAutoscaling {
        self.horizontal_pod_autoscaling.as_ref().unwrap_or_else(|| <HorizontalPodAutoscaling as ::protobuf::Message>::default_instance())
    }
    pub fn clear_horizontal_pod_autoscaling(&mut self) {
        self.horizontal_pod_autoscaling.clear();
    }

    pub fn has_horizontal_pod_autoscaling(&self) -> bool {
        self.horizontal_pod_autoscaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_horizontal_pod_autoscaling(&mut self, v: HorizontalPodAutoscaling) {
        self.horizontal_pod_autoscaling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_horizontal_pod_autoscaling(&mut self) -> &mut HorizontalPodAutoscaling {
        if self.horizontal_pod_autoscaling.is_none() {
            self.horizontal_pod_autoscaling.set_default();
        }
        self.horizontal_pod_autoscaling.as_mut().unwrap()
    }

    // Take field
    pub fn take_horizontal_pod_autoscaling(&mut self) -> HorizontalPodAutoscaling {
        self.horizontal_pod_autoscaling.take().unwrap_or_else(|| HorizontalPodAutoscaling::new())
    }

    // .google.container.v1.KubernetesDashboard kubernetes_dashboard = 3;


    pub fn get_kubernetes_dashboard(&self) -> &KubernetesDashboard {
        self.kubernetes_dashboard.as_ref().unwrap_or_else(|| <KubernetesDashboard as ::protobuf::Message>::default_instance())
    }
    pub fn clear_kubernetes_dashboard(&mut self) {
        self.kubernetes_dashboard.clear();
    }

    pub fn has_kubernetes_dashboard(&self) -> bool {
        self.kubernetes_dashboard.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubernetes_dashboard(&mut self, v: KubernetesDashboard) {
        self.kubernetes_dashboard = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubernetes_dashboard(&mut self) -> &mut KubernetesDashboard {
        if self.kubernetes_dashboard.is_none() {
            self.kubernetes_dashboard.set_default();
        }
        self.kubernetes_dashboard.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubernetes_dashboard(&mut self) -> KubernetesDashboard {
        self.kubernetes_dashboard.take().unwrap_or_else(|| KubernetesDashboard::new())
    }

    // .google.container.v1.NetworkPolicyConfig network_policy_config = 4;


    pub fn get_network_policy_config(&self) -> &NetworkPolicyConfig {
        self.network_policy_config.as_ref().unwrap_or_else(|| <NetworkPolicyConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_network_policy_config(&mut self) {
        self.network_policy_config.clear();
    }

    pub fn has_network_policy_config(&self) -> bool {
        self.network_policy_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_policy_config(&mut self, v: NetworkPolicyConfig) {
        self.network_policy_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network_policy_config(&mut self) -> &mut NetworkPolicyConfig {
        if self.network_policy_config.is_none() {
            self.network_policy_config.set_default();
        }
        self.network_policy_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_network_policy_config(&mut self) -> NetworkPolicyConfig {
        self.network_policy_config.take().unwrap_or_else(|| NetworkPolicyConfig::new())
    }

    // .google.container.v1.CloudRunConfig cloud_run_config = 7;


    pub fn get_cloud_run_config(&self) -> &CloudRunConfig {
        self.cloud_run_config.as_ref().unwrap_or_else(|| <CloudRunConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cloud_run_config(&mut self) {
        self.cloud_run_config.clear();
    }

    pub fn has_cloud_run_config(&self) -> bool {
        self.cloud_run_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cloud_run_config(&mut self, v: CloudRunConfig) {
        self.cloud_run_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cloud_run_config(&mut self) -> &mut CloudRunConfig {
        if self.cloud_run_config.is_none() {
            self.cloud_run_config.set_default();
        }
        self.cloud_run_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_cloud_run_config(&mut self) -> CloudRunConfig {
        self.cloud_run_config.take().unwrap_or_else(|| CloudRunConfig::new())
    }
}

impl ::protobuf::Message for AddonsConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.http_load_balancing {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.horizontal_pod_autoscaling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.kubernetes_dashboard {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network_policy_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cloud_run_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.http_load_balancing)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.horizontal_pod_autoscaling)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kubernetes_dashboard)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.network_policy_config)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cloud_run_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.http_load_balancing.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.horizontal_pod_autoscaling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.kubernetes_dashboard.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.network_policy_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cloud_run_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.http_load_balancing.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.horizontal_pod_autoscaling.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.kubernetes_dashboard.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.network_policy_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cloud_run_config.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddonsConfig {
        AddonsConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HttpLoadBalancing>>(
                "http_load_balancing",
                |m: &AddonsConfig| { &m.http_load_balancing },
                |m: &mut AddonsConfig| { &mut m.http_load_balancing },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HorizontalPodAutoscaling>>(
                "horizontal_pod_autoscaling",
                |m: &AddonsConfig| { &m.horizontal_pod_autoscaling },
                |m: &mut AddonsConfig| { &mut m.horizontal_pod_autoscaling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KubernetesDashboard>>(
                "kubernetes_dashboard",
                |m: &AddonsConfig| { &m.kubernetes_dashboard },
                |m: &mut AddonsConfig| { &mut m.kubernetes_dashboard },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkPolicyConfig>>(
                "network_policy_config",
                |m: &AddonsConfig| { &m.network_policy_config },
                |m: &mut AddonsConfig| { &mut m.network_policy_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CloudRunConfig>>(
                "cloud_run_config",
                |m: &AddonsConfig| { &m.cloud_run_config },
                |m: &mut AddonsConfig| { &mut m.cloud_run_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddonsConfig>(
                "AddonsConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddonsConfig {
        static instance: ::protobuf::rt::LazyV2<AddonsConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddonsConfig::new)
    }
}

impl ::protobuf::Clear for AddonsConfig {
    fn clear(&mut self) {
        self.http_load_balancing.clear();
        self.horizontal_pod_autoscaling.clear();
        self.kubernetes_dashboard.clear();
        self.network_policy_config.clear();
        self.cloud_run_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddonsConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddonsConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HttpLoadBalancing {
    // message fields
    pub disabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HttpLoadBalancing {
    fn default() -> &'a HttpLoadBalancing {
        <HttpLoadBalancing as ::protobuf::Message>::default_instance()
    }
}

impl HttpLoadBalancing {
    pub fn new() -> HttpLoadBalancing {
        ::std::default::Default::default()
    }

    // bool disabled = 1;


    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }
}

impl ::protobuf::Message for HttpLoadBalancing {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.disabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.disabled != false {
            os.write_bool(1, self.disabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HttpLoadBalancing {
        HttpLoadBalancing::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled",
                |m: &HttpLoadBalancing| { &m.disabled },
                |m: &mut HttpLoadBalancing| { &mut m.disabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HttpLoadBalancing>(
                "HttpLoadBalancing",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HttpLoadBalancing {
        static instance: ::protobuf::rt::LazyV2<HttpLoadBalancing> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HttpLoadBalancing::new)
    }
}

impl ::protobuf::Clear for HttpLoadBalancing {
    fn clear(&mut self) {
        self.disabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HttpLoadBalancing {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HttpLoadBalancing {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HorizontalPodAutoscaling {
    // message fields
    pub disabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HorizontalPodAutoscaling {
    fn default() -> &'a HorizontalPodAutoscaling {
        <HorizontalPodAutoscaling as ::protobuf::Message>::default_instance()
    }
}

impl HorizontalPodAutoscaling {
    pub fn new() -> HorizontalPodAutoscaling {
        ::std::default::Default::default()
    }

    // bool disabled = 1;


    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }
}

impl ::protobuf::Message for HorizontalPodAutoscaling {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.disabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.disabled != false {
            os.write_bool(1, self.disabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HorizontalPodAutoscaling {
        HorizontalPodAutoscaling::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled",
                |m: &HorizontalPodAutoscaling| { &m.disabled },
                |m: &mut HorizontalPodAutoscaling| { &mut m.disabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HorizontalPodAutoscaling>(
                "HorizontalPodAutoscaling",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HorizontalPodAutoscaling {
        static instance: ::protobuf::rt::LazyV2<HorizontalPodAutoscaling> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HorizontalPodAutoscaling::new)
    }
}

impl ::protobuf::Clear for HorizontalPodAutoscaling {
    fn clear(&mut self) {
        self.disabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HorizontalPodAutoscaling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HorizontalPodAutoscaling {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KubernetesDashboard {
    // message fields
    pub disabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KubernetesDashboard {
    fn default() -> &'a KubernetesDashboard {
        <KubernetesDashboard as ::protobuf::Message>::default_instance()
    }
}

impl KubernetesDashboard {
    pub fn new() -> KubernetesDashboard {
        ::std::default::Default::default()
    }

    // bool disabled = 1;


    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }
}

impl ::protobuf::Message for KubernetesDashboard {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.disabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.disabled != false {
            os.write_bool(1, self.disabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KubernetesDashboard {
        KubernetesDashboard::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled",
                |m: &KubernetesDashboard| { &m.disabled },
                |m: &mut KubernetesDashboard| { &mut m.disabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KubernetesDashboard>(
                "KubernetesDashboard",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KubernetesDashboard {
        static instance: ::protobuf::rt::LazyV2<KubernetesDashboard> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KubernetesDashboard::new)
    }
}

impl ::protobuf::Clear for KubernetesDashboard {
    fn clear(&mut self) {
        self.disabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KubernetesDashboard {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KubernetesDashboard {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkPolicyConfig {
    // message fields
    pub disabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkPolicyConfig {
    fn default() -> &'a NetworkPolicyConfig {
        <NetworkPolicyConfig as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicyConfig {
    pub fn new() -> NetworkPolicyConfig {
        ::std::default::Default::default()
    }

    // bool disabled = 1;


    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }
}

impl ::protobuf::Message for NetworkPolicyConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.disabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.disabled != false {
            os.write_bool(1, self.disabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkPolicyConfig {
        NetworkPolicyConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled",
                |m: &NetworkPolicyConfig| { &m.disabled },
                |m: &mut NetworkPolicyConfig| { &mut m.disabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkPolicyConfig>(
                "NetworkPolicyConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkPolicyConfig {
        static instance: ::protobuf::rt::LazyV2<NetworkPolicyConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkPolicyConfig::new)
    }
}

impl ::protobuf::Clear for NetworkPolicyConfig {
    fn clear(&mut self) {
        self.disabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkPolicyConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicyConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PrivateClusterConfig {
    // message fields
    pub enable_private_nodes: bool,
    pub enable_private_endpoint: bool,
    pub master_ipv4_cidr_block: ::std::string::String,
    pub private_endpoint: ::std::string::String,
    pub public_endpoint: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PrivateClusterConfig {
    fn default() -> &'a PrivateClusterConfig {
        <PrivateClusterConfig as ::protobuf::Message>::default_instance()
    }
}

impl PrivateClusterConfig {
    pub fn new() -> PrivateClusterConfig {
        ::std::default::Default::default()
    }

    // bool enable_private_nodes = 1;


    pub fn get_enable_private_nodes(&self) -> bool {
        self.enable_private_nodes
    }
    pub fn clear_enable_private_nodes(&mut self) {
        self.enable_private_nodes = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_private_nodes(&mut self, v: bool) {
        self.enable_private_nodes = v;
    }

    // bool enable_private_endpoint = 2;


    pub fn get_enable_private_endpoint(&self) -> bool {
        self.enable_private_endpoint
    }
    pub fn clear_enable_private_endpoint(&mut self) {
        self.enable_private_endpoint = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_private_endpoint(&mut self, v: bool) {
        self.enable_private_endpoint = v;
    }

    // string master_ipv4_cidr_block = 3;


    pub fn get_master_ipv4_cidr_block(&self) -> &str {
        &self.master_ipv4_cidr_block
    }
    pub fn clear_master_ipv4_cidr_block(&mut self) {
        self.master_ipv4_cidr_block.clear();
    }

    // Param is passed by value, moved
    pub fn set_master_ipv4_cidr_block(&mut self, v: ::std::string::String) {
        self.master_ipv4_cidr_block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_master_ipv4_cidr_block(&mut self) -> &mut ::std::string::String {
        &mut self.master_ipv4_cidr_block
    }

    // Take field
    pub fn take_master_ipv4_cidr_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.master_ipv4_cidr_block, ::std::string::String::new())
    }

    // string private_endpoint = 4;


    pub fn get_private_endpoint(&self) -> &str {
        &self.private_endpoint
    }
    pub fn clear_private_endpoint(&mut self) {
        self.private_endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_private_endpoint(&mut self, v: ::std::string::String) {
        self.private_endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.private_endpoint
    }

    // Take field
    pub fn take_private_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.private_endpoint, ::std::string::String::new())
    }

    // string public_endpoint = 5;


    pub fn get_public_endpoint(&self) -> &str {
        &self.public_endpoint
    }
    pub fn clear_public_endpoint(&mut self) {
        self.public_endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_endpoint(&mut self, v: ::std::string::String) {
        self.public_endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.public_endpoint
    }

    // Take field
    pub fn take_public_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.public_endpoint, ::std::string::String::new())
    }
}

impl ::protobuf::Message for PrivateClusterConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_private_nodes = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_private_endpoint = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.master_ipv4_cidr_block)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.private_endpoint)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.public_endpoint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enable_private_nodes != false {
            my_size += 2;
        }
        if self.enable_private_endpoint != false {
            my_size += 2;
        }
        if !self.master_ipv4_cidr_block.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.master_ipv4_cidr_block);
        }
        if !self.private_endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.private_endpoint);
        }
        if !self.public_endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.public_endpoint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enable_private_nodes != false {
            os.write_bool(1, self.enable_private_nodes)?;
        }
        if self.enable_private_endpoint != false {
            os.write_bool(2, self.enable_private_endpoint)?;
        }
        if !self.master_ipv4_cidr_block.is_empty() {
            os.write_string(3, &self.master_ipv4_cidr_block)?;
        }
        if !self.private_endpoint.is_empty() {
            os.write_string(4, &self.private_endpoint)?;
        }
        if !self.public_endpoint.is_empty() {
            os.write_string(5, &self.public_endpoint)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PrivateClusterConfig {
        PrivateClusterConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_private_nodes",
                |m: &PrivateClusterConfig| { &m.enable_private_nodes },
                |m: &mut PrivateClusterConfig| { &mut m.enable_private_nodes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_private_endpoint",
                |m: &PrivateClusterConfig| { &m.enable_private_endpoint },
                |m: &mut PrivateClusterConfig| { &mut m.enable_private_endpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "master_ipv4_cidr_block",
                |m: &PrivateClusterConfig| { &m.master_ipv4_cidr_block },
                |m: &mut PrivateClusterConfig| { &mut m.master_ipv4_cidr_block },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "private_endpoint",
                |m: &PrivateClusterConfig| { &m.private_endpoint },
                |m: &mut PrivateClusterConfig| { &mut m.private_endpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "public_endpoint",
                |m: &PrivateClusterConfig| { &m.public_endpoint },
                |m: &mut PrivateClusterConfig| { &mut m.public_endpoint },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PrivateClusterConfig>(
                "PrivateClusterConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PrivateClusterConfig {
        static instance: ::protobuf::rt::LazyV2<PrivateClusterConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PrivateClusterConfig::new)
    }
}

impl ::protobuf::Clear for PrivateClusterConfig {
    fn clear(&mut self) {
        self.enable_private_nodes = false;
        self.enable_private_endpoint = false;
        self.master_ipv4_cidr_block.clear();
        self.private_endpoint.clear();
        self.public_endpoint.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PrivateClusterConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PrivateClusterConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticatorGroupsConfig {
    // message fields
    pub enabled: bool,
    pub security_group: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticatorGroupsConfig {
    fn default() -> &'a AuthenticatorGroupsConfig {
        <AuthenticatorGroupsConfig as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticatorGroupsConfig {
    pub fn new() -> AuthenticatorGroupsConfig {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // string security_group = 2;


    pub fn get_security_group(&self) -> &str {
        &self.security_group
    }
    pub fn clear_security_group(&mut self) {
        self.security_group.clear();
    }

    // Param is passed by value, moved
    pub fn set_security_group(&mut self, v: ::std::string::String) {
        self.security_group = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_group(&mut self) -> &mut ::std::string::String {
        &mut self.security_group
    }

    // Take field
    pub fn take_security_group(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.security_group, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthenticatorGroupsConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.security_group)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if !self.security_group.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.security_group);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if !self.security_group.is_empty() {
            os.write_string(2, &self.security_group)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticatorGroupsConfig {
        AuthenticatorGroupsConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &AuthenticatorGroupsConfig| { &m.enabled },
                |m: &mut AuthenticatorGroupsConfig| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "security_group",
                |m: &AuthenticatorGroupsConfig| { &m.security_group },
                |m: &mut AuthenticatorGroupsConfig| { &mut m.security_group },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthenticatorGroupsConfig>(
                "AuthenticatorGroupsConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthenticatorGroupsConfig {
        static instance: ::protobuf::rt::LazyV2<AuthenticatorGroupsConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticatorGroupsConfig::new)
    }
}

impl ::protobuf::Clear for AuthenticatorGroupsConfig {
    fn clear(&mut self) {
        self.enabled = false;
        self.security_group.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticatorGroupsConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticatorGroupsConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CloudRunConfig {
    // message fields
    pub disabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CloudRunConfig {
    fn default() -> &'a CloudRunConfig {
        <CloudRunConfig as ::protobuf::Message>::default_instance()
    }
}

impl CloudRunConfig {
    pub fn new() -> CloudRunConfig {
        ::std::default::Default::default()
    }

    // bool disabled = 1;


    pub fn get_disabled(&self) -> bool {
        self.disabled
    }
    pub fn clear_disabled(&mut self) {
        self.disabled = false;
    }

    // Param is passed by value, moved
    pub fn set_disabled(&mut self, v: bool) {
        self.disabled = v;
    }
}

impl ::protobuf::Message for CloudRunConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.disabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.disabled != false {
            os.write_bool(1, self.disabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CloudRunConfig {
        CloudRunConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disabled",
                |m: &CloudRunConfig| { &m.disabled },
                |m: &mut CloudRunConfig| { &mut m.disabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CloudRunConfig>(
                "CloudRunConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CloudRunConfig {
        static instance: ::protobuf::rt::LazyV2<CloudRunConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CloudRunConfig::new)
    }
}

impl ::protobuf::Clear for CloudRunConfig {
    fn clear(&mut self) {
        self.disabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CloudRunConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CloudRunConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MasterAuthorizedNetworksConfig {
    // message fields
    pub enabled: bool,
    pub cidr_blocks: ::protobuf::RepeatedField<MasterAuthorizedNetworksConfig_CidrBlock>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MasterAuthorizedNetworksConfig {
    fn default() -> &'a MasterAuthorizedNetworksConfig {
        <MasterAuthorizedNetworksConfig as ::protobuf::Message>::default_instance()
    }
}

impl MasterAuthorizedNetworksConfig {
    pub fn new() -> MasterAuthorizedNetworksConfig {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // repeated .google.container.v1.MasterAuthorizedNetworksConfig.CidrBlock cidr_blocks = 2;


    pub fn get_cidr_blocks(&self) -> &[MasterAuthorizedNetworksConfig_CidrBlock] {
        &self.cidr_blocks
    }
    pub fn clear_cidr_blocks(&mut self) {
        self.cidr_blocks.clear();
    }

    // Param is passed by value, moved
    pub fn set_cidr_blocks(&mut self, v: ::protobuf::RepeatedField<MasterAuthorizedNetworksConfig_CidrBlock>) {
        self.cidr_blocks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cidr_blocks(&mut self) -> &mut ::protobuf::RepeatedField<MasterAuthorizedNetworksConfig_CidrBlock> {
        &mut self.cidr_blocks
    }

    // Take field
    pub fn take_cidr_blocks(&mut self) -> ::protobuf::RepeatedField<MasterAuthorizedNetworksConfig_CidrBlock> {
        ::std::mem::replace(&mut self.cidr_blocks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MasterAuthorizedNetworksConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.cidr_blocks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cidr_blocks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        for value in &self.cidr_blocks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        for v in &self.cidr_blocks {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MasterAuthorizedNetworksConfig {
        MasterAuthorizedNetworksConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &MasterAuthorizedNetworksConfig| { &m.enabled },
                |m: &mut MasterAuthorizedNetworksConfig| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MasterAuthorizedNetworksConfig_CidrBlock>>(
                "cidr_blocks",
                |m: &MasterAuthorizedNetworksConfig| { &m.cidr_blocks },
                |m: &mut MasterAuthorizedNetworksConfig| { &mut m.cidr_blocks },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MasterAuthorizedNetworksConfig>(
                "MasterAuthorizedNetworksConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MasterAuthorizedNetworksConfig {
        static instance: ::protobuf::rt::LazyV2<MasterAuthorizedNetworksConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MasterAuthorizedNetworksConfig::new)
    }
}

impl ::protobuf::Clear for MasterAuthorizedNetworksConfig {
    fn clear(&mut self) {
        self.enabled = false;
        self.cidr_blocks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MasterAuthorizedNetworksConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MasterAuthorizedNetworksConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MasterAuthorizedNetworksConfig_CidrBlock {
    // message fields
    pub display_name: ::std::string::String,
    pub cidr_block: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MasterAuthorizedNetworksConfig_CidrBlock {
    fn default() -> &'a MasterAuthorizedNetworksConfig_CidrBlock {
        <MasterAuthorizedNetworksConfig_CidrBlock as ::protobuf::Message>::default_instance()
    }
}

impl MasterAuthorizedNetworksConfig_CidrBlock {
    pub fn new() -> MasterAuthorizedNetworksConfig_CidrBlock {
        ::std::default::Default::default()
    }

    // string display_name = 1;


    pub fn get_display_name(&self) -> &str {
        &self.display_name
    }
    pub fn clear_display_name(&mut self) {
        self.display_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_display_name(&mut self, v: ::std::string::String) {
        self.display_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_display_name(&mut self) -> &mut ::std::string::String {
        &mut self.display_name
    }

    // Take field
    pub fn take_display_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.display_name, ::std::string::String::new())
    }

    // string cidr_block = 2;


    pub fn get_cidr_block(&self) -> &str {
        &self.cidr_block
    }
    pub fn clear_cidr_block(&mut self) {
        self.cidr_block.clear();
    }

    // Param is passed by value, moved
    pub fn set_cidr_block(&mut self, v: ::std::string::String) {
        self.cidr_block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cidr_block(&mut self) -> &mut ::std::string::String {
        &mut self.cidr_block
    }

    // Take field
    pub fn take_cidr_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cidr_block, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MasterAuthorizedNetworksConfig_CidrBlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.display_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cidr_block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.display_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.display_name);
        }
        if !self.cidr_block.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cidr_block);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.display_name.is_empty() {
            os.write_string(1, &self.display_name)?;
        }
        if !self.cidr_block.is_empty() {
            os.write_string(2, &self.cidr_block)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MasterAuthorizedNetworksConfig_CidrBlock {
        MasterAuthorizedNetworksConfig_CidrBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "display_name",
                |m: &MasterAuthorizedNetworksConfig_CidrBlock| { &m.display_name },
                |m: &mut MasterAuthorizedNetworksConfig_CidrBlock| { &mut m.display_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cidr_block",
                |m: &MasterAuthorizedNetworksConfig_CidrBlock| { &m.cidr_block },
                |m: &mut MasterAuthorizedNetworksConfig_CidrBlock| { &mut m.cidr_block },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MasterAuthorizedNetworksConfig_CidrBlock>(
                "MasterAuthorizedNetworksConfig.CidrBlock",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MasterAuthorizedNetworksConfig_CidrBlock {
        static instance: ::protobuf::rt::LazyV2<MasterAuthorizedNetworksConfig_CidrBlock> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MasterAuthorizedNetworksConfig_CidrBlock::new)
    }
}

impl ::protobuf::Clear for MasterAuthorizedNetworksConfig_CidrBlock {
    fn clear(&mut self) {
        self.display_name.clear();
        self.cidr_block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MasterAuthorizedNetworksConfig_CidrBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MasterAuthorizedNetworksConfig_CidrBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LegacyAbac {
    // message fields
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LegacyAbac {
    fn default() -> &'a LegacyAbac {
        <LegacyAbac as ::protobuf::Message>::default_instance()
    }
}

impl LegacyAbac {
    pub fn new() -> LegacyAbac {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for LegacyAbac {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LegacyAbac {
        LegacyAbac::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &LegacyAbac| { &m.enabled },
                |m: &mut LegacyAbac| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LegacyAbac>(
                "LegacyAbac",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LegacyAbac {
        static instance: ::protobuf::rt::LazyV2<LegacyAbac> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LegacyAbac::new)
    }
}

impl ::protobuf::Clear for LegacyAbac {
    fn clear(&mut self) {
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LegacyAbac {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LegacyAbac {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkPolicy {
    // message fields
    pub provider: NetworkPolicy_Provider,
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkPolicy {
    fn default() -> &'a NetworkPolicy {
        <NetworkPolicy as ::protobuf::Message>::default_instance()
    }
}

impl NetworkPolicy {
    pub fn new() -> NetworkPolicy {
        ::std::default::Default::default()
    }

    // .google.container.v1.NetworkPolicy.Provider provider = 1;


    pub fn get_provider(&self) -> NetworkPolicy_Provider {
        self.provider
    }
    pub fn clear_provider(&mut self) {
        self.provider = NetworkPolicy_Provider::PROVIDER_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_provider(&mut self, v: NetworkPolicy_Provider) {
        self.provider = v;
    }

    // bool enabled = 2;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for NetworkPolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.provider, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.provider != NetworkPolicy_Provider::PROVIDER_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(1, self.provider);
        }
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.provider != NetworkPolicy_Provider::PROVIDER_UNSPECIFIED {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.provider))?;
        }
        if self.enabled != false {
            os.write_bool(2, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkPolicy {
        NetworkPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NetworkPolicy_Provider>>(
                "provider",
                |m: &NetworkPolicy| { &m.provider },
                |m: &mut NetworkPolicy| { &mut m.provider },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &NetworkPolicy| { &m.enabled },
                |m: &mut NetworkPolicy| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkPolicy>(
                "NetworkPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkPolicy {
        static instance: ::protobuf::rt::LazyV2<NetworkPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkPolicy::new)
    }
}

impl ::protobuf::Clear for NetworkPolicy {
    fn clear(&mut self) {
        self.provider = NetworkPolicy_Provider::PROVIDER_UNSPECIFIED;
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NetworkPolicy_Provider {
    PROVIDER_UNSPECIFIED = 0,
    CALICO = 1,
}

impl ::protobuf::ProtobufEnum for NetworkPolicy_Provider {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NetworkPolicy_Provider> {
        match value {
            0 => ::std::option::Option::Some(NetworkPolicy_Provider::PROVIDER_UNSPECIFIED),
            1 => ::std::option::Option::Some(NetworkPolicy_Provider::CALICO),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NetworkPolicy_Provider] = &[
            NetworkPolicy_Provider::PROVIDER_UNSPECIFIED,
            NetworkPolicy_Provider::CALICO,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NetworkPolicy_Provider>("NetworkPolicy.Provider", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NetworkPolicy_Provider {
}

impl ::std::default::Default for NetworkPolicy_Provider {
    fn default() -> Self {
        NetworkPolicy_Provider::PROVIDER_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkPolicy_Provider {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BinaryAuthorization {
    // message fields
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BinaryAuthorization {
    fn default() -> &'a BinaryAuthorization {
        <BinaryAuthorization as ::protobuf::Message>::default_instance()
    }
}

impl BinaryAuthorization {
    pub fn new() -> BinaryAuthorization {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for BinaryAuthorization {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BinaryAuthorization {
        BinaryAuthorization::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &BinaryAuthorization| { &m.enabled },
                |m: &mut BinaryAuthorization| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BinaryAuthorization>(
                "BinaryAuthorization",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BinaryAuthorization {
        static instance: ::protobuf::rt::LazyV2<BinaryAuthorization> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BinaryAuthorization::new)
    }
}

impl ::protobuf::Clear for BinaryAuthorization {
    fn clear(&mut self) {
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BinaryAuthorization {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinaryAuthorization {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPAllocationPolicy {
    // message fields
    pub use_ip_aliases: bool,
    pub create_subnetwork: bool,
    pub subnetwork_name: ::std::string::String,
    pub cluster_ipv4_cidr: ::std::string::String,
    pub node_ipv4_cidr: ::std::string::String,
    pub services_ipv4_cidr: ::std::string::String,
    pub cluster_secondary_range_name: ::std::string::String,
    pub services_secondary_range_name: ::std::string::String,
    pub cluster_ipv4_cidr_block: ::std::string::String,
    pub node_ipv4_cidr_block: ::std::string::String,
    pub services_ipv4_cidr_block: ::std::string::String,
    pub tpu_ipv4_cidr_block: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPAllocationPolicy {
    fn default() -> &'a IPAllocationPolicy {
        <IPAllocationPolicy as ::protobuf::Message>::default_instance()
    }
}

impl IPAllocationPolicy {
    pub fn new() -> IPAllocationPolicy {
        ::std::default::Default::default()
    }

    // bool use_ip_aliases = 1;


    pub fn get_use_ip_aliases(&self) -> bool {
        self.use_ip_aliases
    }
    pub fn clear_use_ip_aliases(&mut self) {
        self.use_ip_aliases = false;
    }

    // Param is passed by value, moved
    pub fn set_use_ip_aliases(&mut self, v: bool) {
        self.use_ip_aliases = v;
    }

    // bool create_subnetwork = 2;


    pub fn get_create_subnetwork(&self) -> bool {
        self.create_subnetwork
    }
    pub fn clear_create_subnetwork(&mut self) {
        self.create_subnetwork = false;
    }

    // Param is passed by value, moved
    pub fn set_create_subnetwork(&mut self, v: bool) {
        self.create_subnetwork = v;
    }

    // string subnetwork_name = 3;


    pub fn get_subnetwork_name(&self) -> &str {
        &self.subnetwork_name
    }
    pub fn clear_subnetwork_name(&mut self) {
        self.subnetwork_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_subnetwork_name(&mut self, v: ::std::string::String) {
        self.subnetwork_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subnetwork_name(&mut self) -> &mut ::std::string::String {
        &mut self.subnetwork_name
    }

    // Take field
    pub fn take_subnetwork_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subnetwork_name, ::std::string::String::new())
    }

    // string cluster_ipv4_cidr = 4;


    pub fn get_cluster_ipv4_cidr(&self) -> &str {
        &self.cluster_ipv4_cidr
    }
    pub fn clear_cluster_ipv4_cidr(&mut self) {
        self.cluster_ipv4_cidr.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_ipv4_cidr(&mut self, v: ::std::string::String) {
        self.cluster_ipv4_cidr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_ipv4_cidr(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_ipv4_cidr
    }

    // Take field
    pub fn take_cluster_ipv4_cidr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_ipv4_cidr, ::std::string::String::new())
    }

    // string node_ipv4_cidr = 5;


    pub fn get_node_ipv4_cidr(&self) -> &str {
        &self.node_ipv4_cidr
    }
    pub fn clear_node_ipv4_cidr(&mut self) {
        self.node_ipv4_cidr.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_ipv4_cidr(&mut self, v: ::std::string::String) {
        self.node_ipv4_cidr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_ipv4_cidr(&mut self) -> &mut ::std::string::String {
        &mut self.node_ipv4_cidr
    }

    // Take field
    pub fn take_node_ipv4_cidr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_ipv4_cidr, ::std::string::String::new())
    }

    // string services_ipv4_cidr = 6;


    pub fn get_services_ipv4_cidr(&self) -> &str {
        &self.services_ipv4_cidr
    }
    pub fn clear_services_ipv4_cidr(&mut self) {
        self.services_ipv4_cidr.clear();
    }

    // Param is passed by value, moved
    pub fn set_services_ipv4_cidr(&mut self, v: ::std::string::String) {
        self.services_ipv4_cidr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_services_ipv4_cidr(&mut self) -> &mut ::std::string::String {
        &mut self.services_ipv4_cidr
    }

    // Take field
    pub fn take_services_ipv4_cidr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.services_ipv4_cidr, ::std::string::String::new())
    }

    // string cluster_secondary_range_name = 7;


    pub fn get_cluster_secondary_range_name(&self) -> &str {
        &self.cluster_secondary_range_name
    }
    pub fn clear_cluster_secondary_range_name(&mut self) {
        self.cluster_secondary_range_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_secondary_range_name(&mut self, v: ::std::string::String) {
        self.cluster_secondary_range_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_secondary_range_name(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_secondary_range_name
    }

    // Take field
    pub fn take_cluster_secondary_range_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_secondary_range_name, ::std::string::String::new())
    }

    // string services_secondary_range_name = 8;


    pub fn get_services_secondary_range_name(&self) -> &str {
        &self.services_secondary_range_name
    }
    pub fn clear_services_secondary_range_name(&mut self) {
        self.services_secondary_range_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_services_secondary_range_name(&mut self, v: ::std::string::String) {
        self.services_secondary_range_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_services_secondary_range_name(&mut self) -> &mut ::std::string::String {
        &mut self.services_secondary_range_name
    }

    // Take field
    pub fn take_services_secondary_range_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.services_secondary_range_name, ::std::string::String::new())
    }

    // string cluster_ipv4_cidr_block = 9;


    pub fn get_cluster_ipv4_cidr_block(&self) -> &str {
        &self.cluster_ipv4_cidr_block
    }
    pub fn clear_cluster_ipv4_cidr_block(&mut self) {
        self.cluster_ipv4_cidr_block.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_ipv4_cidr_block(&mut self, v: ::std::string::String) {
        self.cluster_ipv4_cidr_block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_ipv4_cidr_block(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_ipv4_cidr_block
    }

    // Take field
    pub fn take_cluster_ipv4_cidr_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_ipv4_cidr_block, ::std::string::String::new())
    }

    // string node_ipv4_cidr_block = 10;


    pub fn get_node_ipv4_cidr_block(&self) -> &str {
        &self.node_ipv4_cidr_block
    }
    pub fn clear_node_ipv4_cidr_block(&mut self) {
        self.node_ipv4_cidr_block.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_ipv4_cidr_block(&mut self, v: ::std::string::String) {
        self.node_ipv4_cidr_block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_ipv4_cidr_block(&mut self) -> &mut ::std::string::String {
        &mut self.node_ipv4_cidr_block
    }

    // Take field
    pub fn take_node_ipv4_cidr_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_ipv4_cidr_block, ::std::string::String::new())
    }

    // string services_ipv4_cidr_block = 11;


    pub fn get_services_ipv4_cidr_block(&self) -> &str {
        &self.services_ipv4_cidr_block
    }
    pub fn clear_services_ipv4_cidr_block(&mut self) {
        self.services_ipv4_cidr_block.clear();
    }

    // Param is passed by value, moved
    pub fn set_services_ipv4_cidr_block(&mut self, v: ::std::string::String) {
        self.services_ipv4_cidr_block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_services_ipv4_cidr_block(&mut self) -> &mut ::std::string::String {
        &mut self.services_ipv4_cidr_block
    }

    // Take field
    pub fn take_services_ipv4_cidr_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.services_ipv4_cidr_block, ::std::string::String::new())
    }

    // string tpu_ipv4_cidr_block = 13;


    pub fn get_tpu_ipv4_cidr_block(&self) -> &str {
        &self.tpu_ipv4_cidr_block
    }
    pub fn clear_tpu_ipv4_cidr_block(&mut self) {
        self.tpu_ipv4_cidr_block.clear();
    }

    // Param is passed by value, moved
    pub fn set_tpu_ipv4_cidr_block(&mut self, v: ::std::string::String) {
        self.tpu_ipv4_cidr_block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tpu_ipv4_cidr_block(&mut self) -> &mut ::std::string::String {
        &mut self.tpu_ipv4_cidr_block
    }

    // Take field
    pub fn take_tpu_ipv4_cidr_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tpu_ipv4_cidr_block, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IPAllocationPolicy {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.use_ip_aliases = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.create_subnetwork = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subnetwork_name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_ipv4_cidr)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_ipv4_cidr)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.services_ipv4_cidr)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_secondary_range_name)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.services_secondary_range_name)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_ipv4_cidr_block)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_ipv4_cidr_block)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.services_ipv4_cidr_block)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tpu_ipv4_cidr_block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.use_ip_aliases != false {
            my_size += 2;
        }
        if self.create_subnetwork != false {
            my_size += 2;
        }
        if !self.subnetwork_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.subnetwork_name);
        }
        if !self.cluster_ipv4_cidr.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.cluster_ipv4_cidr);
        }
        if !self.node_ipv4_cidr.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.node_ipv4_cidr);
        }
        if !self.services_ipv4_cidr.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.services_ipv4_cidr);
        }
        if !self.cluster_secondary_range_name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.cluster_secondary_range_name);
        }
        if !self.services_secondary_range_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.services_secondary_range_name);
        }
        if !self.cluster_ipv4_cidr_block.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.cluster_ipv4_cidr_block);
        }
        if !self.node_ipv4_cidr_block.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.node_ipv4_cidr_block);
        }
        if !self.services_ipv4_cidr_block.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.services_ipv4_cidr_block);
        }
        if !self.tpu_ipv4_cidr_block.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.tpu_ipv4_cidr_block);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.use_ip_aliases != false {
            os.write_bool(1, self.use_ip_aliases)?;
        }
        if self.create_subnetwork != false {
            os.write_bool(2, self.create_subnetwork)?;
        }
        if !self.subnetwork_name.is_empty() {
            os.write_string(3, &self.subnetwork_name)?;
        }
        if !self.cluster_ipv4_cidr.is_empty() {
            os.write_string(4, &self.cluster_ipv4_cidr)?;
        }
        if !self.node_ipv4_cidr.is_empty() {
            os.write_string(5, &self.node_ipv4_cidr)?;
        }
        if !self.services_ipv4_cidr.is_empty() {
            os.write_string(6, &self.services_ipv4_cidr)?;
        }
        if !self.cluster_secondary_range_name.is_empty() {
            os.write_string(7, &self.cluster_secondary_range_name)?;
        }
        if !self.services_secondary_range_name.is_empty() {
            os.write_string(8, &self.services_secondary_range_name)?;
        }
        if !self.cluster_ipv4_cidr_block.is_empty() {
            os.write_string(9, &self.cluster_ipv4_cidr_block)?;
        }
        if !self.node_ipv4_cidr_block.is_empty() {
            os.write_string(10, &self.node_ipv4_cidr_block)?;
        }
        if !self.services_ipv4_cidr_block.is_empty() {
            os.write_string(11, &self.services_ipv4_cidr_block)?;
        }
        if !self.tpu_ipv4_cidr_block.is_empty() {
            os.write_string(13, &self.tpu_ipv4_cidr_block)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPAllocationPolicy {
        IPAllocationPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "use_ip_aliases",
                |m: &IPAllocationPolicy| { &m.use_ip_aliases },
                |m: &mut IPAllocationPolicy| { &mut m.use_ip_aliases },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "create_subnetwork",
                |m: &IPAllocationPolicy| { &m.create_subnetwork },
                |m: &mut IPAllocationPolicy| { &mut m.create_subnetwork },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subnetwork_name",
                |m: &IPAllocationPolicy| { &m.subnetwork_name },
                |m: &mut IPAllocationPolicy| { &mut m.subnetwork_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_ipv4_cidr",
                |m: &IPAllocationPolicy| { &m.cluster_ipv4_cidr },
                |m: &mut IPAllocationPolicy| { &mut m.cluster_ipv4_cidr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_ipv4_cidr",
                |m: &IPAllocationPolicy| { &m.node_ipv4_cidr },
                |m: &mut IPAllocationPolicy| { &mut m.node_ipv4_cidr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "services_ipv4_cidr",
                |m: &IPAllocationPolicy| { &m.services_ipv4_cidr },
                |m: &mut IPAllocationPolicy| { &mut m.services_ipv4_cidr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_secondary_range_name",
                |m: &IPAllocationPolicy| { &m.cluster_secondary_range_name },
                |m: &mut IPAllocationPolicy| { &mut m.cluster_secondary_range_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "services_secondary_range_name",
                |m: &IPAllocationPolicy| { &m.services_secondary_range_name },
                |m: &mut IPAllocationPolicy| { &mut m.services_secondary_range_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_ipv4_cidr_block",
                |m: &IPAllocationPolicy| { &m.cluster_ipv4_cidr_block },
                |m: &mut IPAllocationPolicy| { &mut m.cluster_ipv4_cidr_block },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_ipv4_cidr_block",
                |m: &IPAllocationPolicy| { &m.node_ipv4_cidr_block },
                |m: &mut IPAllocationPolicy| { &mut m.node_ipv4_cidr_block },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "services_ipv4_cidr_block",
                |m: &IPAllocationPolicy| { &m.services_ipv4_cidr_block },
                |m: &mut IPAllocationPolicy| { &mut m.services_ipv4_cidr_block },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tpu_ipv4_cidr_block",
                |m: &IPAllocationPolicy| { &m.tpu_ipv4_cidr_block },
                |m: &mut IPAllocationPolicy| { &mut m.tpu_ipv4_cidr_block },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPAllocationPolicy>(
                "IPAllocationPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IPAllocationPolicy {
        static instance: ::protobuf::rt::LazyV2<IPAllocationPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IPAllocationPolicy::new)
    }
}

impl ::protobuf::Clear for IPAllocationPolicy {
    fn clear(&mut self) {
        self.use_ip_aliases = false;
        self.create_subnetwork = false;
        self.subnetwork_name.clear();
        self.cluster_ipv4_cidr.clear();
        self.node_ipv4_cidr.clear();
        self.services_ipv4_cidr.clear();
        self.cluster_secondary_range_name.clear();
        self.services_secondary_range_name.clear();
        self.cluster_ipv4_cidr_block.clear();
        self.node_ipv4_cidr_block.clear();
        self.services_ipv4_cidr_block.clear();
        self.tpu_ipv4_cidr_block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPAllocationPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPAllocationPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Cluster {
    // message fields
    pub name: ::std::string::String,
    pub description: ::std::string::String,
    pub initial_node_count: i32,
    pub node_config: ::protobuf::SingularPtrField<NodeConfig>,
    pub master_auth: ::protobuf::SingularPtrField<MasterAuth>,
    pub logging_service: ::std::string::String,
    pub monitoring_service: ::std::string::String,
    pub network: ::std::string::String,
    pub cluster_ipv4_cidr: ::std::string::String,
    pub addons_config: ::protobuf::SingularPtrField<AddonsConfig>,
    pub subnetwork: ::std::string::String,
    pub node_pools: ::protobuf::RepeatedField<NodePool>,
    pub locations: ::protobuf::RepeatedField<::std::string::String>,
    pub enable_kubernetes_alpha: bool,
    pub resource_labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub label_fingerprint: ::std::string::String,
    pub legacy_abac: ::protobuf::SingularPtrField<LegacyAbac>,
    pub network_policy: ::protobuf::SingularPtrField<NetworkPolicy>,
    pub ip_allocation_policy: ::protobuf::SingularPtrField<IPAllocationPolicy>,
    pub master_authorized_networks_config: ::protobuf::SingularPtrField<MasterAuthorizedNetworksConfig>,
    pub maintenance_policy: ::protobuf::SingularPtrField<MaintenancePolicy>,
    pub binary_authorization: ::protobuf::SingularPtrField<BinaryAuthorization>,
    pub autoscaling: ::protobuf::SingularPtrField<ClusterAutoscaling>,
    pub network_config: ::protobuf::SingularPtrField<NetworkConfig>,
    pub default_max_pods_constraint: ::protobuf::SingularPtrField<MaxPodsConstraint>,
    pub resource_usage_export_config: ::protobuf::SingularPtrField<ResourceUsageExportConfig>,
    pub authenticator_groups_config: ::protobuf::SingularPtrField<AuthenticatorGroupsConfig>,
    pub private_cluster_config: ::protobuf::SingularPtrField<PrivateClusterConfig>,
    pub database_encryption: ::protobuf::SingularPtrField<DatabaseEncryption>,
    pub vertical_pod_autoscaling: ::protobuf::SingularPtrField<VerticalPodAutoscaling>,
    pub self_link: ::std::string::String,
    pub zone: ::std::string::String,
    pub endpoint: ::std::string::String,
    pub initial_cluster_version: ::std::string::String,
    pub current_master_version: ::std::string::String,
    pub current_node_version: ::std::string::String,
    pub create_time: ::std::string::String,
    pub status: Cluster_Status,
    pub status_message: ::std::string::String,
    pub node_ipv4_cidr_size: i32,
    pub services_ipv4_cidr: ::std::string::String,
    pub instance_group_urls: ::protobuf::RepeatedField<::std::string::String>,
    pub current_node_count: i32,
    pub expire_time: ::std::string::String,
    pub location: ::std::string::String,
    pub enable_tpu: bool,
    pub tpu_ipv4_cidr_block: ::std::string::String,
    pub conditions: ::protobuf::RepeatedField<StatusCondition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cluster {
    fn default() -> &'a Cluster {
        <Cluster as ::protobuf::Message>::default_instance()
    }
}

impl Cluster {
    pub fn new() -> Cluster {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }

    // int32 initial_node_count = 3;


    pub fn get_initial_node_count(&self) -> i32 {
        self.initial_node_count
    }
    pub fn clear_initial_node_count(&mut self) {
        self.initial_node_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_initial_node_count(&mut self, v: i32) {
        self.initial_node_count = v;
    }

    // .google.container.v1.NodeConfig node_config = 4;


    pub fn get_node_config(&self) -> &NodeConfig {
        self.node_config.as_ref().unwrap_or_else(|| <NodeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_node_config(&mut self) {
        self.node_config.clear();
    }

    pub fn has_node_config(&self) -> bool {
        self.node_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_config(&mut self, v: NodeConfig) {
        self.node_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_config(&mut self) -> &mut NodeConfig {
        if self.node_config.is_none() {
            self.node_config.set_default();
        }
        self.node_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_config(&mut self) -> NodeConfig {
        self.node_config.take().unwrap_or_else(|| NodeConfig::new())
    }

    // .google.container.v1.MasterAuth master_auth = 5;


    pub fn get_master_auth(&self) -> &MasterAuth {
        self.master_auth.as_ref().unwrap_or_else(|| <MasterAuth as ::protobuf::Message>::default_instance())
    }
    pub fn clear_master_auth(&mut self) {
        self.master_auth.clear();
    }

    pub fn has_master_auth(&self) -> bool {
        self.master_auth.is_some()
    }

    // Param is passed by value, moved
    pub fn set_master_auth(&mut self, v: MasterAuth) {
        self.master_auth = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_master_auth(&mut self) -> &mut MasterAuth {
        if self.master_auth.is_none() {
            self.master_auth.set_default();
        }
        self.master_auth.as_mut().unwrap()
    }

    // Take field
    pub fn take_master_auth(&mut self) -> MasterAuth {
        self.master_auth.take().unwrap_or_else(|| MasterAuth::new())
    }

    // string logging_service = 6;


    pub fn get_logging_service(&self) -> &str {
        &self.logging_service
    }
    pub fn clear_logging_service(&mut self) {
        self.logging_service.clear();
    }

    // Param is passed by value, moved
    pub fn set_logging_service(&mut self, v: ::std::string::String) {
        self.logging_service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logging_service(&mut self) -> &mut ::std::string::String {
        &mut self.logging_service
    }

    // Take field
    pub fn take_logging_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logging_service, ::std::string::String::new())
    }

    // string monitoring_service = 7;


    pub fn get_monitoring_service(&self) -> &str {
        &self.monitoring_service
    }
    pub fn clear_monitoring_service(&mut self) {
        self.monitoring_service.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitoring_service(&mut self, v: ::std::string::String) {
        self.monitoring_service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_monitoring_service(&mut self) -> &mut ::std::string::String {
        &mut self.monitoring_service
    }

    // Take field
    pub fn take_monitoring_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.monitoring_service, ::std::string::String::new())
    }

    // string network = 8;


    pub fn get_network(&self) -> &str {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::std::string::String) {
        self.network = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut ::std::string::String {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.network, ::std::string::String::new())
    }

    // string cluster_ipv4_cidr = 9;


    pub fn get_cluster_ipv4_cidr(&self) -> &str {
        &self.cluster_ipv4_cidr
    }
    pub fn clear_cluster_ipv4_cidr(&mut self) {
        self.cluster_ipv4_cidr.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_ipv4_cidr(&mut self, v: ::std::string::String) {
        self.cluster_ipv4_cidr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_ipv4_cidr(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_ipv4_cidr
    }

    // Take field
    pub fn take_cluster_ipv4_cidr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_ipv4_cidr, ::std::string::String::new())
    }

    // .google.container.v1.AddonsConfig addons_config = 10;


    pub fn get_addons_config(&self) -> &AddonsConfig {
        self.addons_config.as_ref().unwrap_or_else(|| <AddonsConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addons_config(&mut self) {
        self.addons_config.clear();
    }

    pub fn has_addons_config(&self) -> bool {
        self.addons_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addons_config(&mut self, v: AddonsConfig) {
        self.addons_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addons_config(&mut self) -> &mut AddonsConfig {
        if self.addons_config.is_none() {
            self.addons_config.set_default();
        }
        self.addons_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_addons_config(&mut self) -> AddonsConfig {
        self.addons_config.take().unwrap_or_else(|| AddonsConfig::new())
    }

    // string subnetwork = 11;


    pub fn get_subnetwork(&self) -> &str {
        &self.subnetwork
    }
    pub fn clear_subnetwork(&mut self) {
        self.subnetwork.clear();
    }

    // Param is passed by value, moved
    pub fn set_subnetwork(&mut self, v: ::std::string::String) {
        self.subnetwork = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subnetwork(&mut self) -> &mut ::std::string::String {
        &mut self.subnetwork
    }

    // Take field
    pub fn take_subnetwork(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subnetwork, ::std::string::String::new())
    }

    // repeated .google.container.v1.NodePool node_pools = 12;


    pub fn get_node_pools(&self) -> &[NodePool] {
        &self.node_pools
    }
    pub fn clear_node_pools(&mut self) {
        self.node_pools.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pools(&mut self, v: ::protobuf::RepeatedField<NodePool>) {
        self.node_pools = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node_pools(&mut self) -> &mut ::protobuf::RepeatedField<NodePool> {
        &mut self.node_pools
    }

    // Take field
    pub fn take_node_pools(&mut self) -> ::protobuf::RepeatedField<NodePool> {
        ::std::mem::replace(&mut self.node_pools, ::protobuf::RepeatedField::new())
    }

    // repeated string locations = 13;


    pub fn get_locations(&self) -> &[::std::string::String] {
        &self.locations
    }
    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.locations
    }

    // Take field
    pub fn take_locations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.locations, ::protobuf::RepeatedField::new())
    }

    // bool enable_kubernetes_alpha = 14;


    pub fn get_enable_kubernetes_alpha(&self) -> bool {
        self.enable_kubernetes_alpha
    }
    pub fn clear_enable_kubernetes_alpha(&mut self) {
        self.enable_kubernetes_alpha = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_kubernetes_alpha(&mut self, v: bool) {
        self.enable_kubernetes_alpha = v;
    }

    // repeated .google.container.v1.Cluster.ResourceLabelsEntry resource_labels = 15;


    pub fn get_resource_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.resource_labels
    }
    pub fn clear_resource_labels(&mut self) {
        self.resource_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.resource_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.resource_labels
    }

    // Take field
    pub fn take_resource_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.resource_labels, ::std::collections::HashMap::new())
    }

    // string label_fingerprint = 16;


    pub fn get_label_fingerprint(&self) -> &str {
        &self.label_fingerprint
    }
    pub fn clear_label_fingerprint(&mut self) {
        self.label_fingerprint.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_fingerprint(&mut self, v: ::std::string::String) {
        self.label_fingerprint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label_fingerprint(&mut self) -> &mut ::std::string::String {
        &mut self.label_fingerprint
    }

    // Take field
    pub fn take_label_fingerprint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label_fingerprint, ::std::string::String::new())
    }

    // .google.container.v1.LegacyAbac legacy_abac = 18;


    pub fn get_legacy_abac(&self) -> &LegacyAbac {
        self.legacy_abac.as_ref().unwrap_or_else(|| <LegacyAbac as ::protobuf::Message>::default_instance())
    }
    pub fn clear_legacy_abac(&mut self) {
        self.legacy_abac.clear();
    }

    pub fn has_legacy_abac(&self) -> bool {
        self.legacy_abac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_legacy_abac(&mut self, v: LegacyAbac) {
        self.legacy_abac = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_legacy_abac(&mut self) -> &mut LegacyAbac {
        if self.legacy_abac.is_none() {
            self.legacy_abac.set_default();
        }
        self.legacy_abac.as_mut().unwrap()
    }

    // Take field
    pub fn take_legacy_abac(&mut self) -> LegacyAbac {
        self.legacy_abac.take().unwrap_or_else(|| LegacyAbac::new())
    }

    // .google.container.v1.NetworkPolicy network_policy = 19;


    pub fn get_network_policy(&self) -> &NetworkPolicy {
        self.network_policy.as_ref().unwrap_or_else(|| <NetworkPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_network_policy(&mut self) {
        self.network_policy.clear();
    }

    pub fn has_network_policy(&self) -> bool {
        self.network_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_policy(&mut self, v: NetworkPolicy) {
        self.network_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network_policy(&mut self) -> &mut NetworkPolicy {
        if self.network_policy.is_none() {
            self.network_policy.set_default();
        }
        self.network_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_network_policy(&mut self) -> NetworkPolicy {
        self.network_policy.take().unwrap_or_else(|| NetworkPolicy::new())
    }

    // .google.container.v1.IPAllocationPolicy ip_allocation_policy = 20;


    pub fn get_ip_allocation_policy(&self) -> &IPAllocationPolicy {
        self.ip_allocation_policy.as_ref().unwrap_or_else(|| <IPAllocationPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ip_allocation_policy(&mut self) {
        self.ip_allocation_policy.clear();
    }

    pub fn has_ip_allocation_policy(&self) -> bool {
        self.ip_allocation_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip_allocation_policy(&mut self, v: IPAllocationPolicy) {
        self.ip_allocation_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_allocation_policy(&mut self) -> &mut IPAllocationPolicy {
        if self.ip_allocation_policy.is_none() {
            self.ip_allocation_policy.set_default();
        }
        self.ip_allocation_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip_allocation_policy(&mut self) -> IPAllocationPolicy {
        self.ip_allocation_policy.take().unwrap_or_else(|| IPAllocationPolicy::new())
    }

    // .google.container.v1.MasterAuthorizedNetworksConfig master_authorized_networks_config = 22;


    pub fn get_master_authorized_networks_config(&self) -> &MasterAuthorizedNetworksConfig {
        self.master_authorized_networks_config.as_ref().unwrap_or_else(|| <MasterAuthorizedNetworksConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_master_authorized_networks_config(&mut self) {
        self.master_authorized_networks_config.clear();
    }

    pub fn has_master_authorized_networks_config(&self) -> bool {
        self.master_authorized_networks_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_master_authorized_networks_config(&mut self, v: MasterAuthorizedNetworksConfig) {
        self.master_authorized_networks_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_master_authorized_networks_config(&mut self) -> &mut MasterAuthorizedNetworksConfig {
        if self.master_authorized_networks_config.is_none() {
            self.master_authorized_networks_config.set_default();
        }
        self.master_authorized_networks_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_master_authorized_networks_config(&mut self) -> MasterAuthorizedNetworksConfig {
        self.master_authorized_networks_config.take().unwrap_or_else(|| MasterAuthorizedNetworksConfig::new())
    }

    // .google.container.v1.MaintenancePolicy maintenance_policy = 23;


    pub fn get_maintenance_policy(&self) -> &MaintenancePolicy {
        self.maintenance_policy.as_ref().unwrap_or_else(|| <MaintenancePolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_maintenance_policy(&mut self) {
        self.maintenance_policy.clear();
    }

    pub fn has_maintenance_policy(&self) -> bool {
        self.maintenance_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maintenance_policy(&mut self, v: MaintenancePolicy) {
        self.maintenance_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maintenance_policy(&mut self) -> &mut MaintenancePolicy {
        if self.maintenance_policy.is_none() {
            self.maintenance_policy.set_default();
        }
        self.maintenance_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_maintenance_policy(&mut self) -> MaintenancePolicy {
        self.maintenance_policy.take().unwrap_or_else(|| MaintenancePolicy::new())
    }

    // .google.container.v1.BinaryAuthorization binary_authorization = 24;


    pub fn get_binary_authorization(&self) -> &BinaryAuthorization {
        self.binary_authorization.as_ref().unwrap_or_else(|| <BinaryAuthorization as ::protobuf::Message>::default_instance())
    }
    pub fn clear_binary_authorization(&mut self) {
        self.binary_authorization.clear();
    }

    pub fn has_binary_authorization(&self) -> bool {
        self.binary_authorization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_binary_authorization(&mut self, v: BinaryAuthorization) {
        self.binary_authorization = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_binary_authorization(&mut self) -> &mut BinaryAuthorization {
        if self.binary_authorization.is_none() {
            self.binary_authorization.set_default();
        }
        self.binary_authorization.as_mut().unwrap()
    }

    // Take field
    pub fn take_binary_authorization(&mut self) -> BinaryAuthorization {
        self.binary_authorization.take().unwrap_or_else(|| BinaryAuthorization::new())
    }

    // .google.container.v1.ClusterAutoscaling autoscaling = 26;


    pub fn get_autoscaling(&self) -> &ClusterAutoscaling {
        self.autoscaling.as_ref().unwrap_or_else(|| <ClusterAutoscaling as ::protobuf::Message>::default_instance())
    }
    pub fn clear_autoscaling(&mut self) {
        self.autoscaling.clear();
    }

    pub fn has_autoscaling(&self) -> bool {
        self.autoscaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autoscaling(&mut self, v: ClusterAutoscaling) {
        self.autoscaling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_autoscaling(&mut self) -> &mut ClusterAutoscaling {
        if self.autoscaling.is_none() {
            self.autoscaling.set_default();
        }
        self.autoscaling.as_mut().unwrap()
    }

    // Take field
    pub fn take_autoscaling(&mut self) -> ClusterAutoscaling {
        self.autoscaling.take().unwrap_or_else(|| ClusterAutoscaling::new())
    }

    // .google.container.v1.NetworkConfig network_config = 27;


    pub fn get_network_config(&self) -> &NetworkConfig {
        self.network_config.as_ref().unwrap_or_else(|| <NetworkConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_network_config(&mut self) {
        self.network_config.clear();
    }

    pub fn has_network_config(&self) -> bool {
        self.network_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_config(&mut self, v: NetworkConfig) {
        self.network_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network_config(&mut self) -> &mut NetworkConfig {
        if self.network_config.is_none() {
            self.network_config.set_default();
        }
        self.network_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_network_config(&mut self) -> NetworkConfig {
        self.network_config.take().unwrap_or_else(|| NetworkConfig::new())
    }

    // .google.container.v1.MaxPodsConstraint default_max_pods_constraint = 30;


    pub fn get_default_max_pods_constraint(&self) -> &MaxPodsConstraint {
        self.default_max_pods_constraint.as_ref().unwrap_or_else(|| <MaxPodsConstraint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_default_max_pods_constraint(&mut self) {
        self.default_max_pods_constraint.clear();
    }

    pub fn has_default_max_pods_constraint(&self) -> bool {
        self.default_max_pods_constraint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_default_max_pods_constraint(&mut self, v: MaxPodsConstraint) {
        self.default_max_pods_constraint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_max_pods_constraint(&mut self) -> &mut MaxPodsConstraint {
        if self.default_max_pods_constraint.is_none() {
            self.default_max_pods_constraint.set_default();
        }
        self.default_max_pods_constraint.as_mut().unwrap()
    }

    // Take field
    pub fn take_default_max_pods_constraint(&mut self) -> MaxPodsConstraint {
        self.default_max_pods_constraint.take().unwrap_or_else(|| MaxPodsConstraint::new())
    }

    // .google.container.v1.ResourceUsageExportConfig resource_usage_export_config = 33;


    pub fn get_resource_usage_export_config(&self) -> &ResourceUsageExportConfig {
        self.resource_usage_export_config.as_ref().unwrap_or_else(|| <ResourceUsageExportConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resource_usage_export_config(&mut self) {
        self.resource_usage_export_config.clear();
    }

    pub fn has_resource_usage_export_config(&self) -> bool {
        self.resource_usage_export_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource_usage_export_config(&mut self, v: ResourceUsageExportConfig) {
        self.resource_usage_export_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_usage_export_config(&mut self) -> &mut ResourceUsageExportConfig {
        if self.resource_usage_export_config.is_none() {
            self.resource_usage_export_config.set_default();
        }
        self.resource_usage_export_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource_usage_export_config(&mut self) -> ResourceUsageExportConfig {
        self.resource_usage_export_config.take().unwrap_or_else(|| ResourceUsageExportConfig::new())
    }

    // .google.container.v1.AuthenticatorGroupsConfig authenticator_groups_config = 34;


    pub fn get_authenticator_groups_config(&self) -> &AuthenticatorGroupsConfig {
        self.authenticator_groups_config.as_ref().unwrap_or_else(|| <AuthenticatorGroupsConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authenticator_groups_config(&mut self) {
        self.authenticator_groups_config.clear();
    }

    pub fn has_authenticator_groups_config(&self) -> bool {
        self.authenticator_groups_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authenticator_groups_config(&mut self, v: AuthenticatorGroupsConfig) {
        self.authenticator_groups_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authenticator_groups_config(&mut self) -> &mut AuthenticatorGroupsConfig {
        if self.authenticator_groups_config.is_none() {
            self.authenticator_groups_config.set_default();
        }
        self.authenticator_groups_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_authenticator_groups_config(&mut self) -> AuthenticatorGroupsConfig {
        self.authenticator_groups_config.take().unwrap_or_else(|| AuthenticatorGroupsConfig::new())
    }

    // .google.container.v1.PrivateClusterConfig private_cluster_config = 37;


    pub fn get_private_cluster_config(&self) -> &PrivateClusterConfig {
        self.private_cluster_config.as_ref().unwrap_or_else(|| <PrivateClusterConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_private_cluster_config(&mut self) {
        self.private_cluster_config.clear();
    }

    pub fn has_private_cluster_config(&self) -> bool {
        self.private_cluster_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_private_cluster_config(&mut self, v: PrivateClusterConfig) {
        self.private_cluster_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_private_cluster_config(&mut self) -> &mut PrivateClusterConfig {
        if self.private_cluster_config.is_none() {
            self.private_cluster_config.set_default();
        }
        self.private_cluster_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_private_cluster_config(&mut self) -> PrivateClusterConfig {
        self.private_cluster_config.take().unwrap_or_else(|| PrivateClusterConfig::new())
    }

    // .google.container.v1.DatabaseEncryption database_encryption = 38;


    pub fn get_database_encryption(&self) -> &DatabaseEncryption {
        self.database_encryption.as_ref().unwrap_or_else(|| <DatabaseEncryption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_database_encryption(&mut self) {
        self.database_encryption.clear();
    }

    pub fn has_database_encryption(&self) -> bool {
        self.database_encryption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_database_encryption(&mut self, v: DatabaseEncryption) {
        self.database_encryption = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_database_encryption(&mut self) -> &mut DatabaseEncryption {
        if self.database_encryption.is_none() {
            self.database_encryption.set_default();
        }
        self.database_encryption.as_mut().unwrap()
    }

    // Take field
    pub fn take_database_encryption(&mut self) -> DatabaseEncryption {
        self.database_encryption.take().unwrap_or_else(|| DatabaseEncryption::new())
    }

    // .google.container.v1.VerticalPodAutoscaling vertical_pod_autoscaling = 39;


    pub fn get_vertical_pod_autoscaling(&self) -> &VerticalPodAutoscaling {
        self.vertical_pod_autoscaling.as_ref().unwrap_or_else(|| <VerticalPodAutoscaling as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vertical_pod_autoscaling(&mut self) {
        self.vertical_pod_autoscaling.clear();
    }

    pub fn has_vertical_pod_autoscaling(&self) -> bool {
        self.vertical_pod_autoscaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vertical_pod_autoscaling(&mut self, v: VerticalPodAutoscaling) {
        self.vertical_pod_autoscaling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vertical_pod_autoscaling(&mut self) -> &mut VerticalPodAutoscaling {
        if self.vertical_pod_autoscaling.is_none() {
            self.vertical_pod_autoscaling.set_default();
        }
        self.vertical_pod_autoscaling.as_mut().unwrap()
    }

    // Take field
    pub fn take_vertical_pod_autoscaling(&mut self) -> VerticalPodAutoscaling {
        self.vertical_pod_autoscaling.take().unwrap_or_else(|| VerticalPodAutoscaling::new())
    }

    // string self_link = 100;


    pub fn get_self_link(&self) -> &str {
        &self.self_link
    }
    pub fn clear_self_link(&mut self) {
        self.self_link.clear();
    }

    // Param is passed by value, moved
    pub fn set_self_link(&mut self, v: ::std::string::String) {
        self.self_link = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_self_link(&mut self) -> &mut ::std::string::String {
        &mut self.self_link
    }

    // Take field
    pub fn take_self_link(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.self_link, ::std::string::String::new())
    }

    // string zone = 101;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string endpoint = 102;


    pub fn get_endpoint(&self) -> &str {
        &self.endpoint
    }
    pub fn clear_endpoint(&mut self) {
        self.endpoint.clear();
    }

    // Param is passed by value, moved
    pub fn set_endpoint(&mut self, v: ::std::string::String) {
        self.endpoint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoint(&mut self) -> &mut ::std::string::String {
        &mut self.endpoint
    }

    // Take field
    pub fn take_endpoint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.endpoint, ::std::string::String::new())
    }

    // string initial_cluster_version = 103;


    pub fn get_initial_cluster_version(&self) -> &str {
        &self.initial_cluster_version
    }
    pub fn clear_initial_cluster_version(&mut self) {
        self.initial_cluster_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_initial_cluster_version(&mut self, v: ::std::string::String) {
        self.initial_cluster_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initial_cluster_version(&mut self) -> &mut ::std::string::String {
        &mut self.initial_cluster_version
    }

    // Take field
    pub fn take_initial_cluster_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initial_cluster_version, ::std::string::String::new())
    }

    // string current_master_version = 104;


    pub fn get_current_master_version(&self) -> &str {
        &self.current_master_version
    }
    pub fn clear_current_master_version(&mut self) {
        self.current_master_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_master_version(&mut self, v: ::std::string::String) {
        self.current_master_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_master_version(&mut self) -> &mut ::std::string::String {
        &mut self.current_master_version
    }

    // Take field
    pub fn take_current_master_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.current_master_version, ::std::string::String::new())
    }

    // string current_node_version = 105;


    pub fn get_current_node_version(&self) -> &str {
        &self.current_node_version
    }
    pub fn clear_current_node_version(&mut self) {
        self.current_node_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_current_node_version(&mut self, v: ::std::string::String) {
        self.current_node_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_current_node_version(&mut self) -> &mut ::std::string::String {
        &mut self.current_node_version
    }

    // Take field
    pub fn take_current_node_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.current_node_version, ::std::string::String::new())
    }

    // string create_time = 106;


    pub fn get_create_time(&self) -> &str {
        &self.create_time
    }
    pub fn clear_create_time(&mut self) {
        self.create_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_create_time(&mut self, v: ::std::string::String) {
        self.create_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_create_time(&mut self) -> &mut ::std::string::String {
        &mut self.create_time
    }

    // Take field
    pub fn take_create_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.create_time, ::std::string::String::new())
    }

    // .google.container.v1.Cluster.Status status = 107;


    pub fn get_status(&self) -> Cluster_Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Cluster_Status::STATUS_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Cluster_Status) {
        self.status = v;
    }

    // string status_message = 108;


    pub fn get_status_message(&self) -> &str {
        &self.status_message
    }
    pub fn clear_status_message(&mut self) {
        self.status_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_status_message(&mut self, v: ::std::string::String) {
        self.status_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_message(&mut self) -> &mut ::std::string::String {
        &mut self.status_message
    }

    // Take field
    pub fn take_status_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status_message, ::std::string::String::new())
    }

    // int32 node_ipv4_cidr_size = 109;


    pub fn get_node_ipv4_cidr_size(&self) -> i32 {
        self.node_ipv4_cidr_size
    }
    pub fn clear_node_ipv4_cidr_size(&mut self) {
        self.node_ipv4_cidr_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_ipv4_cidr_size(&mut self, v: i32) {
        self.node_ipv4_cidr_size = v;
    }

    // string services_ipv4_cidr = 110;


    pub fn get_services_ipv4_cidr(&self) -> &str {
        &self.services_ipv4_cidr
    }
    pub fn clear_services_ipv4_cidr(&mut self) {
        self.services_ipv4_cidr.clear();
    }

    // Param is passed by value, moved
    pub fn set_services_ipv4_cidr(&mut self, v: ::std::string::String) {
        self.services_ipv4_cidr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_services_ipv4_cidr(&mut self) -> &mut ::std::string::String {
        &mut self.services_ipv4_cidr
    }

    // Take field
    pub fn take_services_ipv4_cidr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.services_ipv4_cidr, ::std::string::String::new())
    }

    // repeated string instance_group_urls = 111;


    pub fn get_instance_group_urls(&self) -> &[::std::string::String] {
        &self.instance_group_urls
    }
    pub fn clear_instance_group_urls(&mut self) {
        self.instance_group_urls.clear();
    }

    // Param is passed by value, moved
    pub fn set_instance_group_urls(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.instance_group_urls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instance_group_urls(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.instance_group_urls
    }

    // Take field
    pub fn take_instance_group_urls(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.instance_group_urls, ::protobuf::RepeatedField::new())
    }

    // int32 current_node_count = 112;


    pub fn get_current_node_count(&self) -> i32 {
        self.current_node_count
    }
    pub fn clear_current_node_count(&mut self) {
        self.current_node_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_current_node_count(&mut self, v: i32) {
        self.current_node_count = v;
    }

    // string expire_time = 113;


    pub fn get_expire_time(&self) -> &str {
        &self.expire_time
    }
    pub fn clear_expire_time(&mut self) {
        self.expire_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_expire_time(&mut self, v: ::std::string::String) {
        self.expire_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expire_time(&mut self) -> &mut ::std::string::String {
        &mut self.expire_time
    }

    // Take field
    pub fn take_expire_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.expire_time, ::std::string::String::new())
    }

    // string location = 114;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    // bool enable_tpu = 115;


    pub fn get_enable_tpu(&self) -> bool {
        self.enable_tpu
    }
    pub fn clear_enable_tpu(&mut self) {
        self.enable_tpu = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_tpu(&mut self, v: bool) {
        self.enable_tpu = v;
    }

    // string tpu_ipv4_cidr_block = 116;


    pub fn get_tpu_ipv4_cidr_block(&self) -> &str {
        &self.tpu_ipv4_cidr_block
    }
    pub fn clear_tpu_ipv4_cidr_block(&mut self) {
        self.tpu_ipv4_cidr_block.clear();
    }

    // Param is passed by value, moved
    pub fn set_tpu_ipv4_cidr_block(&mut self, v: ::std::string::String) {
        self.tpu_ipv4_cidr_block = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tpu_ipv4_cidr_block(&mut self) -> &mut ::std::string::String {
        &mut self.tpu_ipv4_cidr_block
    }

    // Take field
    pub fn take_tpu_ipv4_cidr_block(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tpu_ipv4_cidr_block, ::std::string::String::new())
    }

    // repeated .google.container.v1.StatusCondition conditions = 118;


    pub fn get_conditions(&self) -> &[StatusCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<StatusCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<StatusCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<StatusCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Cluster {
    fn is_initialized(&self) -> bool {
        for v in &self.node_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.master_auth {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addons_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.node_pools {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.legacy_abac {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ip_allocation_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.master_authorized_networks_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.maintenance_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.binary_authorization {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.autoscaling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.network_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.default_max_pods_constraint {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resource_usage_export_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authenticator_groups_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.private_cluster_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.database_encryption {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vertical_pod_autoscaling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.initial_node_count = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node_config)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.master_auth)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logging_service)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.monitoring_service)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.network)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_ipv4_cidr)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addons_config)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subnetwork)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node_pools)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.locations)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_kubernetes_alpha = tmp;
                },
                15 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.resource_labels)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label_fingerprint)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.legacy_abac)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.network_policy)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ip_allocation_policy)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.master_authorized_networks_config)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.maintenance_policy)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.binary_authorization)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.autoscaling)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.network_config)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.default_max_pods_constraint)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resource_usage_export_config)?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authenticator_groups_config)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.private_cluster_config)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.database_encryption)?;
                },
                39 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vertical_pod_autoscaling)?;
                },
                100 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.self_link)?;
                },
                101 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                102 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.endpoint)?;
                },
                103 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initial_cluster_version)?;
                },
                104 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.current_master_version)?;
                },
                105 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.current_node_version)?;
                },
                106 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.create_time)?;
                },
                107 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 107, &mut self.unknown_fields)?
                },
                108 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status_message)?;
                },
                109 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.node_ipv4_cidr_size = tmp;
                },
                110 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.services_ipv4_cidr)?;
                },
                111 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.instance_group_urls)?;
                },
                112 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.current_node_count = tmp;
                },
                113 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.expire_time)?;
                },
                114 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                115 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_tpu = tmp;
                },
                116 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tpu_ipv4_cidr_block)?;
                },
                118 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        if self.initial_node_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.initial_node_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.node_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.master_auth.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.logging_service.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.logging_service);
        }
        if !self.monitoring_service.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.monitoring_service);
        }
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.network);
        }
        if !self.cluster_ipv4_cidr.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.cluster_ipv4_cidr);
        }
        if let Some(ref v) = self.addons_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.subnetwork.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.subnetwork);
        }
        for value in &self.node_pools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.locations {
            my_size += ::protobuf::rt::string_size(13, &value);
        };
        if self.enable_kubernetes_alpha != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(15, &self.resource_labels);
        if !self.label_fingerprint.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.label_fingerprint);
        }
        if let Some(ref v) = self.legacy_abac.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.network_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ip_allocation_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.master_authorized_networks_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.maintenance_policy.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.binary_authorization.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.autoscaling.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.network_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.default_max_pods_constraint.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resource_usage_export_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authenticator_groups_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.private_cluster_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.database_encryption.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vertical_pod_autoscaling.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.self_link.is_empty() {
            my_size += ::protobuf::rt::string_size(100, &self.self_link);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(101, &self.zone);
        }
        if !self.endpoint.is_empty() {
            my_size += ::protobuf::rt::string_size(102, &self.endpoint);
        }
        if !self.initial_cluster_version.is_empty() {
            my_size += ::protobuf::rt::string_size(103, &self.initial_cluster_version);
        }
        if !self.current_master_version.is_empty() {
            my_size += ::protobuf::rt::string_size(104, &self.current_master_version);
        }
        if !self.current_node_version.is_empty() {
            my_size += ::protobuf::rt::string_size(105, &self.current_node_version);
        }
        if !self.create_time.is_empty() {
            my_size += ::protobuf::rt::string_size(106, &self.create_time);
        }
        if self.status != Cluster_Status::STATUS_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(107, self.status);
        }
        if !self.status_message.is_empty() {
            my_size += ::protobuf::rt::string_size(108, &self.status_message);
        }
        if self.node_ipv4_cidr_size != 0 {
            my_size += ::protobuf::rt::value_size(109, self.node_ipv4_cidr_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.services_ipv4_cidr.is_empty() {
            my_size += ::protobuf::rt::string_size(110, &self.services_ipv4_cidr);
        }
        for value in &self.instance_group_urls {
            my_size += ::protobuf::rt::string_size(111, &value);
        };
        if self.current_node_count != 0 {
            my_size += ::protobuf::rt::value_size(112, self.current_node_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.expire_time.is_empty() {
            my_size += ::protobuf::rt::string_size(113, &self.expire_time);
        }
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(114, &self.location);
        }
        if self.enable_tpu != false {
            my_size += 3;
        }
        if !self.tpu_ipv4_cidr_block.is_empty() {
            my_size += ::protobuf::rt::string_size(116, &self.tpu_ipv4_cidr_block);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        if self.initial_node_count != 0 {
            os.write_int32(3, self.initial_node_count)?;
        }
        if let Some(ref v) = self.node_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.master_auth.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.logging_service.is_empty() {
            os.write_string(6, &self.logging_service)?;
        }
        if !self.monitoring_service.is_empty() {
            os.write_string(7, &self.monitoring_service)?;
        }
        if !self.network.is_empty() {
            os.write_string(8, &self.network)?;
        }
        if !self.cluster_ipv4_cidr.is_empty() {
            os.write_string(9, &self.cluster_ipv4_cidr)?;
        }
        if let Some(ref v) = self.addons_config.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.subnetwork.is_empty() {
            os.write_string(11, &self.subnetwork)?;
        }
        for v in &self.node_pools {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.locations {
            os.write_string(13, &v)?;
        };
        if self.enable_kubernetes_alpha != false {
            os.write_bool(14, self.enable_kubernetes_alpha)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(15, &self.resource_labels, os)?;
        if !self.label_fingerprint.is_empty() {
            os.write_string(16, &self.label_fingerprint)?;
        }
        if let Some(ref v) = self.legacy_abac.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.network_policy.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ip_allocation_policy.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.master_authorized_networks_config.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.maintenance_policy.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.binary_authorization.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.autoscaling.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.network_config.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.default_max_pods_constraint.as_ref() {
            os.write_tag(30, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resource_usage_export_config.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authenticator_groups_config.as_ref() {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.private_cluster_config.as_ref() {
            os.write_tag(37, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.database_encryption.as_ref() {
            os.write_tag(38, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vertical_pod_autoscaling.as_ref() {
            os.write_tag(39, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.self_link.is_empty() {
            os.write_string(100, &self.self_link)?;
        }
        if !self.zone.is_empty() {
            os.write_string(101, &self.zone)?;
        }
        if !self.endpoint.is_empty() {
            os.write_string(102, &self.endpoint)?;
        }
        if !self.initial_cluster_version.is_empty() {
            os.write_string(103, &self.initial_cluster_version)?;
        }
        if !self.current_master_version.is_empty() {
            os.write_string(104, &self.current_master_version)?;
        }
        if !self.current_node_version.is_empty() {
            os.write_string(105, &self.current_node_version)?;
        }
        if !self.create_time.is_empty() {
            os.write_string(106, &self.create_time)?;
        }
        if self.status != Cluster_Status::STATUS_UNSPECIFIED {
            os.write_enum(107, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.status_message.is_empty() {
            os.write_string(108, &self.status_message)?;
        }
        if self.node_ipv4_cidr_size != 0 {
            os.write_int32(109, self.node_ipv4_cidr_size)?;
        }
        if !self.services_ipv4_cidr.is_empty() {
            os.write_string(110, &self.services_ipv4_cidr)?;
        }
        for v in &self.instance_group_urls {
            os.write_string(111, &v)?;
        };
        if self.current_node_count != 0 {
            os.write_int32(112, self.current_node_count)?;
        }
        if !self.expire_time.is_empty() {
            os.write_string(113, &self.expire_time)?;
        }
        if !self.location.is_empty() {
            os.write_string(114, &self.location)?;
        }
        if self.enable_tpu != false {
            os.write_bool(115, self.enable_tpu)?;
        }
        if !self.tpu_ipv4_cidr_block.is_empty() {
            os.write_string(116, &self.tpu_ipv4_cidr_block)?;
        }
        for v in &self.conditions {
            os.write_tag(118, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cluster {
        Cluster::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Cluster| { &m.name },
                |m: &mut Cluster| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &Cluster| { &m.description },
                |m: &mut Cluster| { &mut m.description },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "initial_node_count",
                |m: &Cluster| { &m.initial_node_count },
                |m: &mut Cluster| { &mut m.initial_node_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeConfig>>(
                "node_config",
                |m: &Cluster| { &m.node_config },
                |m: &mut Cluster| { &mut m.node_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MasterAuth>>(
                "master_auth",
                |m: &Cluster| { &m.master_auth },
                |m: &mut Cluster| { &mut m.master_auth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "logging_service",
                |m: &Cluster| { &m.logging_service },
                |m: &mut Cluster| { &mut m.logging_service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "monitoring_service",
                |m: &Cluster| { &m.monitoring_service },
                |m: &mut Cluster| { &mut m.monitoring_service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "network",
                |m: &Cluster| { &m.network },
                |m: &mut Cluster| { &mut m.network },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_ipv4_cidr",
                |m: &Cluster| { &m.cluster_ipv4_cidr },
                |m: &mut Cluster| { &mut m.cluster_ipv4_cidr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddonsConfig>>(
                "addons_config",
                |m: &Cluster| { &m.addons_config },
                |m: &mut Cluster| { &mut m.addons_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subnetwork",
                |m: &Cluster| { &m.subnetwork },
                |m: &mut Cluster| { &mut m.subnetwork },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePool>>(
                "node_pools",
                |m: &Cluster| { &m.node_pools },
                |m: &mut Cluster| { &mut m.node_pools },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "locations",
                |m: &Cluster| { &m.locations },
                |m: &mut Cluster| { &mut m.locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_kubernetes_alpha",
                |m: &Cluster| { &m.enable_kubernetes_alpha },
                |m: &mut Cluster| { &mut m.enable_kubernetes_alpha },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "resource_labels",
                |m: &Cluster| { &m.resource_labels },
                |m: &mut Cluster| { &mut m.resource_labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label_fingerprint",
                |m: &Cluster| { &m.label_fingerprint },
                |m: &mut Cluster| { &mut m.label_fingerprint },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LegacyAbac>>(
                "legacy_abac",
                |m: &Cluster| { &m.legacy_abac },
                |m: &mut Cluster| { &mut m.legacy_abac },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkPolicy>>(
                "network_policy",
                |m: &Cluster| { &m.network_policy },
                |m: &mut Cluster| { &mut m.network_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IPAllocationPolicy>>(
                "ip_allocation_policy",
                |m: &Cluster| { &m.ip_allocation_policy },
                |m: &mut Cluster| { &mut m.ip_allocation_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MasterAuthorizedNetworksConfig>>(
                "master_authorized_networks_config",
                |m: &Cluster| { &m.master_authorized_networks_config },
                |m: &mut Cluster| { &mut m.master_authorized_networks_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MaintenancePolicy>>(
                "maintenance_policy",
                |m: &Cluster| { &m.maintenance_policy },
                |m: &mut Cluster| { &mut m.maintenance_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BinaryAuthorization>>(
                "binary_authorization",
                |m: &Cluster| { &m.binary_authorization },
                |m: &mut Cluster| { &mut m.binary_authorization },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClusterAutoscaling>>(
                "autoscaling",
                |m: &Cluster| { &m.autoscaling },
                |m: &mut Cluster| { &mut m.autoscaling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkConfig>>(
                "network_config",
                |m: &Cluster| { &m.network_config },
                |m: &mut Cluster| { &mut m.network_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MaxPodsConstraint>>(
                "default_max_pods_constraint",
                |m: &Cluster| { &m.default_max_pods_constraint },
                |m: &mut Cluster| { &mut m.default_max_pods_constraint },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceUsageExportConfig>>(
                "resource_usage_export_config",
                |m: &Cluster| { &m.resource_usage_export_config },
                |m: &mut Cluster| { &mut m.resource_usage_export_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthenticatorGroupsConfig>>(
                "authenticator_groups_config",
                |m: &Cluster| { &m.authenticator_groups_config },
                |m: &mut Cluster| { &mut m.authenticator_groups_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PrivateClusterConfig>>(
                "private_cluster_config",
                |m: &Cluster| { &m.private_cluster_config },
                |m: &mut Cluster| { &mut m.private_cluster_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseEncryption>>(
                "database_encryption",
                |m: &Cluster| { &m.database_encryption },
                |m: &mut Cluster| { &mut m.database_encryption },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VerticalPodAutoscaling>>(
                "vertical_pod_autoscaling",
                |m: &Cluster| { &m.vertical_pod_autoscaling },
                |m: &mut Cluster| { &mut m.vertical_pod_autoscaling },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "self_link",
                |m: &Cluster| { &m.self_link },
                |m: &mut Cluster| { &mut m.self_link },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &Cluster| { &m.zone },
                |m: &mut Cluster| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoint",
                |m: &Cluster| { &m.endpoint },
                |m: &mut Cluster| { &mut m.endpoint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "initial_cluster_version",
                |m: &Cluster| { &m.initial_cluster_version },
                |m: &mut Cluster| { &mut m.initial_cluster_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "current_master_version",
                |m: &Cluster| { &m.current_master_version },
                |m: &mut Cluster| { &mut m.current_master_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "current_node_version",
                |m: &Cluster| { &m.current_node_version },
                |m: &mut Cluster| { &mut m.current_node_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "create_time",
                |m: &Cluster| { &m.create_time },
                |m: &mut Cluster| { &mut m.create_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Cluster_Status>>(
                "status",
                |m: &Cluster| { &m.status },
                |m: &mut Cluster| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status_message",
                |m: &Cluster| { &m.status_message },
                |m: &mut Cluster| { &mut m.status_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "node_ipv4_cidr_size",
                |m: &Cluster| { &m.node_ipv4_cidr_size },
                |m: &mut Cluster| { &mut m.node_ipv4_cidr_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "services_ipv4_cidr",
                |m: &Cluster| { &m.services_ipv4_cidr },
                |m: &mut Cluster| { &mut m.services_ipv4_cidr },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instance_group_urls",
                |m: &Cluster| { &m.instance_group_urls },
                |m: &mut Cluster| { &mut m.instance_group_urls },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "current_node_count",
                |m: &Cluster| { &m.current_node_count },
                |m: &mut Cluster| { &mut m.current_node_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "expire_time",
                |m: &Cluster| { &m.expire_time },
                |m: &mut Cluster| { &mut m.expire_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &Cluster| { &m.location },
                |m: &mut Cluster| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_tpu",
                |m: &Cluster| { &m.enable_tpu },
                |m: &mut Cluster| { &mut m.enable_tpu },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tpu_ipv4_cidr_block",
                |m: &Cluster| { &m.tpu_ipv4_cidr_block },
                |m: &mut Cluster| { &mut m.tpu_ipv4_cidr_block },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusCondition>>(
                "conditions",
                |m: &Cluster| { &m.conditions },
                |m: &mut Cluster| { &mut m.conditions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cluster>(
                "Cluster",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cluster {
        static instance: ::protobuf::rt::LazyV2<Cluster> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cluster::new)
    }
}

impl ::protobuf::Clear for Cluster {
    fn clear(&mut self) {
        self.name.clear();
        self.description.clear();
        self.initial_node_count = 0;
        self.node_config.clear();
        self.master_auth.clear();
        self.logging_service.clear();
        self.monitoring_service.clear();
        self.network.clear();
        self.cluster_ipv4_cidr.clear();
        self.addons_config.clear();
        self.subnetwork.clear();
        self.node_pools.clear();
        self.locations.clear();
        self.enable_kubernetes_alpha = false;
        self.resource_labels.clear();
        self.label_fingerprint.clear();
        self.legacy_abac.clear();
        self.network_policy.clear();
        self.ip_allocation_policy.clear();
        self.master_authorized_networks_config.clear();
        self.maintenance_policy.clear();
        self.binary_authorization.clear();
        self.autoscaling.clear();
        self.network_config.clear();
        self.default_max_pods_constraint.clear();
        self.resource_usage_export_config.clear();
        self.authenticator_groups_config.clear();
        self.private_cluster_config.clear();
        self.database_encryption.clear();
        self.vertical_pod_autoscaling.clear();
        self.self_link.clear();
        self.zone.clear();
        self.endpoint.clear();
        self.initial_cluster_version.clear();
        self.current_master_version.clear();
        self.current_node_version.clear();
        self.create_time.clear();
        self.status = Cluster_Status::STATUS_UNSPECIFIED;
        self.status_message.clear();
        self.node_ipv4_cidr_size = 0;
        self.services_ipv4_cidr.clear();
        self.instance_group_urls.clear();
        self.current_node_count = 0;
        self.expire_time.clear();
        self.location.clear();
        self.enable_tpu = false;
        self.tpu_ipv4_cidr_block.clear();
        self.conditions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cluster {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Cluster_Status {
    STATUS_UNSPECIFIED = 0,
    PROVISIONING = 1,
    RUNNING = 2,
    RECONCILING = 3,
    STOPPING = 4,
    ERROR = 5,
    DEGRADED = 6,
}

impl ::protobuf::ProtobufEnum for Cluster_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Cluster_Status> {
        match value {
            0 => ::std::option::Option::Some(Cluster_Status::STATUS_UNSPECIFIED),
            1 => ::std::option::Option::Some(Cluster_Status::PROVISIONING),
            2 => ::std::option::Option::Some(Cluster_Status::RUNNING),
            3 => ::std::option::Option::Some(Cluster_Status::RECONCILING),
            4 => ::std::option::Option::Some(Cluster_Status::STOPPING),
            5 => ::std::option::Option::Some(Cluster_Status::ERROR),
            6 => ::std::option::Option::Some(Cluster_Status::DEGRADED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Cluster_Status] = &[
            Cluster_Status::STATUS_UNSPECIFIED,
            Cluster_Status::PROVISIONING,
            Cluster_Status::RUNNING,
            Cluster_Status::RECONCILING,
            Cluster_Status::STOPPING,
            Cluster_Status::ERROR,
            Cluster_Status::DEGRADED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Cluster_Status>("Cluster.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Cluster_Status {
}

impl ::std::default::Default for Cluster_Status {
    fn default() -> Self {
        Cluster_Status::STATUS_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Cluster_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClusterUpdate {
    // message fields
    pub desired_node_version: ::std::string::String,
    pub desired_monitoring_service: ::std::string::String,
    pub desired_addons_config: ::protobuf::SingularPtrField<AddonsConfig>,
    pub desired_node_pool_id: ::std::string::String,
    pub desired_image_type: ::std::string::String,
    pub desired_database_encryption: ::protobuf::SingularPtrField<DatabaseEncryption>,
    pub desired_node_pool_autoscaling: ::protobuf::SingularPtrField<NodePoolAutoscaling>,
    pub desired_locations: ::protobuf::RepeatedField<::std::string::String>,
    pub desired_master_authorized_networks_config: ::protobuf::SingularPtrField<MasterAuthorizedNetworksConfig>,
    pub desired_cluster_autoscaling: ::protobuf::SingularPtrField<ClusterAutoscaling>,
    pub desired_binary_authorization: ::protobuf::SingularPtrField<BinaryAuthorization>,
    pub desired_logging_service: ::std::string::String,
    pub desired_resource_usage_export_config: ::protobuf::SingularPtrField<ResourceUsageExportConfig>,
    pub desired_vertical_pod_autoscaling: ::protobuf::SingularPtrField<VerticalPodAutoscaling>,
    pub desired_intra_node_visibility_config: ::protobuf::SingularPtrField<IntraNodeVisibilityConfig>,
    pub desired_master_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClusterUpdate {
    fn default() -> &'a ClusterUpdate {
        <ClusterUpdate as ::protobuf::Message>::default_instance()
    }
}

impl ClusterUpdate {
    pub fn new() -> ClusterUpdate {
        ::std::default::Default::default()
    }

    // string desired_node_version = 4;


    pub fn get_desired_node_version(&self) -> &str {
        &self.desired_node_version
    }
    pub fn clear_desired_node_version(&mut self) {
        self.desired_node_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_desired_node_version(&mut self, v: ::std::string::String) {
        self.desired_node_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_node_version(&mut self) -> &mut ::std::string::String {
        &mut self.desired_node_version
    }

    // Take field
    pub fn take_desired_node_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desired_node_version, ::std::string::String::new())
    }

    // string desired_monitoring_service = 5;


    pub fn get_desired_monitoring_service(&self) -> &str {
        &self.desired_monitoring_service
    }
    pub fn clear_desired_monitoring_service(&mut self) {
        self.desired_monitoring_service.clear();
    }

    // Param is passed by value, moved
    pub fn set_desired_monitoring_service(&mut self, v: ::std::string::String) {
        self.desired_monitoring_service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_monitoring_service(&mut self) -> &mut ::std::string::String {
        &mut self.desired_monitoring_service
    }

    // Take field
    pub fn take_desired_monitoring_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desired_monitoring_service, ::std::string::String::new())
    }

    // .google.container.v1.AddonsConfig desired_addons_config = 6;


    pub fn get_desired_addons_config(&self) -> &AddonsConfig {
        self.desired_addons_config.as_ref().unwrap_or_else(|| <AddonsConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desired_addons_config(&mut self) {
        self.desired_addons_config.clear();
    }

    pub fn has_desired_addons_config(&self) -> bool {
        self.desired_addons_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_addons_config(&mut self, v: AddonsConfig) {
        self.desired_addons_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_addons_config(&mut self) -> &mut AddonsConfig {
        if self.desired_addons_config.is_none() {
            self.desired_addons_config.set_default();
        }
        self.desired_addons_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_desired_addons_config(&mut self) -> AddonsConfig {
        self.desired_addons_config.take().unwrap_or_else(|| AddonsConfig::new())
    }

    // string desired_node_pool_id = 7;


    pub fn get_desired_node_pool_id(&self) -> &str {
        &self.desired_node_pool_id
    }
    pub fn clear_desired_node_pool_id(&mut self) {
        self.desired_node_pool_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_desired_node_pool_id(&mut self, v: ::std::string::String) {
        self.desired_node_pool_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_node_pool_id(&mut self) -> &mut ::std::string::String {
        &mut self.desired_node_pool_id
    }

    // Take field
    pub fn take_desired_node_pool_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desired_node_pool_id, ::std::string::String::new())
    }

    // string desired_image_type = 8;


    pub fn get_desired_image_type(&self) -> &str {
        &self.desired_image_type
    }
    pub fn clear_desired_image_type(&mut self) {
        self.desired_image_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_desired_image_type(&mut self, v: ::std::string::String) {
        self.desired_image_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_image_type(&mut self) -> &mut ::std::string::String {
        &mut self.desired_image_type
    }

    // Take field
    pub fn take_desired_image_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desired_image_type, ::std::string::String::new())
    }

    // .google.container.v1.DatabaseEncryption desired_database_encryption = 46;


    pub fn get_desired_database_encryption(&self) -> &DatabaseEncryption {
        self.desired_database_encryption.as_ref().unwrap_or_else(|| <DatabaseEncryption as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desired_database_encryption(&mut self) {
        self.desired_database_encryption.clear();
    }

    pub fn has_desired_database_encryption(&self) -> bool {
        self.desired_database_encryption.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_database_encryption(&mut self, v: DatabaseEncryption) {
        self.desired_database_encryption = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_database_encryption(&mut self) -> &mut DatabaseEncryption {
        if self.desired_database_encryption.is_none() {
            self.desired_database_encryption.set_default();
        }
        self.desired_database_encryption.as_mut().unwrap()
    }

    // Take field
    pub fn take_desired_database_encryption(&mut self) -> DatabaseEncryption {
        self.desired_database_encryption.take().unwrap_or_else(|| DatabaseEncryption::new())
    }

    // .google.container.v1.NodePoolAutoscaling desired_node_pool_autoscaling = 9;


    pub fn get_desired_node_pool_autoscaling(&self) -> &NodePoolAutoscaling {
        self.desired_node_pool_autoscaling.as_ref().unwrap_or_else(|| <NodePoolAutoscaling as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desired_node_pool_autoscaling(&mut self) {
        self.desired_node_pool_autoscaling.clear();
    }

    pub fn has_desired_node_pool_autoscaling(&self) -> bool {
        self.desired_node_pool_autoscaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_node_pool_autoscaling(&mut self, v: NodePoolAutoscaling) {
        self.desired_node_pool_autoscaling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_node_pool_autoscaling(&mut self) -> &mut NodePoolAutoscaling {
        if self.desired_node_pool_autoscaling.is_none() {
            self.desired_node_pool_autoscaling.set_default();
        }
        self.desired_node_pool_autoscaling.as_mut().unwrap()
    }

    // Take field
    pub fn take_desired_node_pool_autoscaling(&mut self) -> NodePoolAutoscaling {
        self.desired_node_pool_autoscaling.take().unwrap_or_else(|| NodePoolAutoscaling::new())
    }

    // repeated string desired_locations = 10;


    pub fn get_desired_locations(&self) -> &[::std::string::String] {
        &self.desired_locations
    }
    pub fn clear_desired_locations(&mut self) {
        self.desired_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_desired_locations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.desired_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_desired_locations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.desired_locations
    }

    // Take field
    pub fn take_desired_locations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.desired_locations, ::protobuf::RepeatedField::new())
    }

    // .google.container.v1.MasterAuthorizedNetworksConfig desired_master_authorized_networks_config = 12;


    pub fn get_desired_master_authorized_networks_config(&self) -> &MasterAuthorizedNetworksConfig {
        self.desired_master_authorized_networks_config.as_ref().unwrap_or_else(|| <MasterAuthorizedNetworksConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desired_master_authorized_networks_config(&mut self) {
        self.desired_master_authorized_networks_config.clear();
    }

    pub fn has_desired_master_authorized_networks_config(&self) -> bool {
        self.desired_master_authorized_networks_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_master_authorized_networks_config(&mut self, v: MasterAuthorizedNetworksConfig) {
        self.desired_master_authorized_networks_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_master_authorized_networks_config(&mut self) -> &mut MasterAuthorizedNetworksConfig {
        if self.desired_master_authorized_networks_config.is_none() {
            self.desired_master_authorized_networks_config.set_default();
        }
        self.desired_master_authorized_networks_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_desired_master_authorized_networks_config(&mut self) -> MasterAuthorizedNetworksConfig {
        self.desired_master_authorized_networks_config.take().unwrap_or_else(|| MasterAuthorizedNetworksConfig::new())
    }

    // .google.container.v1.ClusterAutoscaling desired_cluster_autoscaling = 15;


    pub fn get_desired_cluster_autoscaling(&self) -> &ClusterAutoscaling {
        self.desired_cluster_autoscaling.as_ref().unwrap_or_else(|| <ClusterAutoscaling as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desired_cluster_autoscaling(&mut self) {
        self.desired_cluster_autoscaling.clear();
    }

    pub fn has_desired_cluster_autoscaling(&self) -> bool {
        self.desired_cluster_autoscaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_cluster_autoscaling(&mut self, v: ClusterAutoscaling) {
        self.desired_cluster_autoscaling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_cluster_autoscaling(&mut self) -> &mut ClusterAutoscaling {
        if self.desired_cluster_autoscaling.is_none() {
            self.desired_cluster_autoscaling.set_default();
        }
        self.desired_cluster_autoscaling.as_mut().unwrap()
    }

    // Take field
    pub fn take_desired_cluster_autoscaling(&mut self) -> ClusterAutoscaling {
        self.desired_cluster_autoscaling.take().unwrap_or_else(|| ClusterAutoscaling::new())
    }

    // .google.container.v1.BinaryAuthorization desired_binary_authorization = 16;


    pub fn get_desired_binary_authorization(&self) -> &BinaryAuthorization {
        self.desired_binary_authorization.as_ref().unwrap_or_else(|| <BinaryAuthorization as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desired_binary_authorization(&mut self) {
        self.desired_binary_authorization.clear();
    }

    pub fn has_desired_binary_authorization(&self) -> bool {
        self.desired_binary_authorization.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_binary_authorization(&mut self, v: BinaryAuthorization) {
        self.desired_binary_authorization = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_binary_authorization(&mut self) -> &mut BinaryAuthorization {
        if self.desired_binary_authorization.is_none() {
            self.desired_binary_authorization.set_default();
        }
        self.desired_binary_authorization.as_mut().unwrap()
    }

    // Take field
    pub fn take_desired_binary_authorization(&mut self) -> BinaryAuthorization {
        self.desired_binary_authorization.take().unwrap_or_else(|| BinaryAuthorization::new())
    }

    // string desired_logging_service = 19;


    pub fn get_desired_logging_service(&self) -> &str {
        &self.desired_logging_service
    }
    pub fn clear_desired_logging_service(&mut self) {
        self.desired_logging_service.clear();
    }

    // Param is passed by value, moved
    pub fn set_desired_logging_service(&mut self, v: ::std::string::String) {
        self.desired_logging_service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_logging_service(&mut self) -> &mut ::std::string::String {
        &mut self.desired_logging_service
    }

    // Take field
    pub fn take_desired_logging_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desired_logging_service, ::std::string::String::new())
    }

    // .google.container.v1.ResourceUsageExportConfig desired_resource_usage_export_config = 21;


    pub fn get_desired_resource_usage_export_config(&self) -> &ResourceUsageExportConfig {
        self.desired_resource_usage_export_config.as_ref().unwrap_or_else(|| <ResourceUsageExportConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desired_resource_usage_export_config(&mut self) {
        self.desired_resource_usage_export_config.clear();
    }

    pub fn has_desired_resource_usage_export_config(&self) -> bool {
        self.desired_resource_usage_export_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_resource_usage_export_config(&mut self, v: ResourceUsageExportConfig) {
        self.desired_resource_usage_export_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_resource_usage_export_config(&mut self) -> &mut ResourceUsageExportConfig {
        if self.desired_resource_usage_export_config.is_none() {
            self.desired_resource_usage_export_config.set_default();
        }
        self.desired_resource_usage_export_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_desired_resource_usage_export_config(&mut self) -> ResourceUsageExportConfig {
        self.desired_resource_usage_export_config.take().unwrap_or_else(|| ResourceUsageExportConfig::new())
    }

    // .google.container.v1.VerticalPodAutoscaling desired_vertical_pod_autoscaling = 22;


    pub fn get_desired_vertical_pod_autoscaling(&self) -> &VerticalPodAutoscaling {
        self.desired_vertical_pod_autoscaling.as_ref().unwrap_or_else(|| <VerticalPodAutoscaling as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desired_vertical_pod_autoscaling(&mut self) {
        self.desired_vertical_pod_autoscaling.clear();
    }

    pub fn has_desired_vertical_pod_autoscaling(&self) -> bool {
        self.desired_vertical_pod_autoscaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_vertical_pod_autoscaling(&mut self, v: VerticalPodAutoscaling) {
        self.desired_vertical_pod_autoscaling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_vertical_pod_autoscaling(&mut self) -> &mut VerticalPodAutoscaling {
        if self.desired_vertical_pod_autoscaling.is_none() {
            self.desired_vertical_pod_autoscaling.set_default();
        }
        self.desired_vertical_pod_autoscaling.as_mut().unwrap()
    }

    // Take field
    pub fn take_desired_vertical_pod_autoscaling(&mut self) -> VerticalPodAutoscaling {
        self.desired_vertical_pod_autoscaling.take().unwrap_or_else(|| VerticalPodAutoscaling::new())
    }

    // .google.container.v1.IntraNodeVisibilityConfig desired_intra_node_visibility_config = 26;


    pub fn get_desired_intra_node_visibility_config(&self) -> &IntraNodeVisibilityConfig {
        self.desired_intra_node_visibility_config.as_ref().unwrap_or_else(|| <IntraNodeVisibilityConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_desired_intra_node_visibility_config(&mut self) {
        self.desired_intra_node_visibility_config.clear();
    }

    pub fn has_desired_intra_node_visibility_config(&self) -> bool {
        self.desired_intra_node_visibility_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desired_intra_node_visibility_config(&mut self, v: IntraNodeVisibilityConfig) {
        self.desired_intra_node_visibility_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_intra_node_visibility_config(&mut self) -> &mut IntraNodeVisibilityConfig {
        if self.desired_intra_node_visibility_config.is_none() {
            self.desired_intra_node_visibility_config.set_default();
        }
        self.desired_intra_node_visibility_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_desired_intra_node_visibility_config(&mut self) -> IntraNodeVisibilityConfig {
        self.desired_intra_node_visibility_config.take().unwrap_or_else(|| IntraNodeVisibilityConfig::new())
    }

    // string desired_master_version = 100;


    pub fn get_desired_master_version(&self) -> &str {
        &self.desired_master_version
    }
    pub fn clear_desired_master_version(&mut self) {
        self.desired_master_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_desired_master_version(&mut self, v: ::std::string::String) {
        self.desired_master_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desired_master_version(&mut self) -> &mut ::std::string::String {
        &mut self.desired_master_version
    }

    // Take field
    pub fn take_desired_master_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desired_master_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ClusterUpdate {
    fn is_initialized(&self) -> bool {
        for v in &self.desired_addons_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desired_database_encryption {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desired_node_pool_autoscaling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desired_master_authorized_networks_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desired_cluster_autoscaling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desired_binary_authorization {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desired_resource_usage_export_config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desired_vertical_pod_autoscaling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desired_intra_node_visibility_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.desired_node_version)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.desired_monitoring_service)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desired_addons_config)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.desired_node_pool_id)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.desired_image_type)?;
                },
                46 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desired_database_encryption)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desired_node_pool_autoscaling)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.desired_locations)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desired_master_authorized_networks_config)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desired_cluster_autoscaling)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desired_binary_authorization)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.desired_logging_service)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desired_resource_usage_export_config)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desired_vertical_pod_autoscaling)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desired_intra_node_visibility_config)?;
                },
                100 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.desired_master_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.desired_node_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.desired_node_version);
        }
        if !self.desired_monitoring_service.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.desired_monitoring_service);
        }
        if let Some(ref v) = self.desired_addons_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.desired_node_pool_id.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.desired_node_pool_id);
        }
        if !self.desired_image_type.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.desired_image_type);
        }
        if let Some(ref v) = self.desired_database_encryption.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.desired_node_pool_autoscaling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.desired_locations {
            my_size += ::protobuf::rt::string_size(10, &value);
        };
        if let Some(ref v) = self.desired_master_authorized_networks_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.desired_cluster_autoscaling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.desired_binary_authorization.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.desired_logging_service.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.desired_logging_service);
        }
        if let Some(ref v) = self.desired_resource_usage_export_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.desired_vertical_pod_autoscaling.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.desired_intra_node_visibility_config.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.desired_master_version.is_empty() {
            my_size += ::protobuf::rt::string_size(100, &self.desired_master_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.desired_node_version.is_empty() {
            os.write_string(4, &self.desired_node_version)?;
        }
        if !self.desired_monitoring_service.is_empty() {
            os.write_string(5, &self.desired_monitoring_service)?;
        }
        if let Some(ref v) = self.desired_addons_config.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.desired_node_pool_id.is_empty() {
            os.write_string(7, &self.desired_node_pool_id)?;
        }
        if !self.desired_image_type.is_empty() {
            os.write_string(8, &self.desired_image_type)?;
        }
        if let Some(ref v) = self.desired_database_encryption.as_ref() {
            os.write_tag(46, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.desired_node_pool_autoscaling.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.desired_locations {
            os.write_string(10, &v)?;
        };
        if let Some(ref v) = self.desired_master_authorized_networks_config.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.desired_cluster_autoscaling.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.desired_binary_authorization.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.desired_logging_service.is_empty() {
            os.write_string(19, &self.desired_logging_service)?;
        }
        if let Some(ref v) = self.desired_resource_usage_export_config.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.desired_vertical_pod_autoscaling.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.desired_intra_node_visibility_config.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.desired_master_version.is_empty() {
            os.write_string(100, &self.desired_master_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClusterUpdate {
        ClusterUpdate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desired_node_version",
                |m: &ClusterUpdate| { &m.desired_node_version },
                |m: &mut ClusterUpdate| { &mut m.desired_node_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desired_monitoring_service",
                |m: &ClusterUpdate| { &m.desired_monitoring_service },
                |m: &mut ClusterUpdate| { &mut m.desired_monitoring_service },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddonsConfig>>(
                "desired_addons_config",
                |m: &ClusterUpdate| { &m.desired_addons_config },
                |m: &mut ClusterUpdate| { &mut m.desired_addons_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desired_node_pool_id",
                |m: &ClusterUpdate| { &m.desired_node_pool_id },
                |m: &mut ClusterUpdate| { &mut m.desired_node_pool_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desired_image_type",
                |m: &ClusterUpdate| { &m.desired_image_type },
                |m: &mut ClusterUpdate| { &mut m.desired_image_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DatabaseEncryption>>(
                "desired_database_encryption",
                |m: &ClusterUpdate| { &m.desired_database_encryption },
                |m: &mut ClusterUpdate| { &mut m.desired_database_encryption },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePoolAutoscaling>>(
                "desired_node_pool_autoscaling",
                |m: &ClusterUpdate| { &m.desired_node_pool_autoscaling },
                |m: &mut ClusterUpdate| { &mut m.desired_node_pool_autoscaling },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desired_locations",
                |m: &ClusterUpdate| { &m.desired_locations },
                |m: &mut ClusterUpdate| { &mut m.desired_locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MasterAuthorizedNetworksConfig>>(
                "desired_master_authorized_networks_config",
                |m: &ClusterUpdate| { &m.desired_master_authorized_networks_config },
                |m: &mut ClusterUpdate| { &mut m.desired_master_authorized_networks_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClusterAutoscaling>>(
                "desired_cluster_autoscaling",
                |m: &ClusterUpdate| { &m.desired_cluster_autoscaling },
                |m: &mut ClusterUpdate| { &mut m.desired_cluster_autoscaling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BinaryAuthorization>>(
                "desired_binary_authorization",
                |m: &ClusterUpdate| { &m.desired_binary_authorization },
                |m: &mut ClusterUpdate| { &mut m.desired_binary_authorization },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desired_logging_service",
                |m: &ClusterUpdate| { &m.desired_logging_service },
                |m: &mut ClusterUpdate| { &mut m.desired_logging_service },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceUsageExportConfig>>(
                "desired_resource_usage_export_config",
                |m: &ClusterUpdate| { &m.desired_resource_usage_export_config },
                |m: &mut ClusterUpdate| { &mut m.desired_resource_usage_export_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VerticalPodAutoscaling>>(
                "desired_vertical_pod_autoscaling",
                |m: &ClusterUpdate| { &m.desired_vertical_pod_autoscaling },
                |m: &mut ClusterUpdate| { &mut m.desired_vertical_pod_autoscaling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IntraNodeVisibilityConfig>>(
                "desired_intra_node_visibility_config",
                |m: &ClusterUpdate| { &m.desired_intra_node_visibility_config },
                |m: &mut ClusterUpdate| { &mut m.desired_intra_node_visibility_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "desired_master_version",
                |m: &ClusterUpdate| { &m.desired_master_version },
                |m: &mut ClusterUpdate| { &mut m.desired_master_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClusterUpdate>(
                "ClusterUpdate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClusterUpdate {
        static instance: ::protobuf::rt::LazyV2<ClusterUpdate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClusterUpdate::new)
    }
}

impl ::protobuf::Clear for ClusterUpdate {
    fn clear(&mut self) {
        self.desired_node_version.clear();
        self.desired_monitoring_service.clear();
        self.desired_addons_config.clear();
        self.desired_node_pool_id.clear();
        self.desired_image_type.clear();
        self.desired_database_encryption.clear();
        self.desired_node_pool_autoscaling.clear();
        self.desired_locations.clear();
        self.desired_master_authorized_networks_config.clear();
        self.desired_cluster_autoscaling.clear();
        self.desired_binary_authorization.clear();
        self.desired_logging_service.clear();
        self.desired_resource_usage_export_config.clear();
        self.desired_vertical_pod_autoscaling.clear();
        self.desired_intra_node_visibility_config.clear();
        self.desired_master_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClusterUpdate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterUpdate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Operation {
    // message fields
    pub name: ::std::string::String,
    pub zone: ::std::string::String,
    pub operation_type: Operation_Type,
    pub status: Operation_Status,
    pub detail: ::std::string::String,
    pub status_message: ::std::string::String,
    pub self_link: ::std::string::String,
    pub target_link: ::std::string::String,
    pub location: ::std::string::String,
    pub start_time: ::std::string::String,
    pub end_time: ::std::string::String,
    pub cluster_conditions: ::protobuf::RepeatedField<StatusCondition>,
    pub nodepool_conditions: ::protobuf::RepeatedField<StatusCondition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Operation {
    fn default() -> &'a Operation {
        <Operation as ::protobuf::Message>::default_instance()
    }
}

impl Operation {
    pub fn new() -> Operation {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // .google.container.v1.Operation.Type operation_type = 3;


    pub fn get_operation_type(&self) -> Operation_Type {
        self.operation_type
    }
    pub fn clear_operation_type(&mut self) {
        self.operation_type = Operation_Type::TYPE_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_operation_type(&mut self, v: Operation_Type) {
        self.operation_type = v;
    }

    // .google.container.v1.Operation.Status status = 4;


    pub fn get_status(&self) -> Operation_Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Operation_Status::STATUS_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Operation_Status) {
        self.status = v;
    }

    // string detail = 8;


    pub fn get_detail(&self) -> &str {
        &self.detail
    }
    pub fn clear_detail(&mut self) {
        self.detail.clear();
    }

    // Param is passed by value, moved
    pub fn set_detail(&mut self, v: ::std::string::String) {
        self.detail = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_detail(&mut self) -> &mut ::std::string::String {
        &mut self.detail
    }

    // Take field
    pub fn take_detail(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.detail, ::std::string::String::new())
    }

    // string status_message = 5;


    pub fn get_status_message(&self) -> &str {
        &self.status_message
    }
    pub fn clear_status_message(&mut self) {
        self.status_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_status_message(&mut self, v: ::std::string::String) {
        self.status_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_message(&mut self) -> &mut ::std::string::String {
        &mut self.status_message
    }

    // Take field
    pub fn take_status_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status_message, ::std::string::String::new())
    }

    // string self_link = 6;


    pub fn get_self_link(&self) -> &str {
        &self.self_link
    }
    pub fn clear_self_link(&mut self) {
        self.self_link.clear();
    }

    // Param is passed by value, moved
    pub fn set_self_link(&mut self, v: ::std::string::String) {
        self.self_link = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_self_link(&mut self) -> &mut ::std::string::String {
        &mut self.self_link
    }

    // Take field
    pub fn take_self_link(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.self_link, ::std::string::String::new())
    }

    // string target_link = 7;


    pub fn get_target_link(&self) -> &str {
        &self.target_link
    }
    pub fn clear_target_link(&mut self) {
        self.target_link.clear();
    }

    // Param is passed by value, moved
    pub fn set_target_link(&mut self, v: ::std::string::String) {
        self.target_link = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_link(&mut self) -> &mut ::std::string::String {
        &mut self.target_link
    }

    // Take field
    pub fn take_target_link(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.target_link, ::std::string::String::new())
    }

    // string location = 9;


    pub fn get_location(&self) -> &str {
        &self.location
    }
    pub fn clear_location(&mut self) {
        self.location.clear();
    }

    // Param is passed by value, moved
    pub fn set_location(&mut self, v: ::std::string::String) {
        self.location = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_location(&mut self) -> &mut ::std::string::String {
        &mut self.location
    }

    // Take field
    pub fn take_location(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.location, ::std::string::String::new())
    }

    // string start_time = 10;


    pub fn get_start_time(&self) -> &str {
        &self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::std::string::String) {
        self.start_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::std::string::String {
        &mut self.start_time
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.start_time, ::std::string::String::new())
    }

    // string end_time = 11;


    pub fn get_end_time(&self) -> &str {
        &self.end_time
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::std::string::String) {
        self.end_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::std::string::String {
        &mut self.end_time
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.end_time, ::std::string::String::new())
    }

    // repeated .google.container.v1.StatusCondition cluster_conditions = 13;


    pub fn get_cluster_conditions(&self) -> &[StatusCondition] {
        &self.cluster_conditions
    }
    pub fn clear_cluster_conditions(&mut self) {
        self.cluster_conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_conditions(&mut self, v: ::protobuf::RepeatedField<StatusCondition>) {
        self.cluster_conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cluster_conditions(&mut self) -> &mut ::protobuf::RepeatedField<StatusCondition> {
        &mut self.cluster_conditions
    }

    // Take field
    pub fn take_cluster_conditions(&mut self) -> ::protobuf::RepeatedField<StatusCondition> {
        ::std::mem::replace(&mut self.cluster_conditions, ::protobuf::RepeatedField::new())
    }

    // repeated .google.container.v1.StatusCondition nodepool_conditions = 14;


    pub fn get_nodepool_conditions(&self) -> &[StatusCondition] {
        &self.nodepool_conditions
    }
    pub fn clear_nodepool_conditions(&mut self) {
        self.nodepool_conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodepool_conditions(&mut self, v: ::protobuf::RepeatedField<StatusCondition>) {
        self.nodepool_conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodepool_conditions(&mut self) -> &mut ::protobuf::RepeatedField<StatusCondition> {
        &mut self.nodepool_conditions
    }

    // Take field
    pub fn take_nodepool_conditions(&mut self) -> ::protobuf::RepeatedField<StatusCondition> {
        ::std::mem::replace(&mut self.nodepool_conditions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Operation {
    fn is_initialized(&self) -> bool {
        for v in &self.cluster_conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nodepool_conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.operation_type, 3, &mut self.unknown_fields)?
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.detail)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status_message)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.self_link)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.target_link)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.location)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.start_time)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.end_time)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cluster_conditions)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodepool_conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if self.operation_type != Operation_Type::TYPE_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(3, self.operation_type);
        }
        if self.status != Operation_Status::STATUS_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(4, self.status);
        }
        if !self.detail.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.detail);
        }
        if !self.status_message.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.status_message);
        }
        if !self.self_link.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.self_link);
        }
        if !self.target_link.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.target_link);
        }
        if !self.location.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.location);
        }
        if !self.start_time.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.start_time);
        }
        if !self.end_time.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.end_time);
        }
        for value in &self.cluster_conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.nodepool_conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if self.operation_type != Operation_Type::TYPE_UNSPECIFIED {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.operation_type))?;
        }
        if self.status != Operation_Status::STATUS_UNSPECIFIED {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.detail.is_empty() {
            os.write_string(8, &self.detail)?;
        }
        if !self.status_message.is_empty() {
            os.write_string(5, &self.status_message)?;
        }
        if !self.self_link.is_empty() {
            os.write_string(6, &self.self_link)?;
        }
        if !self.target_link.is_empty() {
            os.write_string(7, &self.target_link)?;
        }
        if !self.location.is_empty() {
            os.write_string(9, &self.location)?;
        }
        if !self.start_time.is_empty() {
            os.write_string(10, &self.start_time)?;
        }
        if !self.end_time.is_empty() {
            os.write_string(11, &self.end_time)?;
        }
        for v in &self.cluster_conditions {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.nodepool_conditions {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Operation {
        Operation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Operation| { &m.name },
                |m: &mut Operation| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &Operation| { &m.zone },
                |m: &mut Operation| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Operation_Type>>(
                "operation_type",
                |m: &Operation| { &m.operation_type },
                |m: &mut Operation| { &mut m.operation_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Operation_Status>>(
                "status",
                |m: &Operation| { &m.status },
                |m: &mut Operation| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "detail",
                |m: &Operation| { &m.detail },
                |m: &mut Operation| { &mut m.detail },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status_message",
                |m: &Operation| { &m.status_message },
                |m: &mut Operation| { &mut m.status_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "self_link",
                |m: &Operation| { &m.self_link },
                |m: &mut Operation| { &mut m.self_link },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "target_link",
                |m: &Operation| { &m.target_link },
                |m: &mut Operation| { &mut m.target_link },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "location",
                |m: &Operation| { &m.location },
                |m: &mut Operation| { &mut m.location },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "start_time",
                |m: &Operation| { &m.start_time },
                |m: &mut Operation| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "end_time",
                |m: &Operation| { &m.end_time },
                |m: &mut Operation| { &mut m.end_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusCondition>>(
                "cluster_conditions",
                |m: &Operation| { &m.cluster_conditions },
                |m: &mut Operation| { &mut m.cluster_conditions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusCondition>>(
                "nodepool_conditions",
                |m: &Operation| { &m.nodepool_conditions },
                |m: &mut Operation| { &mut m.nodepool_conditions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Operation>(
                "Operation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Operation {
        static instance: ::protobuf::rt::LazyV2<Operation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Operation::new)
    }
}

impl ::protobuf::Clear for Operation {
    fn clear(&mut self) {
        self.name.clear();
        self.zone.clear();
        self.operation_type = Operation_Type::TYPE_UNSPECIFIED;
        self.status = Operation_Status::STATUS_UNSPECIFIED;
        self.detail.clear();
        self.status_message.clear();
        self.self_link.clear();
        self.target_link.clear();
        self.location.clear();
        self.start_time.clear();
        self.end_time.clear();
        self.cluster_conditions.clear();
        self.nodepool_conditions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Operation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Operation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Operation_Status {
    STATUS_UNSPECIFIED = 0,
    PENDING = 1,
    RUNNING = 2,
    DONE = 3,
    ABORTING = 4,
}

impl ::protobuf::ProtobufEnum for Operation_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Operation_Status> {
        match value {
            0 => ::std::option::Option::Some(Operation_Status::STATUS_UNSPECIFIED),
            1 => ::std::option::Option::Some(Operation_Status::PENDING),
            2 => ::std::option::Option::Some(Operation_Status::RUNNING),
            3 => ::std::option::Option::Some(Operation_Status::DONE),
            4 => ::std::option::Option::Some(Operation_Status::ABORTING),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Operation_Status] = &[
            Operation_Status::STATUS_UNSPECIFIED,
            Operation_Status::PENDING,
            Operation_Status::RUNNING,
            Operation_Status::DONE,
            Operation_Status::ABORTING,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Operation_Status>("Operation.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Operation_Status {
}

impl ::std::default::Default for Operation_Status {
    fn default() -> Self {
        Operation_Status::STATUS_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Operation_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum Operation_Type {
    TYPE_UNSPECIFIED = 0,
    CREATE_CLUSTER = 1,
    DELETE_CLUSTER = 2,
    UPGRADE_MASTER = 3,
    UPGRADE_NODES = 4,
    REPAIR_CLUSTER = 5,
    UPDATE_CLUSTER = 6,
    CREATE_NODE_POOL = 7,
    DELETE_NODE_POOL = 8,
    SET_NODE_POOL_MANAGEMENT = 9,
    AUTO_REPAIR_NODES = 10,
    AUTO_UPGRADE_NODES = 11,
    SET_LABELS = 12,
    SET_MASTER_AUTH = 13,
    SET_NODE_POOL_SIZE = 14,
    SET_NETWORK_POLICY = 15,
    SET_MAINTENANCE_POLICY = 16,
}

impl ::protobuf::ProtobufEnum for Operation_Type {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Operation_Type> {
        match value {
            0 => ::std::option::Option::Some(Operation_Type::TYPE_UNSPECIFIED),
            1 => ::std::option::Option::Some(Operation_Type::CREATE_CLUSTER),
            2 => ::std::option::Option::Some(Operation_Type::DELETE_CLUSTER),
            3 => ::std::option::Option::Some(Operation_Type::UPGRADE_MASTER),
            4 => ::std::option::Option::Some(Operation_Type::UPGRADE_NODES),
            5 => ::std::option::Option::Some(Operation_Type::REPAIR_CLUSTER),
            6 => ::std::option::Option::Some(Operation_Type::UPDATE_CLUSTER),
            7 => ::std::option::Option::Some(Operation_Type::CREATE_NODE_POOL),
            8 => ::std::option::Option::Some(Operation_Type::DELETE_NODE_POOL),
            9 => ::std::option::Option::Some(Operation_Type::SET_NODE_POOL_MANAGEMENT),
            10 => ::std::option::Option::Some(Operation_Type::AUTO_REPAIR_NODES),
            11 => ::std::option::Option::Some(Operation_Type::AUTO_UPGRADE_NODES),
            12 => ::std::option::Option::Some(Operation_Type::SET_LABELS),
            13 => ::std::option::Option::Some(Operation_Type::SET_MASTER_AUTH),
            14 => ::std::option::Option::Some(Operation_Type::SET_NODE_POOL_SIZE),
            15 => ::std::option::Option::Some(Operation_Type::SET_NETWORK_POLICY),
            16 => ::std::option::Option::Some(Operation_Type::SET_MAINTENANCE_POLICY),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Operation_Type] = &[
            Operation_Type::TYPE_UNSPECIFIED,
            Operation_Type::CREATE_CLUSTER,
            Operation_Type::DELETE_CLUSTER,
            Operation_Type::UPGRADE_MASTER,
            Operation_Type::UPGRADE_NODES,
            Operation_Type::REPAIR_CLUSTER,
            Operation_Type::UPDATE_CLUSTER,
            Operation_Type::CREATE_NODE_POOL,
            Operation_Type::DELETE_NODE_POOL,
            Operation_Type::SET_NODE_POOL_MANAGEMENT,
            Operation_Type::AUTO_REPAIR_NODES,
            Operation_Type::AUTO_UPGRADE_NODES,
            Operation_Type::SET_LABELS,
            Operation_Type::SET_MASTER_AUTH,
            Operation_Type::SET_NODE_POOL_SIZE,
            Operation_Type::SET_NETWORK_POLICY,
            Operation_Type::SET_MAINTENANCE_POLICY,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<Operation_Type>("Operation.Type", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for Operation_Type {
}

impl ::std::default::Default for Operation_Type {
    fn default() -> Self {
        Operation_Type::TYPE_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for Operation_Type {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateClusterRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster: ::protobuf::SingularPtrField<Cluster>,
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateClusterRequest {
    fn default() -> &'a CreateClusterRequest {
        <CreateClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateClusterRequest {
    pub fn new() -> CreateClusterRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // .google.container.v1.Cluster cluster = 3;


    pub fn get_cluster(&self) -> &Cluster {
        self.cluster.as_ref().unwrap_or_else(|| <Cluster as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cluster(&mut self) {
        self.cluster.clear();
    }

    pub fn has_cluster(&self) -> bool {
        self.cluster.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cluster(&mut self, v: Cluster) {
        self.cluster = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster(&mut self) -> &mut Cluster {
        if self.cluster.is_none() {
            self.cluster.set_default();
        }
        self.cluster.as_mut().unwrap()
    }

    // Take field
    pub fn take_cluster(&mut self) -> Cluster {
        self.cluster.take().unwrap_or_else(|| Cluster::new())
    }

    // string parent = 5;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateClusterRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.cluster {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cluster)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if let Some(ref v) = self.cluster.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if let Some(ref v) = self.cluster.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.parent.is_empty() {
            os.write_string(5, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateClusterRequest {
        CreateClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &CreateClusterRequest| { &m.project_id },
                |m: &mut CreateClusterRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &CreateClusterRequest| { &m.zone },
                |m: &mut CreateClusterRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cluster>>(
                "cluster",
                |m: &CreateClusterRequest| { &m.cluster },
                |m: &mut CreateClusterRequest| { &mut m.cluster },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateClusterRequest| { &m.parent },
                |m: &mut CreateClusterRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateClusterRequest>(
                "CreateClusterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateClusterRequest {
        static instance: ::protobuf::rt::LazyV2<CreateClusterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateClusterRequest::new)
    }
}

impl ::protobuf::Clear for CreateClusterRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster.clear();
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetClusterRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetClusterRequest {
    fn default() -> &'a GetClusterRequest {
        <GetClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetClusterRequest {
    pub fn new() -> GetClusterRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string name = 5;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetClusterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetClusterRequest {
        GetClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &GetClusterRequest| { &m.project_id },
                |m: &mut GetClusterRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &GetClusterRequest| { &m.zone },
                |m: &mut GetClusterRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &GetClusterRequest| { &m.cluster_id },
                |m: &mut GetClusterRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetClusterRequest| { &m.name },
                |m: &mut GetClusterRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetClusterRequest>(
                "GetClusterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetClusterRequest {
        static instance: ::protobuf::rt::LazyV2<GetClusterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetClusterRequest::new)
    }
}

impl ::protobuf::Clear for GetClusterRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateClusterRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub update: ::protobuf::SingularPtrField<ClusterUpdate>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateClusterRequest {
    fn default() -> &'a UpdateClusterRequest {
        <UpdateClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateClusterRequest {
    pub fn new() -> UpdateClusterRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // .google.container.v1.ClusterUpdate update = 4;


    pub fn get_update(&self) -> &ClusterUpdate {
        self.update.as_ref().unwrap_or_else(|| <ClusterUpdate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: ClusterUpdate) {
        self.update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut ClusterUpdate {
        if self.update.is_none() {
            self.update.set_default();
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> ClusterUpdate {
        self.update.take().unwrap_or_else(|| ClusterUpdate::new())
    }

    // string name = 5;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateClusterRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if let Some(ref v) = self.update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if let Some(ref v) = self.update.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateClusterRequest {
        UpdateClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &UpdateClusterRequest| { &m.project_id },
                |m: &mut UpdateClusterRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &UpdateClusterRequest| { &m.zone },
                |m: &mut UpdateClusterRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &UpdateClusterRequest| { &m.cluster_id },
                |m: &mut UpdateClusterRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClusterUpdate>>(
                "update",
                |m: &UpdateClusterRequest| { &m.update },
                |m: &mut UpdateClusterRequest| { &mut m.update },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UpdateClusterRequest| { &m.name },
                |m: &mut UpdateClusterRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateClusterRequest>(
                "UpdateClusterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateClusterRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateClusterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateClusterRequest::new)
    }
}

impl ::protobuf::Clear for UpdateClusterRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.update.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateNodePoolRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub node_pool_id: ::std::string::String,
    pub node_version: ::std::string::String,
    pub image_type: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateNodePoolRequest {
    fn default() -> &'a UpdateNodePoolRequest {
        <UpdateNodePoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateNodePoolRequest {
    pub fn new() -> UpdateNodePoolRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string node_pool_id = 4;


    pub fn get_node_pool_id(&self) -> &str {
        &self.node_pool_id
    }
    pub fn clear_node_pool_id(&mut self) {
        self.node_pool_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pool_id(&mut self, v: ::std::string::String) {
        self.node_pool_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pool_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_pool_id
    }

    // Take field
    pub fn take_node_pool_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pool_id, ::std::string::String::new())
    }

    // string node_version = 5;


    pub fn get_node_version(&self) -> &str {
        &self.node_version
    }
    pub fn clear_node_version(&mut self) {
        self.node_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_version(&mut self, v: ::std::string::String) {
        self.node_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_version(&mut self) -> &mut ::std::string::String {
        &mut self.node_version
    }

    // Take field
    pub fn take_node_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_version, ::std::string::String::new())
    }

    // string image_type = 6;


    pub fn get_image_type(&self) -> &str {
        &self.image_type
    }
    pub fn clear_image_type(&mut self) {
        self.image_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_image_type(&mut self, v: ::std::string::String) {
        self.image_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image_type(&mut self) -> &mut ::std::string::String {
        &mut self.image_type
    }

    // Take field
    pub fn take_image_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.image_type, ::std::string::String::new())
    }

    // string name = 8;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateNodePoolRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pool_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_version)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.image_type)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.node_pool_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node_pool_id);
        }
        if !self.node_version.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.node_version);
        }
        if !self.image_type.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.image_type);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            os.write_string(4, &self.node_pool_id)?;
        }
        if !self.node_version.is_empty() {
            os.write_string(5, &self.node_version)?;
        }
        if !self.image_type.is_empty() {
            os.write_string(6, &self.image_type)?;
        }
        if !self.name.is_empty() {
            os.write_string(8, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateNodePoolRequest {
        UpdateNodePoolRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &UpdateNodePoolRequest| { &m.project_id },
                |m: &mut UpdateNodePoolRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &UpdateNodePoolRequest| { &m.zone },
                |m: &mut UpdateNodePoolRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &UpdateNodePoolRequest| { &m.cluster_id },
                |m: &mut UpdateNodePoolRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_pool_id",
                |m: &UpdateNodePoolRequest| { &m.node_pool_id },
                |m: &mut UpdateNodePoolRequest| { &mut m.node_pool_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_version",
                |m: &UpdateNodePoolRequest| { &m.node_version },
                |m: &mut UpdateNodePoolRequest| { &mut m.node_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image_type",
                |m: &UpdateNodePoolRequest| { &m.image_type },
                |m: &mut UpdateNodePoolRequest| { &mut m.image_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UpdateNodePoolRequest| { &m.name },
                |m: &mut UpdateNodePoolRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateNodePoolRequest>(
                "UpdateNodePoolRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateNodePoolRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateNodePoolRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateNodePoolRequest::new)
    }
}

impl ::protobuf::Clear for UpdateNodePoolRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.node_pool_id.clear();
        self.node_version.clear();
        self.image_type.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateNodePoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateNodePoolRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetNodePoolAutoscalingRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub node_pool_id: ::std::string::String,
    pub autoscaling: ::protobuf::SingularPtrField<NodePoolAutoscaling>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetNodePoolAutoscalingRequest {
    fn default() -> &'a SetNodePoolAutoscalingRequest {
        <SetNodePoolAutoscalingRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetNodePoolAutoscalingRequest {
    pub fn new() -> SetNodePoolAutoscalingRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string node_pool_id = 4;


    pub fn get_node_pool_id(&self) -> &str {
        &self.node_pool_id
    }
    pub fn clear_node_pool_id(&mut self) {
        self.node_pool_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pool_id(&mut self, v: ::std::string::String) {
        self.node_pool_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pool_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_pool_id
    }

    // Take field
    pub fn take_node_pool_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pool_id, ::std::string::String::new())
    }

    // .google.container.v1.NodePoolAutoscaling autoscaling = 5;


    pub fn get_autoscaling(&self) -> &NodePoolAutoscaling {
        self.autoscaling.as_ref().unwrap_or_else(|| <NodePoolAutoscaling as ::protobuf::Message>::default_instance())
    }
    pub fn clear_autoscaling(&mut self) {
        self.autoscaling.clear();
    }

    pub fn has_autoscaling(&self) -> bool {
        self.autoscaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autoscaling(&mut self, v: NodePoolAutoscaling) {
        self.autoscaling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_autoscaling(&mut self) -> &mut NodePoolAutoscaling {
        if self.autoscaling.is_none() {
            self.autoscaling.set_default();
        }
        self.autoscaling.as_mut().unwrap()
    }

    // Take field
    pub fn take_autoscaling(&mut self) -> NodePoolAutoscaling {
        self.autoscaling.take().unwrap_or_else(|| NodePoolAutoscaling::new())
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetNodePoolAutoscalingRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.autoscaling {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pool_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.autoscaling)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.node_pool_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node_pool_id);
        }
        if let Some(ref v) = self.autoscaling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            os.write_string(4, &self.node_pool_id)?;
        }
        if let Some(ref v) = self.autoscaling.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetNodePoolAutoscalingRequest {
        SetNodePoolAutoscalingRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetNodePoolAutoscalingRequest| { &m.project_id },
                |m: &mut SetNodePoolAutoscalingRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetNodePoolAutoscalingRequest| { &m.zone },
                |m: &mut SetNodePoolAutoscalingRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetNodePoolAutoscalingRequest| { &m.cluster_id },
                |m: &mut SetNodePoolAutoscalingRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_pool_id",
                |m: &SetNodePoolAutoscalingRequest| { &m.node_pool_id },
                |m: &mut SetNodePoolAutoscalingRequest| { &mut m.node_pool_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePoolAutoscaling>>(
                "autoscaling",
                |m: &SetNodePoolAutoscalingRequest| { &m.autoscaling },
                |m: &mut SetNodePoolAutoscalingRequest| { &mut m.autoscaling },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetNodePoolAutoscalingRequest| { &m.name },
                |m: &mut SetNodePoolAutoscalingRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetNodePoolAutoscalingRequest>(
                "SetNodePoolAutoscalingRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetNodePoolAutoscalingRequest {
        static instance: ::protobuf::rt::LazyV2<SetNodePoolAutoscalingRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetNodePoolAutoscalingRequest::new)
    }
}

impl ::protobuf::Clear for SetNodePoolAutoscalingRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.node_pool_id.clear();
        self.autoscaling.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetNodePoolAutoscalingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetNodePoolAutoscalingRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetLoggingServiceRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub logging_service: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetLoggingServiceRequest {
    fn default() -> &'a SetLoggingServiceRequest {
        <SetLoggingServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetLoggingServiceRequest {
    pub fn new() -> SetLoggingServiceRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string logging_service = 4;


    pub fn get_logging_service(&self) -> &str {
        &self.logging_service
    }
    pub fn clear_logging_service(&mut self) {
        self.logging_service.clear();
    }

    // Param is passed by value, moved
    pub fn set_logging_service(&mut self, v: ::std::string::String) {
        self.logging_service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logging_service(&mut self) -> &mut ::std::string::String {
        &mut self.logging_service
    }

    // Take field
    pub fn take_logging_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logging_service, ::std::string::String::new())
    }

    // string name = 5;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetLoggingServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logging_service)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.logging_service.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.logging_service);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.logging_service.is_empty() {
            os.write_string(4, &self.logging_service)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetLoggingServiceRequest {
        SetLoggingServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetLoggingServiceRequest| { &m.project_id },
                |m: &mut SetLoggingServiceRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetLoggingServiceRequest| { &m.zone },
                |m: &mut SetLoggingServiceRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetLoggingServiceRequest| { &m.cluster_id },
                |m: &mut SetLoggingServiceRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "logging_service",
                |m: &SetLoggingServiceRequest| { &m.logging_service },
                |m: &mut SetLoggingServiceRequest| { &mut m.logging_service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetLoggingServiceRequest| { &m.name },
                |m: &mut SetLoggingServiceRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetLoggingServiceRequest>(
                "SetLoggingServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetLoggingServiceRequest {
        static instance: ::protobuf::rt::LazyV2<SetLoggingServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetLoggingServiceRequest::new)
    }
}

impl ::protobuf::Clear for SetLoggingServiceRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.logging_service.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetLoggingServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetLoggingServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetMonitoringServiceRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub monitoring_service: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMonitoringServiceRequest {
    fn default() -> &'a SetMonitoringServiceRequest {
        <SetMonitoringServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetMonitoringServiceRequest {
    pub fn new() -> SetMonitoringServiceRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string monitoring_service = 4;


    pub fn get_monitoring_service(&self) -> &str {
        &self.monitoring_service
    }
    pub fn clear_monitoring_service(&mut self) {
        self.monitoring_service.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitoring_service(&mut self, v: ::std::string::String) {
        self.monitoring_service = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_monitoring_service(&mut self) -> &mut ::std::string::String {
        &mut self.monitoring_service
    }

    // Take field
    pub fn take_monitoring_service(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.monitoring_service, ::std::string::String::new())
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetMonitoringServiceRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.monitoring_service)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.monitoring_service.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.monitoring_service);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.monitoring_service.is_empty() {
            os.write_string(4, &self.monitoring_service)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMonitoringServiceRequest {
        SetMonitoringServiceRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetMonitoringServiceRequest| { &m.project_id },
                |m: &mut SetMonitoringServiceRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetMonitoringServiceRequest| { &m.zone },
                |m: &mut SetMonitoringServiceRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetMonitoringServiceRequest| { &m.cluster_id },
                |m: &mut SetMonitoringServiceRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "monitoring_service",
                |m: &SetMonitoringServiceRequest| { &m.monitoring_service },
                |m: &mut SetMonitoringServiceRequest| { &mut m.monitoring_service },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetMonitoringServiceRequest| { &m.name },
                |m: &mut SetMonitoringServiceRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetMonitoringServiceRequest>(
                "SetMonitoringServiceRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetMonitoringServiceRequest {
        static instance: ::protobuf::rt::LazyV2<SetMonitoringServiceRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMonitoringServiceRequest::new)
    }
}

impl ::protobuf::Clear for SetMonitoringServiceRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.monitoring_service.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetMonitoringServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMonitoringServiceRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetAddonsConfigRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub addons_config: ::protobuf::SingularPtrField<AddonsConfig>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetAddonsConfigRequest {
    fn default() -> &'a SetAddonsConfigRequest {
        <SetAddonsConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetAddonsConfigRequest {
    pub fn new() -> SetAddonsConfigRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // .google.container.v1.AddonsConfig addons_config = 4;


    pub fn get_addons_config(&self) -> &AddonsConfig {
        self.addons_config.as_ref().unwrap_or_else(|| <AddonsConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addons_config(&mut self) {
        self.addons_config.clear();
    }

    pub fn has_addons_config(&self) -> bool {
        self.addons_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addons_config(&mut self, v: AddonsConfig) {
        self.addons_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addons_config(&mut self) -> &mut AddonsConfig {
        if self.addons_config.is_none() {
            self.addons_config.set_default();
        }
        self.addons_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_addons_config(&mut self) -> AddonsConfig {
        self.addons_config.take().unwrap_or_else(|| AddonsConfig::new())
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetAddonsConfigRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.addons_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addons_config)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if let Some(ref v) = self.addons_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if let Some(ref v) = self.addons_config.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetAddonsConfigRequest {
        SetAddonsConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetAddonsConfigRequest| { &m.project_id },
                |m: &mut SetAddonsConfigRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetAddonsConfigRequest| { &m.zone },
                |m: &mut SetAddonsConfigRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetAddonsConfigRequest| { &m.cluster_id },
                |m: &mut SetAddonsConfigRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddonsConfig>>(
                "addons_config",
                |m: &SetAddonsConfigRequest| { &m.addons_config },
                |m: &mut SetAddonsConfigRequest| { &mut m.addons_config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetAddonsConfigRequest| { &m.name },
                |m: &mut SetAddonsConfigRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetAddonsConfigRequest>(
                "SetAddonsConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetAddonsConfigRequest {
        static instance: ::protobuf::rt::LazyV2<SetAddonsConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetAddonsConfigRequest::new)
    }
}

impl ::protobuf::Clear for SetAddonsConfigRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.addons_config.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetAddonsConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetAddonsConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetLocationsRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub locations: ::protobuf::RepeatedField<::std::string::String>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetLocationsRequest {
    fn default() -> &'a SetLocationsRequest {
        <SetLocationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetLocationsRequest {
    pub fn new() -> SetLocationsRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // repeated string locations = 4;


    pub fn get_locations(&self) -> &[::std::string::String] {
        &self.locations
    }
    pub fn clear_locations(&mut self) {
        self.locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_locations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_locations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.locations
    }

    // Take field
    pub fn take_locations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.locations, ::protobuf::RepeatedField::new())
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetLocationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.locations)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        for value in &self.locations {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        for v in &self.locations {
            os.write_string(4, &v)?;
        };
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetLocationsRequest {
        SetLocationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetLocationsRequest| { &m.project_id },
                |m: &mut SetLocationsRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetLocationsRequest| { &m.zone },
                |m: &mut SetLocationsRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetLocationsRequest| { &m.cluster_id },
                |m: &mut SetLocationsRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "locations",
                |m: &SetLocationsRequest| { &m.locations },
                |m: &mut SetLocationsRequest| { &mut m.locations },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetLocationsRequest| { &m.name },
                |m: &mut SetLocationsRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetLocationsRequest>(
                "SetLocationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetLocationsRequest {
        static instance: ::protobuf::rt::LazyV2<SetLocationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetLocationsRequest::new)
    }
}

impl ::protobuf::Clear for SetLocationsRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.locations.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetLocationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetLocationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateMasterRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub master_version: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateMasterRequest {
    fn default() -> &'a UpdateMasterRequest {
        <UpdateMasterRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateMasterRequest {
    pub fn new() -> UpdateMasterRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string master_version = 4;


    pub fn get_master_version(&self) -> &str {
        &self.master_version
    }
    pub fn clear_master_version(&mut self) {
        self.master_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_master_version(&mut self, v: ::std::string::String) {
        self.master_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_master_version(&mut self) -> &mut ::std::string::String {
        &mut self.master_version
    }

    // Take field
    pub fn take_master_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.master_version, ::std::string::String::new())
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateMasterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.master_version)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.master_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.master_version);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.master_version.is_empty() {
            os.write_string(4, &self.master_version)?;
        }
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateMasterRequest {
        UpdateMasterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &UpdateMasterRequest| { &m.project_id },
                |m: &mut UpdateMasterRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &UpdateMasterRequest| { &m.zone },
                |m: &mut UpdateMasterRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &UpdateMasterRequest| { &m.cluster_id },
                |m: &mut UpdateMasterRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "master_version",
                |m: &UpdateMasterRequest| { &m.master_version },
                |m: &mut UpdateMasterRequest| { &mut m.master_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &UpdateMasterRequest| { &m.name },
                |m: &mut UpdateMasterRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateMasterRequest>(
                "UpdateMasterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateMasterRequest {
        static instance: ::protobuf::rt::LazyV2<UpdateMasterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateMasterRequest::new)
    }
}

impl ::protobuf::Clear for UpdateMasterRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.master_version.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateMasterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateMasterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetMasterAuthRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub action: SetMasterAuthRequest_Action,
    pub update: ::protobuf::SingularPtrField<MasterAuth>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMasterAuthRequest {
    fn default() -> &'a SetMasterAuthRequest {
        <SetMasterAuthRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetMasterAuthRequest {
    pub fn new() -> SetMasterAuthRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // .google.container.v1.SetMasterAuthRequest.Action action = 4;


    pub fn get_action(&self) -> SetMasterAuthRequest_Action {
        self.action
    }
    pub fn clear_action(&mut self) {
        self.action = SetMasterAuthRequest_Action::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: SetMasterAuthRequest_Action) {
        self.action = v;
    }

    // .google.container.v1.MasterAuth update = 5;


    pub fn get_update(&self) -> &MasterAuth {
        self.update.as_ref().unwrap_or_else(|| <MasterAuth as ::protobuf::Message>::default_instance())
    }
    pub fn clear_update(&mut self) {
        self.update.clear();
    }

    pub fn has_update(&self) -> bool {
        self.update.is_some()
    }

    // Param is passed by value, moved
    pub fn set_update(&mut self, v: MasterAuth) {
        self.update = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_update(&mut self) -> &mut MasterAuth {
        if self.update.is_none() {
            self.update.set_default();
        }
        self.update.as_mut().unwrap()
    }

    // Take field
    pub fn take_update(&mut self) -> MasterAuth {
        self.update.take().unwrap_or_else(|| MasterAuth::new())
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetMasterAuthRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.update {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.action, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.update)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if self.action != SetMasterAuthRequest_Action::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(4, self.action);
        }
        if let Some(ref v) = self.update.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if self.action != SetMasterAuthRequest_Action::UNKNOWN {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&self.action))?;
        }
        if let Some(ref v) = self.update.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMasterAuthRequest {
        SetMasterAuthRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetMasterAuthRequest| { &m.project_id },
                |m: &mut SetMasterAuthRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetMasterAuthRequest| { &m.zone },
                |m: &mut SetMasterAuthRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetMasterAuthRequest| { &m.cluster_id },
                |m: &mut SetMasterAuthRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<SetMasterAuthRequest_Action>>(
                "action",
                |m: &SetMasterAuthRequest| { &m.action },
                |m: &mut SetMasterAuthRequest| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MasterAuth>>(
                "update",
                |m: &SetMasterAuthRequest| { &m.update },
                |m: &mut SetMasterAuthRequest| { &mut m.update },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetMasterAuthRequest| { &m.name },
                |m: &mut SetMasterAuthRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetMasterAuthRequest>(
                "SetMasterAuthRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetMasterAuthRequest {
        static instance: ::protobuf::rt::LazyV2<SetMasterAuthRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMasterAuthRequest::new)
    }
}

impl ::protobuf::Clear for SetMasterAuthRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.action = SetMasterAuthRequest_Action::UNKNOWN;
        self.update.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetMasterAuthRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMasterAuthRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum SetMasterAuthRequest_Action {
    UNKNOWN = 0,
    SET_PASSWORD = 1,
    GENERATE_PASSWORD = 2,
    SET_USERNAME = 3,
}

impl ::protobuf::ProtobufEnum for SetMasterAuthRequest_Action {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SetMasterAuthRequest_Action> {
        match value {
            0 => ::std::option::Option::Some(SetMasterAuthRequest_Action::UNKNOWN),
            1 => ::std::option::Option::Some(SetMasterAuthRequest_Action::SET_PASSWORD),
            2 => ::std::option::Option::Some(SetMasterAuthRequest_Action::GENERATE_PASSWORD),
            3 => ::std::option::Option::Some(SetMasterAuthRequest_Action::SET_USERNAME),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [SetMasterAuthRequest_Action] = &[
            SetMasterAuthRequest_Action::UNKNOWN,
            SetMasterAuthRequest_Action::SET_PASSWORD,
            SetMasterAuthRequest_Action::GENERATE_PASSWORD,
            SetMasterAuthRequest_Action::SET_USERNAME,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<SetMasterAuthRequest_Action>("SetMasterAuthRequest.Action", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for SetMasterAuthRequest_Action {
}

impl ::std::default::Default for SetMasterAuthRequest_Action {
    fn default() -> Self {
        SetMasterAuthRequest_Action::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMasterAuthRequest_Action {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteClusterRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteClusterRequest {
    fn default() -> &'a DeleteClusterRequest {
        <DeleteClusterRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteClusterRequest {
    pub fn new() -> DeleteClusterRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteClusterRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteClusterRequest {
        DeleteClusterRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &DeleteClusterRequest| { &m.project_id },
                |m: &mut DeleteClusterRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &DeleteClusterRequest| { &m.zone },
                |m: &mut DeleteClusterRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &DeleteClusterRequest| { &m.cluster_id },
                |m: &mut DeleteClusterRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteClusterRequest| { &m.name },
                |m: &mut DeleteClusterRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteClusterRequest>(
                "DeleteClusterRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteClusterRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteClusterRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteClusterRequest::new)
    }
}

impl ::protobuf::Clear for DeleteClusterRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteClusterRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteClusterRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListClustersRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListClustersRequest {
    fn default() -> &'a ListClustersRequest {
        <ListClustersRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListClustersRequest {
    pub fn new() -> ListClustersRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string parent = 4;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListClustersRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.parent.is_empty() {
            os.write_string(4, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListClustersRequest {
        ListClustersRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &ListClustersRequest| { &m.project_id },
                |m: &mut ListClustersRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &ListClustersRequest| { &m.zone },
                |m: &mut ListClustersRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListClustersRequest| { &m.parent },
                |m: &mut ListClustersRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListClustersRequest>(
                "ListClustersRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListClustersRequest {
        static instance: ::protobuf::rt::LazyV2<ListClustersRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListClustersRequest::new)
    }
}

impl ::protobuf::Clear for ListClustersRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListClustersRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListClustersRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListClustersResponse {
    // message fields
    pub clusters: ::protobuf::RepeatedField<Cluster>,
    pub missing_zones: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListClustersResponse {
    fn default() -> &'a ListClustersResponse {
        <ListClustersResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListClustersResponse {
    pub fn new() -> ListClustersResponse {
        ::std::default::Default::default()
    }

    // repeated .google.container.v1.Cluster clusters = 1;


    pub fn get_clusters(&self) -> &[Cluster] {
        &self.clusters
    }
    pub fn clear_clusters(&mut self) {
        self.clusters.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusters(&mut self, v: ::protobuf::RepeatedField<Cluster>) {
        self.clusters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusters(&mut self) -> &mut ::protobuf::RepeatedField<Cluster> {
        &mut self.clusters
    }

    // Take field
    pub fn take_clusters(&mut self) -> ::protobuf::RepeatedField<Cluster> {
        ::std::mem::replace(&mut self.clusters, ::protobuf::RepeatedField::new())
    }

    // repeated string missing_zones = 2;


    pub fn get_missing_zones(&self) -> &[::std::string::String] {
        &self.missing_zones
    }
    pub fn clear_missing_zones(&mut self) {
        self.missing_zones.clear();
    }

    // Param is passed by value, moved
    pub fn set_missing_zones(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.missing_zones = v;
    }

    // Mutable pointer to the field.
    pub fn mut_missing_zones(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.missing_zones
    }

    // Take field
    pub fn take_missing_zones(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.missing_zones, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListClustersResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.clusters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.clusters)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.missing_zones)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.clusters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.missing_zones {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.clusters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.missing_zones {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListClustersResponse {
        ListClustersResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cluster>>(
                "clusters",
                |m: &ListClustersResponse| { &m.clusters },
                |m: &mut ListClustersResponse| { &mut m.clusters },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "missing_zones",
                |m: &ListClustersResponse| { &m.missing_zones },
                |m: &mut ListClustersResponse| { &mut m.missing_zones },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListClustersResponse>(
                "ListClustersResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListClustersResponse {
        static instance: ::protobuf::rt::LazyV2<ListClustersResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListClustersResponse::new)
    }
}

impl ::protobuf::Clear for ListClustersResponse {
    fn clear(&mut self) {
        self.clusters.clear();
        self.missing_zones.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListClustersResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListClustersResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOperationRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub operation_id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetOperationRequest {
    fn default() -> &'a GetOperationRequest {
        <GetOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetOperationRequest {
    pub fn new() -> GetOperationRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string operation_id = 3;


    pub fn get_operation_id(&self) -> &str {
        &self.operation_id
    }
    pub fn clear_operation_id(&mut self) {
        self.operation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_id(&mut self, v: ::std::string::String) {
        self.operation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_id(&mut self) -> &mut ::std::string::String {
        &mut self.operation_id
    }

    // Take field
    pub fn take_operation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_id, ::std::string::String::new())
    }

    // string name = 5;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetOperationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.operation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.operation_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.operation_id.is_empty() {
            os.write_string(3, &self.operation_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOperationRequest {
        GetOperationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &GetOperationRequest| { &m.project_id },
                |m: &mut GetOperationRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &GetOperationRequest| { &m.zone },
                |m: &mut GetOperationRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operation_id",
                |m: &GetOperationRequest| { &m.operation_id },
                |m: &mut GetOperationRequest| { &mut m.operation_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetOperationRequest| { &m.name },
                |m: &mut GetOperationRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetOperationRequest>(
                "GetOperationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetOperationRequest {
        static instance: ::protobuf::rt::LazyV2<GetOperationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetOperationRequest::new)
    }
}

impl ::protobuf::Clear for GetOperationRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.operation_id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOperationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOperationsRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOperationsRequest {
    fn default() -> &'a ListOperationsRequest {
        <ListOperationsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListOperationsRequest {
    pub fn new() -> ListOperationsRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string parent = 4;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOperationsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.parent.is_empty() {
            os.write_string(4, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOperationsRequest {
        ListOperationsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &ListOperationsRequest| { &m.project_id },
                |m: &mut ListOperationsRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &ListOperationsRequest| { &m.zone },
                |m: &mut ListOperationsRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListOperationsRequest| { &m.parent },
                |m: &mut ListOperationsRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOperationsRequest>(
                "ListOperationsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOperationsRequest {
        static instance: ::protobuf::rt::LazyV2<ListOperationsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOperationsRequest::new)
    }
}

impl ::protobuf::Clear for ListOperationsRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOperationsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOperationsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CancelOperationRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub operation_id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CancelOperationRequest {
    fn default() -> &'a CancelOperationRequest {
        <CancelOperationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CancelOperationRequest {
    pub fn new() -> CancelOperationRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string operation_id = 3;


    pub fn get_operation_id(&self) -> &str {
        &self.operation_id
    }
    pub fn clear_operation_id(&mut self) {
        self.operation_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_operation_id(&mut self, v: ::std::string::String) {
        self.operation_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation_id(&mut self) -> &mut ::std::string::String {
        &mut self.operation_id
    }

    // Take field
    pub fn take_operation_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.operation_id, ::std::string::String::new())
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CancelOperationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.operation_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.operation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.operation_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.operation_id.is_empty() {
            os.write_string(3, &self.operation_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CancelOperationRequest {
        CancelOperationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &CancelOperationRequest| { &m.project_id },
                |m: &mut CancelOperationRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &CancelOperationRequest| { &m.zone },
                |m: &mut CancelOperationRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operation_id",
                |m: &CancelOperationRequest| { &m.operation_id },
                |m: &mut CancelOperationRequest| { &mut m.operation_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CancelOperationRequest| { &m.name },
                |m: &mut CancelOperationRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CancelOperationRequest>(
                "CancelOperationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CancelOperationRequest {
        static instance: ::protobuf::rt::LazyV2<CancelOperationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CancelOperationRequest::new)
    }
}

impl ::protobuf::Clear for CancelOperationRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.operation_id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CancelOperationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CancelOperationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOperationsResponse {
    // message fields
    pub operations: ::protobuf::RepeatedField<Operation>,
    pub missing_zones: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOperationsResponse {
    fn default() -> &'a ListOperationsResponse {
        <ListOperationsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListOperationsResponse {
    pub fn new() -> ListOperationsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.container.v1.Operation operations = 1;


    pub fn get_operations(&self) -> &[Operation] {
        &self.operations
    }
    pub fn clear_operations(&mut self) {
        self.operations.clear();
    }

    // Param is passed by value, moved
    pub fn set_operations(&mut self, v: ::protobuf::RepeatedField<Operation>) {
        self.operations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_operations(&mut self) -> &mut ::protobuf::RepeatedField<Operation> {
        &mut self.operations
    }

    // Take field
    pub fn take_operations(&mut self) -> ::protobuf::RepeatedField<Operation> {
        ::std::mem::replace(&mut self.operations, ::protobuf::RepeatedField::new())
    }

    // repeated string missing_zones = 2;


    pub fn get_missing_zones(&self) -> &[::std::string::String] {
        &self.missing_zones
    }
    pub fn clear_missing_zones(&mut self) {
        self.missing_zones.clear();
    }

    // Param is passed by value, moved
    pub fn set_missing_zones(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.missing_zones = v;
    }

    // Mutable pointer to the field.
    pub fn mut_missing_zones(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.missing_zones
    }

    // Take field
    pub fn take_missing_zones(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.missing_zones, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListOperationsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.operations {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.operations)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.missing_zones)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.operations {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.missing_zones {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.operations {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.missing_zones {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOperationsResponse {
        ListOperationsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Operation>>(
                "operations",
                |m: &ListOperationsResponse| { &m.operations },
                |m: &mut ListOperationsResponse| { &mut m.operations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "missing_zones",
                |m: &ListOperationsResponse| { &m.missing_zones },
                |m: &mut ListOperationsResponse| { &mut m.missing_zones },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOperationsResponse>(
                "ListOperationsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOperationsResponse {
        static instance: ::protobuf::rt::LazyV2<ListOperationsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOperationsResponse::new)
    }
}

impl ::protobuf::Clear for ListOperationsResponse {
    fn clear(&mut self) {
        self.operations.clear();
        self.missing_zones.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOperationsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOperationsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetServerConfigRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetServerConfigRequest {
    fn default() -> &'a GetServerConfigRequest {
        <GetServerConfigRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetServerConfigRequest {
    pub fn new() -> GetServerConfigRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string name = 4;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetServerConfigRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetServerConfigRequest {
        GetServerConfigRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &GetServerConfigRequest| { &m.project_id },
                |m: &mut GetServerConfigRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &GetServerConfigRequest| { &m.zone },
                |m: &mut GetServerConfigRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetServerConfigRequest| { &m.name },
                |m: &mut GetServerConfigRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetServerConfigRequest>(
                "GetServerConfigRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetServerConfigRequest {
        static instance: ::protobuf::rt::LazyV2<GetServerConfigRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetServerConfigRequest::new)
    }
}

impl ::protobuf::Clear for GetServerConfigRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetServerConfigRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetServerConfigRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerConfig {
    // message fields
    pub default_cluster_version: ::std::string::String,
    pub valid_node_versions: ::protobuf::RepeatedField<::std::string::String>,
    pub default_image_type: ::std::string::String,
    pub valid_image_types: ::protobuf::RepeatedField<::std::string::String>,
    pub valid_master_versions: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerConfig {
    fn default() -> &'a ServerConfig {
        <ServerConfig as ::protobuf::Message>::default_instance()
    }
}

impl ServerConfig {
    pub fn new() -> ServerConfig {
        ::std::default::Default::default()
    }

    // string default_cluster_version = 1;


    pub fn get_default_cluster_version(&self) -> &str {
        &self.default_cluster_version
    }
    pub fn clear_default_cluster_version(&mut self) {
        self.default_cluster_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_cluster_version(&mut self, v: ::std::string::String) {
        self.default_cluster_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_cluster_version(&mut self) -> &mut ::std::string::String {
        &mut self.default_cluster_version
    }

    // Take field
    pub fn take_default_cluster_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_cluster_version, ::std::string::String::new())
    }

    // repeated string valid_node_versions = 3;


    pub fn get_valid_node_versions(&self) -> &[::std::string::String] {
        &self.valid_node_versions
    }
    pub fn clear_valid_node_versions(&mut self) {
        self.valid_node_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_valid_node_versions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.valid_node_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_valid_node_versions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.valid_node_versions
    }

    // Take field
    pub fn take_valid_node_versions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.valid_node_versions, ::protobuf::RepeatedField::new())
    }

    // string default_image_type = 4;


    pub fn get_default_image_type(&self) -> &str {
        &self.default_image_type
    }
    pub fn clear_default_image_type(&mut self) {
        self.default_image_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_default_image_type(&mut self, v: ::std::string::String) {
        self.default_image_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_default_image_type(&mut self) -> &mut ::std::string::String {
        &mut self.default_image_type
    }

    // Take field
    pub fn take_default_image_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.default_image_type, ::std::string::String::new())
    }

    // repeated string valid_image_types = 5;


    pub fn get_valid_image_types(&self) -> &[::std::string::String] {
        &self.valid_image_types
    }
    pub fn clear_valid_image_types(&mut self) {
        self.valid_image_types.clear();
    }

    // Param is passed by value, moved
    pub fn set_valid_image_types(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.valid_image_types = v;
    }

    // Mutable pointer to the field.
    pub fn mut_valid_image_types(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.valid_image_types
    }

    // Take field
    pub fn take_valid_image_types(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.valid_image_types, ::protobuf::RepeatedField::new())
    }

    // repeated string valid_master_versions = 6;


    pub fn get_valid_master_versions(&self) -> &[::std::string::String] {
        &self.valid_master_versions
    }
    pub fn clear_valid_master_versions(&mut self) {
        self.valid_master_versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_valid_master_versions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.valid_master_versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_valid_master_versions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.valid_master_versions
    }

    // Take field
    pub fn take_valid_master_versions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.valid_master_versions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ServerConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_cluster_version)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.valid_node_versions)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.default_image_type)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.valid_image_types)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.valid_master_versions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.default_cluster_version.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.default_cluster_version);
        }
        for value in &self.valid_node_versions {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if !self.default_image_type.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.default_image_type);
        }
        for value in &self.valid_image_types {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.valid_master_versions {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.default_cluster_version.is_empty() {
            os.write_string(1, &self.default_cluster_version)?;
        }
        for v in &self.valid_node_versions {
            os.write_string(3, &v)?;
        };
        if !self.default_image_type.is_empty() {
            os.write_string(4, &self.default_image_type)?;
        }
        for v in &self.valid_image_types {
            os.write_string(5, &v)?;
        };
        for v in &self.valid_master_versions {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerConfig {
        ServerConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "default_cluster_version",
                |m: &ServerConfig| { &m.default_cluster_version },
                |m: &mut ServerConfig| { &mut m.default_cluster_version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "valid_node_versions",
                |m: &ServerConfig| { &m.valid_node_versions },
                |m: &mut ServerConfig| { &mut m.valid_node_versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "default_image_type",
                |m: &ServerConfig| { &m.default_image_type },
                |m: &mut ServerConfig| { &mut m.default_image_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "valid_image_types",
                |m: &ServerConfig| { &m.valid_image_types },
                |m: &mut ServerConfig| { &mut m.valid_image_types },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "valid_master_versions",
                |m: &ServerConfig| { &m.valid_master_versions },
                |m: &mut ServerConfig| { &mut m.valid_master_versions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerConfig>(
                "ServerConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerConfig {
        static instance: ::protobuf::rt::LazyV2<ServerConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerConfig::new)
    }
}

impl ::protobuf::Clear for ServerConfig {
    fn clear(&mut self) {
        self.default_cluster_version.clear();
        self.valid_node_versions.clear();
        self.default_image_type.clear();
        self.valid_image_types.clear();
        self.valid_master_versions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateNodePoolRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub node_pool: ::protobuf::SingularPtrField<NodePool>,
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateNodePoolRequest {
    fn default() -> &'a CreateNodePoolRequest {
        <CreateNodePoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl CreateNodePoolRequest {
    pub fn new() -> CreateNodePoolRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // .google.container.v1.NodePool node_pool = 4;


    pub fn get_node_pool(&self) -> &NodePool {
        self.node_pool.as_ref().unwrap_or_else(|| <NodePool as ::protobuf::Message>::default_instance())
    }
    pub fn clear_node_pool(&mut self) {
        self.node_pool.clear();
    }

    pub fn has_node_pool(&self) -> bool {
        self.node_pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_node_pool(&mut self, v: NodePool) {
        self.node_pool = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pool(&mut self) -> &mut NodePool {
        if self.node_pool.is_none() {
            self.node_pool.set_default();
        }
        self.node_pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_node_pool(&mut self) -> NodePool {
        self.node_pool.take().unwrap_or_else(|| NodePool::new())
    }

    // string parent = 6;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateNodePoolRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.node_pool {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.node_pool)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if let Some(ref v) = self.node_pool.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if let Some(ref v) = self.node_pool.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.parent.is_empty() {
            os.write_string(6, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateNodePoolRequest {
        CreateNodePoolRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &CreateNodePoolRequest| { &m.project_id },
                |m: &mut CreateNodePoolRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &CreateNodePoolRequest| { &m.zone },
                |m: &mut CreateNodePoolRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &CreateNodePoolRequest| { &m.cluster_id },
                |m: &mut CreateNodePoolRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePool>>(
                "node_pool",
                |m: &CreateNodePoolRequest| { &m.node_pool },
                |m: &mut CreateNodePoolRequest| { &mut m.node_pool },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &CreateNodePoolRequest| { &m.parent },
                |m: &mut CreateNodePoolRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateNodePoolRequest>(
                "CreateNodePoolRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateNodePoolRequest {
        static instance: ::protobuf::rt::LazyV2<CreateNodePoolRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateNodePoolRequest::new)
    }
}

impl ::protobuf::Clear for CreateNodePoolRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.node_pool.clear();
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateNodePoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateNodePoolRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteNodePoolRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub node_pool_id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteNodePoolRequest {
    fn default() -> &'a DeleteNodePoolRequest {
        <DeleteNodePoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeleteNodePoolRequest {
    pub fn new() -> DeleteNodePoolRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string node_pool_id = 4;


    pub fn get_node_pool_id(&self) -> &str {
        &self.node_pool_id
    }
    pub fn clear_node_pool_id(&mut self) {
        self.node_pool_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pool_id(&mut self, v: ::std::string::String) {
        self.node_pool_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pool_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_pool_id
    }

    // Take field
    pub fn take_node_pool_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pool_id, ::std::string::String::new())
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DeleteNodePoolRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pool_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.node_pool_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node_pool_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            os.write_string(4, &self.node_pool_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteNodePoolRequest {
        DeleteNodePoolRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &DeleteNodePoolRequest| { &m.project_id },
                |m: &mut DeleteNodePoolRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &DeleteNodePoolRequest| { &m.zone },
                |m: &mut DeleteNodePoolRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &DeleteNodePoolRequest| { &m.cluster_id },
                |m: &mut DeleteNodePoolRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_pool_id",
                |m: &DeleteNodePoolRequest| { &m.node_pool_id },
                |m: &mut DeleteNodePoolRequest| { &mut m.node_pool_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &DeleteNodePoolRequest| { &m.name },
                |m: &mut DeleteNodePoolRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteNodePoolRequest>(
                "DeleteNodePoolRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteNodePoolRequest {
        static instance: ::protobuf::rt::LazyV2<DeleteNodePoolRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteNodePoolRequest::new)
    }
}

impl ::protobuf::Clear for DeleteNodePoolRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.node_pool_id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteNodePoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteNodePoolRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListNodePoolsRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub parent: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListNodePoolsRequest {
    fn default() -> &'a ListNodePoolsRequest {
        <ListNodePoolsRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListNodePoolsRequest {
    pub fn new() -> ListNodePoolsRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string parent = 5;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListNodePoolsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.parent);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.parent.is_empty() {
            os.write_string(5, &self.parent)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListNodePoolsRequest {
        ListNodePoolsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &ListNodePoolsRequest| { &m.project_id },
                |m: &mut ListNodePoolsRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &ListNodePoolsRequest| { &m.zone },
                |m: &mut ListNodePoolsRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &ListNodePoolsRequest| { &m.cluster_id },
                |m: &mut ListNodePoolsRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListNodePoolsRequest| { &m.parent },
                |m: &mut ListNodePoolsRequest| { &mut m.parent },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListNodePoolsRequest>(
                "ListNodePoolsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListNodePoolsRequest {
        static instance: ::protobuf::rt::LazyV2<ListNodePoolsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListNodePoolsRequest::new)
    }
}

impl ::protobuf::Clear for ListNodePoolsRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.parent.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListNodePoolsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListNodePoolsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetNodePoolRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub node_pool_id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetNodePoolRequest {
    fn default() -> &'a GetNodePoolRequest {
        <GetNodePoolRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetNodePoolRequest {
    pub fn new() -> GetNodePoolRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string node_pool_id = 4;


    pub fn get_node_pool_id(&self) -> &str {
        &self.node_pool_id
    }
    pub fn clear_node_pool_id(&mut self) {
        self.node_pool_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pool_id(&mut self, v: ::std::string::String) {
        self.node_pool_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pool_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_pool_id
    }

    // Take field
    pub fn take_node_pool_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pool_id, ::std::string::String::new())
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetNodePoolRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pool_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.node_pool_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node_pool_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            os.write_string(4, &self.node_pool_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetNodePoolRequest {
        GetNodePoolRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &GetNodePoolRequest| { &m.project_id },
                |m: &mut GetNodePoolRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &GetNodePoolRequest| { &m.zone },
                |m: &mut GetNodePoolRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &GetNodePoolRequest| { &m.cluster_id },
                |m: &mut GetNodePoolRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_pool_id",
                |m: &GetNodePoolRequest| { &m.node_pool_id },
                |m: &mut GetNodePoolRequest| { &mut m.node_pool_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &GetNodePoolRequest| { &m.name },
                |m: &mut GetNodePoolRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetNodePoolRequest>(
                "GetNodePoolRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetNodePoolRequest {
        static instance: ::protobuf::rt::LazyV2<GetNodePoolRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetNodePoolRequest::new)
    }
}

impl ::protobuf::Clear for GetNodePoolRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.node_pool_id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetNodePoolRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetNodePoolRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodePool {
    // message fields
    pub name: ::std::string::String,
    pub config: ::protobuf::SingularPtrField<NodeConfig>,
    pub initial_node_count: i32,
    pub self_link: ::std::string::String,
    pub version: ::std::string::String,
    pub instance_group_urls: ::protobuf::RepeatedField<::std::string::String>,
    pub status: NodePool_Status,
    pub status_message: ::std::string::String,
    pub autoscaling: ::protobuf::SingularPtrField<NodePoolAutoscaling>,
    pub management: ::protobuf::SingularPtrField<NodeManagement>,
    pub max_pods_constraint: ::protobuf::SingularPtrField<MaxPodsConstraint>,
    pub conditions: ::protobuf::RepeatedField<StatusCondition>,
    pub pod_ipv4_cidr_size: i32,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodePool {
    fn default() -> &'a NodePool {
        <NodePool as ::protobuf::Message>::default_instance()
    }
}

impl NodePool {
    pub fn new() -> NodePool {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // .google.container.v1.NodeConfig config = 2;


    pub fn get_config(&self) -> &NodeConfig {
        self.config.as_ref().unwrap_or_else(|| <NodeConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: NodeConfig) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut NodeConfig {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> NodeConfig {
        self.config.take().unwrap_or_else(|| NodeConfig::new())
    }

    // int32 initial_node_count = 3;


    pub fn get_initial_node_count(&self) -> i32 {
        self.initial_node_count
    }
    pub fn clear_initial_node_count(&mut self) {
        self.initial_node_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_initial_node_count(&mut self, v: i32) {
        self.initial_node_count = v;
    }

    // string self_link = 100;


    pub fn get_self_link(&self) -> &str {
        &self.self_link
    }
    pub fn clear_self_link(&mut self) {
        self.self_link.clear();
    }

    // Param is passed by value, moved
    pub fn set_self_link(&mut self, v: ::std::string::String) {
        self.self_link = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_self_link(&mut self) -> &mut ::std::string::String {
        &mut self.self_link
    }

    // Take field
    pub fn take_self_link(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.self_link, ::std::string::String::new())
    }

    // string version = 101;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // repeated string instance_group_urls = 102;


    pub fn get_instance_group_urls(&self) -> &[::std::string::String] {
        &self.instance_group_urls
    }
    pub fn clear_instance_group_urls(&mut self) {
        self.instance_group_urls.clear();
    }

    // Param is passed by value, moved
    pub fn set_instance_group_urls(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.instance_group_urls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_instance_group_urls(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.instance_group_urls
    }

    // Take field
    pub fn take_instance_group_urls(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.instance_group_urls, ::protobuf::RepeatedField::new())
    }

    // .google.container.v1.NodePool.Status status = 103;


    pub fn get_status(&self) -> NodePool_Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = NodePool_Status::STATUS_UNSPECIFIED;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: NodePool_Status) {
        self.status = v;
    }

    // string status_message = 104;


    pub fn get_status_message(&self) -> &str {
        &self.status_message
    }
    pub fn clear_status_message(&mut self) {
        self.status_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_status_message(&mut self, v: ::std::string::String) {
        self.status_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_message(&mut self) -> &mut ::std::string::String {
        &mut self.status_message
    }

    // Take field
    pub fn take_status_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status_message, ::std::string::String::new())
    }

    // .google.container.v1.NodePoolAutoscaling autoscaling = 4;


    pub fn get_autoscaling(&self) -> &NodePoolAutoscaling {
        self.autoscaling.as_ref().unwrap_or_else(|| <NodePoolAutoscaling as ::protobuf::Message>::default_instance())
    }
    pub fn clear_autoscaling(&mut self) {
        self.autoscaling.clear();
    }

    pub fn has_autoscaling(&self) -> bool {
        self.autoscaling.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autoscaling(&mut self, v: NodePoolAutoscaling) {
        self.autoscaling = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_autoscaling(&mut self) -> &mut NodePoolAutoscaling {
        if self.autoscaling.is_none() {
            self.autoscaling.set_default();
        }
        self.autoscaling.as_mut().unwrap()
    }

    // Take field
    pub fn take_autoscaling(&mut self) -> NodePoolAutoscaling {
        self.autoscaling.take().unwrap_or_else(|| NodePoolAutoscaling::new())
    }

    // .google.container.v1.NodeManagement management = 5;


    pub fn get_management(&self) -> &NodeManagement {
        self.management.as_ref().unwrap_or_else(|| <NodeManagement as ::protobuf::Message>::default_instance())
    }
    pub fn clear_management(&mut self) {
        self.management.clear();
    }

    pub fn has_management(&self) -> bool {
        self.management.is_some()
    }

    // Param is passed by value, moved
    pub fn set_management(&mut self, v: NodeManagement) {
        self.management = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_management(&mut self) -> &mut NodeManagement {
        if self.management.is_none() {
            self.management.set_default();
        }
        self.management.as_mut().unwrap()
    }

    // Take field
    pub fn take_management(&mut self) -> NodeManagement {
        self.management.take().unwrap_or_else(|| NodeManagement::new())
    }

    // .google.container.v1.MaxPodsConstraint max_pods_constraint = 6;


    pub fn get_max_pods_constraint(&self) -> &MaxPodsConstraint {
        self.max_pods_constraint.as_ref().unwrap_or_else(|| <MaxPodsConstraint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_max_pods_constraint(&mut self) {
        self.max_pods_constraint.clear();
    }

    pub fn has_max_pods_constraint(&self) -> bool {
        self.max_pods_constraint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_max_pods_constraint(&mut self, v: MaxPodsConstraint) {
        self.max_pods_constraint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_max_pods_constraint(&mut self) -> &mut MaxPodsConstraint {
        if self.max_pods_constraint.is_none() {
            self.max_pods_constraint.set_default();
        }
        self.max_pods_constraint.as_mut().unwrap()
    }

    // Take field
    pub fn take_max_pods_constraint(&mut self) -> MaxPodsConstraint {
        self.max_pods_constraint.take().unwrap_or_else(|| MaxPodsConstraint::new())
    }

    // repeated .google.container.v1.StatusCondition conditions = 105;


    pub fn get_conditions(&self) -> &[StatusCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<StatusCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<StatusCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<StatusCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }

    // int32 pod_ipv4_cidr_size = 7;


    pub fn get_pod_ipv4_cidr_size(&self) -> i32 {
        self.pod_ipv4_cidr_size
    }
    pub fn clear_pod_ipv4_cidr_size(&mut self) {
        self.pod_ipv4_cidr_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_pod_ipv4_cidr_size(&mut self, v: i32) {
        self.pod_ipv4_cidr_size = v;
    }
}

impl ::protobuf::Message for NodePool {
    fn is_initialized(&self) -> bool {
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.autoscaling {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.management {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.max_pods_constraint {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.initial_node_count = tmp;
                },
                100 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.self_link)?;
                },
                101 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                102 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.instance_group_urls)?;
                },
                103 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 103, &mut self.unknown_fields)?
                },
                104 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status_message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.autoscaling)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.management)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.max_pods_constraint)?;
                },
                105 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.pod_ipv4_cidr_size = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.initial_node_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.initial_node_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.self_link.is_empty() {
            my_size += ::protobuf::rt::string_size(100, &self.self_link);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(101, &self.version);
        }
        for value in &self.instance_group_urls {
            my_size += ::protobuf::rt::string_size(102, &value);
        };
        if self.status != NodePool_Status::STATUS_UNSPECIFIED {
            my_size += ::protobuf::rt::enum_size(103, self.status);
        }
        if !self.status_message.is_empty() {
            my_size += ::protobuf::rt::string_size(104, &self.status_message);
        }
        if let Some(ref v) = self.autoscaling.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.management.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.max_pods_constraint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.pod_ipv4_cidr_size != 0 {
            my_size += ::protobuf::rt::value_size(7, self.pod_ipv4_cidr_size, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.initial_node_count != 0 {
            os.write_int32(3, self.initial_node_count)?;
        }
        if !self.self_link.is_empty() {
            os.write_string(100, &self.self_link)?;
        }
        if !self.version.is_empty() {
            os.write_string(101, &self.version)?;
        }
        for v in &self.instance_group_urls {
            os.write_string(102, &v)?;
        };
        if self.status != NodePool_Status::STATUS_UNSPECIFIED {
            os.write_enum(103, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        if !self.status_message.is_empty() {
            os.write_string(104, &self.status_message)?;
        }
        if let Some(ref v) = self.autoscaling.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.management.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.max_pods_constraint.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.conditions {
            os.write_tag(105, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.pod_ipv4_cidr_size != 0 {
            os.write_int32(7, self.pod_ipv4_cidr_size)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodePool {
        NodePool::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &NodePool| { &m.name },
                |m: &mut NodePool| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeConfig>>(
                "config",
                |m: &NodePool| { &m.config },
                |m: &mut NodePool| { &mut m.config },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "initial_node_count",
                |m: &NodePool| { &m.initial_node_count },
                |m: &mut NodePool| { &mut m.initial_node_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "self_link",
                |m: &NodePool| { &m.self_link },
                |m: &mut NodePool| { &mut m.self_link },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &NodePool| { &m.version },
                |m: &mut NodePool| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instance_group_urls",
                |m: &NodePool| { &m.instance_group_urls },
                |m: &mut NodePool| { &mut m.instance_group_urls },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<NodePool_Status>>(
                "status",
                |m: &NodePool| { &m.status },
                |m: &mut NodePool| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status_message",
                |m: &NodePool| { &m.status_message },
                |m: &mut NodePool| { &mut m.status_message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePoolAutoscaling>>(
                "autoscaling",
                |m: &NodePool| { &m.autoscaling },
                |m: &mut NodePool| { &mut m.autoscaling },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeManagement>>(
                "management",
                |m: &NodePool| { &m.management },
                |m: &mut NodePool| { &mut m.management },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MaxPodsConstraint>>(
                "max_pods_constraint",
                |m: &NodePool| { &m.max_pods_constraint },
                |m: &mut NodePool| { &mut m.max_pods_constraint },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusCondition>>(
                "conditions",
                |m: &NodePool| { &m.conditions },
                |m: &mut NodePool| { &mut m.conditions },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "pod_ipv4_cidr_size",
                |m: &NodePool| { &m.pod_ipv4_cidr_size },
                |m: &mut NodePool| { &mut m.pod_ipv4_cidr_size },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodePool>(
                "NodePool",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodePool {
        static instance: ::protobuf::rt::LazyV2<NodePool> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodePool::new)
    }
}

impl ::protobuf::Clear for NodePool {
    fn clear(&mut self) {
        self.name.clear();
        self.config.clear();
        self.initial_node_count = 0;
        self.self_link.clear();
        self.version.clear();
        self.instance_group_urls.clear();
        self.status = NodePool_Status::STATUS_UNSPECIFIED;
        self.status_message.clear();
        self.autoscaling.clear();
        self.management.clear();
        self.max_pods_constraint.clear();
        self.conditions.clear();
        self.pod_ipv4_cidr_size = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodePool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodePool {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum NodePool_Status {
    STATUS_UNSPECIFIED = 0,
    PROVISIONING = 1,
    RUNNING = 2,
    RUNNING_WITH_ERROR = 3,
    RECONCILING = 4,
    STOPPING = 5,
    ERROR = 6,
}

impl ::protobuf::ProtobufEnum for NodePool_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NodePool_Status> {
        match value {
            0 => ::std::option::Option::Some(NodePool_Status::STATUS_UNSPECIFIED),
            1 => ::std::option::Option::Some(NodePool_Status::PROVISIONING),
            2 => ::std::option::Option::Some(NodePool_Status::RUNNING),
            3 => ::std::option::Option::Some(NodePool_Status::RUNNING_WITH_ERROR),
            4 => ::std::option::Option::Some(NodePool_Status::RECONCILING),
            5 => ::std::option::Option::Some(NodePool_Status::STOPPING),
            6 => ::std::option::Option::Some(NodePool_Status::ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [NodePool_Status] = &[
            NodePool_Status::STATUS_UNSPECIFIED,
            NodePool_Status::PROVISIONING,
            NodePool_Status::RUNNING,
            NodePool_Status::RUNNING_WITH_ERROR,
            NodePool_Status::RECONCILING,
            NodePool_Status::STOPPING,
            NodePool_Status::ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<NodePool_Status>("NodePool.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for NodePool_Status {
}

impl ::std::default::Default for NodePool_Status {
    fn default() -> Self {
        NodePool_Status::STATUS_UNSPECIFIED
    }
}

impl ::protobuf::reflect::ProtobufValue for NodePool_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeManagement {
    // message fields
    pub auto_upgrade: bool,
    pub auto_repair: bool,
    pub upgrade_options: ::protobuf::SingularPtrField<AutoUpgradeOptions>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeManagement {
    fn default() -> &'a NodeManagement {
        <NodeManagement as ::protobuf::Message>::default_instance()
    }
}

impl NodeManagement {
    pub fn new() -> NodeManagement {
        ::std::default::Default::default()
    }

    // bool auto_upgrade = 1;


    pub fn get_auto_upgrade(&self) -> bool {
        self.auto_upgrade
    }
    pub fn clear_auto_upgrade(&mut self) {
        self.auto_upgrade = false;
    }

    // Param is passed by value, moved
    pub fn set_auto_upgrade(&mut self, v: bool) {
        self.auto_upgrade = v;
    }

    // bool auto_repair = 2;


    pub fn get_auto_repair(&self) -> bool {
        self.auto_repair
    }
    pub fn clear_auto_repair(&mut self) {
        self.auto_repair = false;
    }

    // Param is passed by value, moved
    pub fn set_auto_repair(&mut self, v: bool) {
        self.auto_repair = v;
    }

    // .google.container.v1.AutoUpgradeOptions upgrade_options = 10;


    pub fn get_upgrade_options(&self) -> &AutoUpgradeOptions {
        self.upgrade_options.as_ref().unwrap_or_else(|| <AutoUpgradeOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_upgrade_options(&mut self) {
        self.upgrade_options.clear();
    }

    pub fn has_upgrade_options(&self) -> bool {
        self.upgrade_options.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upgrade_options(&mut self, v: AutoUpgradeOptions) {
        self.upgrade_options = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_upgrade_options(&mut self) -> &mut AutoUpgradeOptions {
        if self.upgrade_options.is_none() {
            self.upgrade_options.set_default();
        }
        self.upgrade_options.as_mut().unwrap()
    }

    // Take field
    pub fn take_upgrade_options(&mut self) -> AutoUpgradeOptions {
        self.upgrade_options.take().unwrap_or_else(|| AutoUpgradeOptions::new())
    }
}

impl ::protobuf::Message for NodeManagement {
    fn is_initialized(&self) -> bool {
        for v in &self.upgrade_options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.auto_upgrade = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.auto_repair = tmp;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.upgrade_options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.auto_upgrade != false {
            my_size += 2;
        }
        if self.auto_repair != false {
            my_size += 2;
        }
        if let Some(ref v) = self.upgrade_options.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.auto_upgrade != false {
            os.write_bool(1, self.auto_upgrade)?;
        }
        if self.auto_repair != false {
            os.write_bool(2, self.auto_repair)?;
        }
        if let Some(ref v) = self.upgrade_options.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeManagement {
        NodeManagement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "auto_upgrade",
                |m: &NodeManagement| { &m.auto_upgrade },
                |m: &mut NodeManagement| { &mut m.auto_upgrade },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "auto_repair",
                |m: &NodeManagement| { &m.auto_repair },
                |m: &mut NodeManagement| { &mut m.auto_repair },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AutoUpgradeOptions>>(
                "upgrade_options",
                |m: &NodeManagement| { &m.upgrade_options },
                |m: &mut NodeManagement| { &mut m.upgrade_options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeManagement>(
                "NodeManagement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeManagement {
        static instance: ::protobuf::rt::LazyV2<NodeManagement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeManagement::new)
    }
}

impl ::protobuf::Clear for NodeManagement {
    fn clear(&mut self) {
        self.auto_upgrade = false;
        self.auto_repair = false;
        self.upgrade_options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeManagement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeManagement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AutoUpgradeOptions {
    // message fields
    pub auto_upgrade_start_time: ::std::string::String,
    pub description: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AutoUpgradeOptions {
    fn default() -> &'a AutoUpgradeOptions {
        <AutoUpgradeOptions as ::protobuf::Message>::default_instance()
    }
}

impl AutoUpgradeOptions {
    pub fn new() -> AutoUpgradeOptions {
        ::std::default::Default::default()
    }

    // string auto_upgrade_start_time = 1;


    pub fn get_auto_upgrade_start_time(&self) -> &str {
        &self.auto_upgrade_start_time
    }
    pub fn clear_auto_upgrade_start_time(&mut self) {
        self.auto_upgrade_start_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_auto_upgrade_start_time(&mut self, v: ::std::string::String) {
        self.auto_upgrade_start_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_auto_upgrade_start_time(&mut self) -> &mut ::std::string::String {
        &mut self.auto_upgrade_start_time
    }

    // Take field
    pub fn take_auto_upgrade_start_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.auto_upgrade_start_time, ::std::string::String::new())
    }

    // string description = 2;


    pub fn get_description(&self) -> &str {
        &self.description
    }
    pub fn clear_description(&mut self) {
        self.description.clear();
    }

    // Param is passed by value, moved
    pub fn set_description(&mut self, v: ::std::string::String) {
        self.description = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_description(&mut self) -> &mut ::std::string::String {
        &mut self.description
    }

    // Take field
    pub fn take_description(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.description, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AutoUpgradeOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.auto_upgrade_start_time)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.description)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.auto_upgrade_start_time.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.auto_upgrade_start_time);
        }
        if !self.description.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.description);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.auto_upgrade_start_time.is_empty() {
            os.write_string(1, &self.auto_upgrade_start_time)?;
        }
        if !self.description.is_empty() {
            os.write_string(2, &self.description)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AutoUpgradeOptions {
        AutoUpgradeOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "auto_upgrade_start_time",
                |m: &AutoUpgradeOptions| { &m.auto_upgrade_start_time },
                |m: &mut AutoUpgradeOptions| { &mut m.auto_upgrade_start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "description",
                |m: &AutoUpgradeOptions| { &m.description },
                |m: &mut AutoUpgradeOptions| { &mut m.description },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AutoUpgradeOptions>(
                "AutoUpgradeOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AutoUpgradeOptions {
        static instance: ::protobuf::rt::LazyV2<AutoUpgradeOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AutoUpgradeOptions::new)
    }
}

impl ::protobuf::Clear for AutoUpgradeOptions {
    fn clear(&mut self) {
        self.auto_upgrade_start_time.clear();
        self.description.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AutoUpgradeOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AutoUpgradeOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MaintenancePolicy {
    // message fields
    pub window: ::protobuf::SingularPtrField<MaintenanceWindow>,
    pub resource_version: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MaintenancePolicy {
    fn default() -> &'a MaintenancePolicy {
        <MaintenancePolicy as ::protobuf::Message>::default_instance()
    }
}

impl MaintenancePolicy {
    pub fn new() -> MaintenancePolicy {
        ::std::default::Default::default()
    }

    // .google.container.v1.MaintenanceWindow window = 1;


    pub fn get_window(&self) -> &MaintenanceWindow {
        self.window.as_ref().unwrap_or_else(|| <MaintenanceWindow as ::protobuf::Message>::default_instance())
    }
    pub fn clear_window(&mut self) {
        self.window.clear();
    }

    pub fn has_window(&self) -> bool {
        self.window.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window(&mut self, v: MaintenanceWindow) {
        self.window = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window(&mut self) -> &mut MaintenanceWindow {
        if self.window.is_none() {
            self.window.set_default();
        }
        self.window.as_mut().unwrap()
    }

    // Take field
    pub fn take_window(&mut self) -> MaintenanceWindow {
        self.window.take().unwrap_or_else(|| MaintenanceWindow::new())
    }

    // string resource_version = 3;


    pub fn get_resource_version(&self) -> &str {
        &self.resource_version
    }
    pub fn clear_resource_version(&mut self) {
        self.resource_version.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_version(&mut self, v: ::std::string::String) {
        self.resource_version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_version(&mut self) -> &mut ::std::string::String {
        &mut self.resource_version
    }

    // Take field
    pub fn take_resource_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.resource_version, ::std::string::String::new())
    }
}

impl ::protobuf::Message for MaintenancePolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.window {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.window)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.resource_version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.window.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.resource_version.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.resource_version);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.window.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.resource_version.is_empty() {
            os.write_string(3, &self.resource_version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MaintenancePolicy {
        MaintenancePolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MaintenanceWindow>>(
                "window",
                |m: &MaintenancePolicy| { &m.window },
                |m: &mut MaintenancePolicy| { &mut m.window },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource_version",
                |m: &MaintenancePolicy| { &m.resource_version },
                |m: &mut MaintenancePolicy| { &mut m.resource_version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MaintenancePolicy>(
                "MaintenancePolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MaintenancePolicy {
        static instance: ::protobuf::rt::LazyV2<MaintenancePolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MaintenancePolicy::new)
    }
}

impl ::protobuf::Clear for MaintenancePolicy {
    fn clear(&mut self) {
        self.window.clear();
        self.resource_version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MaintenancePolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaintenancePolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MaintenanceWindow {
    // message fields
    pub maintenance_exclusions: ::std::collections::HashMap<::std::string::String, TimeWindow>,
    // message oneof groups
    pub policy: ::std::option::Option<MaintenanceWindow_oneof_policy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MaintenanceWindow {
    fn default() -> &'a MaintenanceWindow {
        <MaintenanceWindow as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone,PartialEq,Debug)]
pub enum MaintenanceWindow_oneof_policy {
    daily_maintenance_window(DailyMaintenanceWindow),
    recurring_window(RecurringTimeWindow),
}

impl MaintenanceWindow {
    pub fn new() -> MaintenanceWindow {
        ::std::default::Default::default()
    }

    // .google.container.v1.DailyMaintenanceWindow daily_maintenance_window = 2;


    pub fn get_daily_maintenance_window(&self) -> &DailyMaintenanceWindow {
        match self.policy {
            ::std::option::Option::Some(MaintenanceWindow_oneof_policy::daily_maintenance_window(ref v)) => v,
            _ => <DailyMaintenanceWindow as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_daily_maintenance_window(&mut self) {
        self.policy = ::std::option::Option::None;
    }

    pub fn has_daily_maintenance_window(&self) -> bool {
        match self.policy {
            ::std::option::Option::Some(MaintenanceWindow_oneof_policy::daily_maintenance_window(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_daily_maintenance_window(&mut self, v: DailyMaintenanceWindow) {
        self.policy = ::std::option::Option::Some(MaintenanceWindow_oneof_policy::daily_maintenance_window(v))
    }

    // Mutable pointer to the field.
    pub fn mut_daily_maintenance_window(&mut self) -> &mut DailyMaintenanceWindow {
        if let ::std::option::Option::Some(MaintenanceWindow_oneof_policy::daily_maintenance_window(_)) = self.policy {
        } else {
            self.policy = ::std::option::Option::Some(MaintenanceWindow_oneof_policy::daily_maintenance_window(DailyMaintenanceWindow::new()));
        }
        match self.policy {
            ::std::option::Option::Some(MaintenanceWindow_oneof_policy::daily_maintenance_window(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_daily_maintenance_window(&mut self) -> DailyMaintenanceWindow {
        if self.has_daily_maintenance_window() {
            match self.policy.take() {
                ::std::option::Option::Some(MaintenanceWindow_oneof_policy::daily_maintenance_window(v)) => v,
                _ => panic!(),
            }
        } else {
            DailyMaintenanceWindow::new()
        }
    }

    // .google.container.v1.RecurringTimeWindow recurring_window = 3;


    pub fn get_recurring_window(&self) -> &RecurringTimeWindow {
        match self.policy {
            ::std::option::Option::Some(MaintenanceWindow_oneof_policy::recurring_window(ref v)) => v,
            _ => <RecurringTimeWindow as ::protobuf::Message>::default_instance(),
        }
    }
    pub fn clear_recurring_window(&mut self) {
        self.policy = ::std::option::Option::None;
    }

    pub fn has_recurring_window(&self) -> bool {
        match self.policy {
            ::std::option::Option::Some(MaintenanceWindow_oneof_policy::recurring_window(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_recurring_window(&mut self, v: RecurringTimeWindow) {
        self.policy = ::std::option::Option::Some(MaintenanceWindow_oneof_policy::recurring_window(v))
    }

    // Mutable pointer to the field.
    pub fn mut_recurring_window(&mut self) -> &mut RecurringTimeWindow {
        if let ::std::option::Option::Some(MaintenanceWindow_oneof_policy::recurring_window(_)) = self.policy {
        } else {
            self.policy = ::std::option::Option::Some(MaintenanceWindow_oneof_policy::recurring_window(RecurringTimeWindow::new()));
        }
        match self.policy {
            ::std::option::Option::Some(MaintenanceWindow_oneof_policy::recurring_window(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_recurring_window(&mut self) -> RecurringTimeWindow {
        if self.has_recurring_window() {
            match self.policy.take() {
                ::std::option::Option::Some(MaintenanceWindow_oneof_policy::recurring_window(v)) => v,
                _ => panic!(),
            }
        } else {
            RecurringTimeWindow::new()
        }
    }

    // repeated .google.container.v1.MaintenanceWindow.MaintenanceExclusionsEntry maintenance_exclusions = 4;


    pub fn get_maintenance_exclusions(&self) -> &::std::collections::HashMap<::std::string::String, TimeWindow> {
        &self.maintenance_exclusions
    }
    pub fn clear_maintenance_exclusions(&mut self) {
        self.maintenance_exclusions.clear();
    }

    // Param is passed by value, moved
    pub fn set_maintenance_exclusions(&mut self, v: ::std::collections::HashMap<::std::string::String, TimeWindow>) {
        self.maintenance_exclusions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_maintenance_exclusions(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, TimeWindow> {
        &mut self.maintenance_exclusions
    }

    // Take field
    pub fn take_maintenance_exclusions(&mut self) -> ::std::collections::HashMap<::std::string::String, TimeWindow> {
        ::std::mem::replace(&mut self.maintenance_exclusions, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for MaintenanceWindow {
    fn is_initialized(&self) -> bool {
        if let Some(MaintenanceWindow_oneof_policy::daily_maintenance_window(ref v)) = self.policy {
            if !v.is_initialized() {
                return false;
            }
        }
        if let Some(MaintenanceWindow_oneof_policy::recurring_window(ref v)) = self.policy {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy = ::std::option::Option::Some(MaintenanceWindow_oneof_policy::daily_maintenance_window(is.read_message()?));
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.policy = ::std::option::Option::Some(MaintenanceWindow_oneof_policy::recurring_window(is.read_message()?));
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TimeWindow>>(wire_type, is, &mut self.maintenance_exclusions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TimeWindow>>(4, &self.maintenance_exclusions);
        if let ::std::option::Option::Some(ref v) = self.policy {
            match v {
                &MaintenanceWindow_oneof_policy::daily_maintenance_window(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
                &MaintenanceWindow_oneof_policy::recurring_window(ref v) => {
                    let len = v.compute_size();
                    my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
                },
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TimeWindow>>(4, &self.maintenance_exclusions, os)?;
        if let ::std::option::Option::Some(ref v) = self.policy {
            match v {
                &MaintenanceWindow_oneof_policy::daily_maintenance_window(ref v) => {
                    os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
                &MaintenanceWindow_oneof_policy::recurring_window(ref v) => {
                    os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
                    os.write_raw_varint32(v.get_cached_size())?;
                    v.write_to_with_cached_sizes(os)?;
                },
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MaintenanceWindow {
        MaintenanceWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, DailyMaintenanceWindow>(
                "daily_maintenance_window",
                MaintenanceWindow::has_daily_maintenance_window,
                MaintenanceWindow::get_daily_maintenance_window,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_message_accessor::<_, RecurringTimeWindow>(
                "recurring_window",
                MaintenanceWindow::has_recurring_window,
                MaintenanceWindow::get_recurring_window,
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<TimeWindow>>(
                "maintenance_exclusions",
                |m: &MaintenanceWindow| { &m.maintenance_exclusions },
                |m: &mut MaintenanceWindow| { &mut m.maintenance_exclusions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MaintenanceWindow>(
                "MaintenanceWindow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MaintenanceWindow {
        static instance: ::protobuf::rt::LazyV2<MaintenanceWindow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MaintenanceWindow::new)
    }
}

impl ::protobuf::Clear for MaintenanceWindow {
    fn clear(&mut self) {
        self.policy = ::std::option::Option::None;
        self.policy = ::std::option::Option::None;
        self.maintenance_exclusions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MaintenanceWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaintenanceWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TimeWindow {
    // message fields
    pub start_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    pub end_time: ::protobuf::SingularPtrField<::protobuf::well_known_types::Timestamp>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TimeWindow {
    fn default() -> &'a TimeWindow {
        <TimeWindow as ::protobuf::Message>::default_instance()
    }
}

impl TimeWindow {
    pub fn new() -> TimeWindow {
        ::std::default::Default::default()
    }

    // .google.protobuf.Timestamp start_time = 1;


    pub fn get_start_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.start_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    pub fn has_start_time(&self) -> bool {
        self.start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.start_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.start_time.is_none() {
            self.start_time.set_default();
        }
        self.start_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.start_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }

    // .google.protobuf.Timestamp end_time = 2;


    pub fn get_end_time(&self) -> &::protobuf::well_known_types::Timestamp {
        self.end_time.as_ref().unwrap_or_else(|| <::protobuf::well_known_types::Timestamp as ::protobuf::Message>::default_instance())
    }
    pub fn clear_end_time(&mut self) {
        self.end_time.clear();
    }

    pub fn has_end_time(&self) -> bool {
        self.end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_end_time(&mut self, v: ::protobuf::well_known_types::Timestamp) {
        self.end_time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_end_time(&mut self) -> &mut ::protobuf::well_known_types::Timestamp {
        if self.end_time.is_none() {
            self.end_time.set_default();
        }
        self.end_time.as_mut().unwrap()
    }

    // Take field
    pub fn take_end_time(&mut self) -> ::protobuf::well_known_types::Timestamp {
        self.end_time.take().unwrap_or_else(|| ::protobuf::well_known_types::Timestamp::new())
    }
}

impl ::protobuf::Message for TimeWindow {
    fn is_initialized(&self) -> bool {
        for v in &self.start_time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.end_time {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.start_time)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.end_time)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.start_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.start_time.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.end_time.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TimeWindow {
        TimeWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "start_time",
                |m: &TimeWindow| { &m.start_time },
                |m: &mut TimeWindow| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<::protobuf::well_known_types::Timestamp>>(
                "end_time",
                |m: &TimeWindow| { &m.end_time },
                |m: &mut TimeWindow| { &mut m.end_time },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TimeWindow>(
                "TimeWindow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TimeWindow {
        static instance: ::protobuf::rt::LazyV2<TimeWindow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TimeWindow::new)
    }
}

impl ::protobuf::Clear for TimeWindow {
    fn clear(&mut self) {
        self.start_time.clear();
        self.end_time.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TimeWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RecurringTimeWindow {
    // message fields
    pub window: ::protobuf::SingularPtrField<TimeWindow>,
    pub recurrence: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RecurringTimeWindow {
    fn default() -> &'a RecurringTimeWindow {
        <RecurringTimeWindow as ::protobuf::Message>::default_instance()
    }
}

impl RecurringTimeWindow {
    pub fn new() -> RecurringTimeWindow {
        ::std::default::Default::default()
    }

    // .google.container.v1.TimeWindow window = 1;


    pub fn get_window(&self) -> &TimeWindow {
        self.window.as_ref().unwrap_or_else(|| <TimeWindow as ::protobuf::Message>::default_instance())
    }
    pub fn clear_window(&mut self) {
        self.window.clear();
    }

    pub fn has_window(&self) -> bool {
        self.window.is_some()
    }

    // Param is passed by value, moved
    pub fn set_window(&mut self, v: TimeWindow) {
        self.window = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_window(&mut self) -> &mut TimeWindow {
        if self.window.is_none() {
            self.window.set_default();
        }
        self.window.as_mut().unwrap()
    }

    // Take field
    pub fn take_window(&mut self) -> TimeWindow {
        self.window.take().unwrap_or_else(|| TimeWindow::new())
    }

    // string recurrence = 2;


    pub fn get_recurrence(&self) -> &str {
        &self.recurrence
    }
    pub fn clear_recurrence(&mut self) {
        self.recurrence.clear();
    }

    // Param is passed by value, moved
    pub fn set_recurrence(&mut self, v: ::std::string::String) {
        self.recurrence = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_recurrence(&mut self) -> &mut ::std::string::String {
        &mut self.recurrence
    }

    // Take field
    pub fn take_recurrence(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.recurrence, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RecurringTimeWindow {
    fn is_initialized(&self) -> bool {
        for v in &self.window {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.window)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.recurrence)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.window.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.recurrence.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.recurrence);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.window.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.recurrence.is_empty() {
            os.write_string(2, &self.recurrence)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RecurringTimeWindow {
        RecurringTimeWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TimeWindow>>(
                "window",
                |m: &RecurringTimeWindow| { &m.window },
                |m: &mut RecurringTimeWindow| { &mut m.window },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "recurrence",
                |m: &RecurringTimeWindow| { &m.recurrence },
                |m: &mut RecurringTimeWindow| { &mut m.recurrence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RecurringTimeWindow>(
                "RecurringTimeWindow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RecurringTimeWindow {
        static instance: ::protobuf::rt::LazyV2<RecurringTimeWindow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RecurringTimeWindow::new)
    }
}

impl ::protobuf::Clear for RecurringTimeWindow {
    fn clear(&mut self) {
        self.window.clear();
        self.recurrence.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RecurringTimeWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RecurringTimeWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DailyMaintenanceWindow {
    // message fields
    pub start_time: ::std::string::String,
    pub duration: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DailyMaintenanceWindow {
    fn default() -> &'a DailyMaintenanceWindow {
        <DailyMaintenanceWindow as ::protobuf::Message>::default_instance()
    }
}

impl DailyMaintenanceWindow {
    pub fn new() -> DailyMaintenanceWindow {
        ::std::default::Default::default()
    }

    // string start_time = 2;


    pub fn get_start_time(&self) -> &str {
        &self.start_time
    }
    pub fn clear_start_time(&mut self) {
        self.start_time.clear();
    }

    // Param is passed by value, moved
    pub fn set_start_time(&mut self, v: ::std::string::String) {
        self.start_time = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_start_time(&mut self) -> &mut ::std::string::String {
        &mut self.start_time
    }

    // Take field
    pub fn take_start_time(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.start_time, ::std::string::String::new())
    }

    // string duration = 3;


    pub fn get_duration(&self) -> &str {
        &self.duration
    }
    pub fn clear_duration(&mut self) {
        self.duration.clear();
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: ::std::string::String) {
        self.duration = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_duration(&mut self) -> &mut ::std::string::String {
        &mut self.duration
    }

    // Take field
    pub fn take_duration(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.duration, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DailyMaintenanceWindow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.start_time)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.duration)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.start_time.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.start_time);
        }
        if !self.duration.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.duration);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.start_time.is_empty() {
            os.write_string(2, &self.start_time)?;
        }
        if !self.duration.is_empty() {
            os.write_string(3, &self.duration)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DailyMaintenanceWindow {
        DailyMaintenanceWindow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "start_time",
                |m: &DailyMaintenanceWindow| { &m.start_time },
                |m: &mut DailyMaintenanceWindow| { &mut m.start_time },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "duration",
                |m: &DailyMaintenanceWindow| { &m.duration },
                |m: &mut DailyMaintenanceWindow| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DailyMaintenanceWindow>(
                "DailyMaintenanceWindow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DailyMaintenanceWindow {
        static instance: ::protobuf::rt::LazyV2<DailyMaintenanceWindow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DailyMaintenanceWindow::new)
    }
}

impl ::protobuf::Clear for DailyMaintenanceWindow {
    fn clear(&mut self) {
        self.start_time.clear();
        self.duration.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DailyMaintenanceWindow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DailyMaintenanceWindow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetNodePoolManagementRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub node_pool_id: ::std::string::String,
    pub management: ::protobuf::SingularPtrField<NodeManagement>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetNodePoolManagementRequest {
    fn default() -> &'a SetNodePoolManagementRequest {
        <SetNodePoolManagementRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetNodePoolManagementRequest {
    pub fn new() -> SetNodePoolManagementRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string node_pool_id = 4;


    pub fn get_node_pool_id(&self) -> &str {
        &self.node_pool_id
    }
    pub fn clear_node_pool_id(&mut self) {
        self.node_pool_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pool_id(&mut self, v: ::std::string::String) {
        self.node_pool_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pool_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_pool_id
    }

    // Take field
    pub fn take_node_pool_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pool_id, ::std::string::String::new())
    }

    // .google.container.v1.NodeManagement management = 5;


    pub fn get_management(&self) -> &NodeManagement {
        self.management.as_ref().unwrap_or_else(|| <NodeManagement as ::protobuf::Message>::default_instance())
    }
    pub fn clear_management(&mut self) {
        self.management.clear();
    }

    pub fn has_management(&self) -> bool {
        self.management.is_some()
    }

    // Param is passed by value, moved
    pub fn set_management(&mut self, v: NodeManagement) {
        self.management = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_management(&mut self) -> &mut NodeManagement {
        if self.management.is_none() {
            self.management.set_default();
        }
        self.management.as_mut().unwrap()
    }

    // Take field
    pub fn take_management(&mut self) -> NodeManagement {
        self.management.take().unwrap_or_else(|| NodeManagement::new())
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetNodePoolManagementRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.management {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pool_id)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.management)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.node_pool_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node_pool_id);
        }
        if let Some(ref v) = self.management.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            os.write_string(4, &self.node_pool_id)?;
        }
        if let Some(ref v) = self.management.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetNodePoolManagementRequest {
        SetNodePoolManagementRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetNodePoolManagementRequest| { &m.project_id },
                |m: &mut SetNodePoolManagementRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetNodePoolManagementRequest| { &m.zone },
                |m: &mut SetNodePoolManagementRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetNodePoolManagementRequest| { &m.cluster_id },
                |m: &mut SetNodePoolManagementRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_pool_id",
                |m: &SetNodePoolManagementRequest| { &m.node_pool_id },
                |m: &mut SetNodePoolManagementRequest| { &mut m.node_pool_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeManagement>>(
                "management",
                |m: &SetNodePoolManagementRequest| { &m.management },
                |m: &mut SetNodePoolManagementRequest| { &mut m.management },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetNodePoolManagementRequest| { &m.name },
                |m: &mut SetNodePoolManagementRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetNodePoolManagementRequest>(
                "SetNodePoolManagementRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetNodePoolManagementRequest {
        static instance: ::protobuf::rt::LazyV2<SetNodePoolManagementRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetNodePoolManagementRequest::new)
    }
}

impl ::protobuf::Clear for SetNodePoolManagementRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.node_pool_id.clear();
        self.management.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetNodePoolManagementRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetNodePoolManagementRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetNodePoolSizeRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub node_pool_id: ::std::string::String,
    pub node_count: i32,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetNodePoolSizeRequest {
    fn default() -> &'a SetNodePoolSizeRequest {
        <SetNodePoolSizeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetNodePoolSizeRequest {
    pub fn new() -> SetNodePoolSizeRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string node_pool_id = 4;


    pub fn get_node_pool_id(&self) -> &str {
        &self.node_pool_id
    }
    pub fn clear_node_pool_id(&mut self) {
        self.node_pool_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pool_id(&mut self, v: ::std::string::String) {
        self.node_pool_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pool_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_pool_id
    }

    // Take field
    pub fn take_node_pool_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pool_id, ::std::string::String::new())
    }

    // int32 node_count = 5;


    pub fn get_node_count(&self) -> i32 {
        self.node_count
    }
    pub fn clear_node_count(&mut self) {
        self.node_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_node_count(&mut self, v: i32) {
        self.node_count = v;
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetNodePoolSizeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pool_id)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.node_count = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.node_pool_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node_pool_id);
        }
        if self.node_count != 0 {
            my_size += ::protobuf::rt::value_size(5, self.node_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            os.write_string(4, &self.node_pool_id)?;
        }
        if self.node_count != 0 {
            os.write_int32(5, self.node_count)?;
        }
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetNodePoolSizeRequest {
        SetNodePoolSizeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetNodePoolSizeRequest| { &m.project_id },
                |m: &mut SetNodePoolSizeRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetNodePoolSizeRequest| { &m.zone },
                |m: &mut SetNodePoolSizeRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetNodePoolSizeRequest| { &m.cluster_id },
                |m: &mut SetNodePoolSizeRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_pool_id",
                |m: &SetNodePoolSizeRequest| { &m.node_pool_id },
                |m: &mut SetNodePoolSizeRequest| { &mut m.node_pool_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "node_count",
                |m: &SetNodePoolSizeRequest| { &m.node_count },
                |m: &mut SetNodePoolSizeRequest| { &mut m.node_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetNodePoolSizeRequest| { &m.name },
                |m: &mut SetNodePoolSizeRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetNodePoolSizeRequest>(
                "SetNodePoolSizeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetNodePoolSizeRequest {
        static instance: ::protobuf::rt::LazyV2<SetNodePoolSizeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetNodePoolSizeRequest::new)
    }
}

impl ::protobuf::Clear for SetNodePoolSizeRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.node_pool_id.clear();
        self.node_count = 0;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetNodePoolSizeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetNodePoolSizeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RollbackNodePoolUpgradeRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub node_pool_id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RollbackNodePoolUpgradeRequest {
    fn default() -> &'a RollbackNodePoolUpgradeRequest {
        <RollbackNodePoolUpgradeRequest as ::protobuf::Message>::default_instance()
    }
}

impl RollbackNodePoolUpgradeRequest {
    pub fn new() -> RollbackNodePoolUpgradeRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string node_pool_id = 4;


    pub fn get_node_pool_id(&self) -> &str {
        &self.node_pool_id
    }
    pub fn clear_node_pool_id(&mut self) {
        self.node_pool_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pool_id(&mut self, v: ::std::string::String) {
        self.node_pool_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_node_pool_id(&mut self) -> &mut ::std::string::String {
        &mut self.node_pool_id
    }

    // Take field
    pub fn take_node_pool_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.node_pool_id, ::std::string::String::new())
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RollbackNodePoolUpgradeRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.node_pool_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.node_pool_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.node_pool_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.node_pool_id.is_empty() {
            os.write_string(4, &self.node_pool_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RollbackNodePoolUpgradeRequest {
        RollbackNodePoolUpgradeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &RollbackNodePoolUpgradeRequest| { &m.project_id },
                |m: &mut RollbackNodePoolUpgradeRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &RollbackNodePoolUpgradeRequest| { &m.zone },
                |m: &mut RollbackNodePoolUpgradeRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &RollbackNodePoolUpgradeRequest| { &m.cluster_id },
                |m: &mut RollbackNodePoolUpgradeRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "node_pool_id",
                |m: &RollbackNodePoolUpgradeRequest| { &m.node_pool_id },
                |m: &mut RollbackNodePoolUpgradeRequest| { &mut m.node_pool_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &RollbackNodePoolUpgradeRequest| { &m.name },
                |m: &mut RollbackNodePoolUpgradeRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RollbackNodePoolUpgradeRequest>(
                "RollbackNodePoolUpgradeRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RollbackNodePoolUpgradeRequest {
        static instance: ::protobuf::rt::LazyV2<RollbackNodePoolUpgradeRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RollbackNodePoolUpgradeRequest::new)
    }
}

impl ::protobuf::Clear for RollbackNodePoolUpgradeRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.node_pool_id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RollbackNodePoolUpgradeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RollbackNodePoolUpgradeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListNodePoolsResponse {
    // message fields
    pub node_pools: ::protobuf::RepeatedField<NodePool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListNodePoolsResponse {
    fn default() -> &'a ListNodePoolsResponse {
        <ListNodePoolsResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListNodePoolsResponse {
    pub fn new() -> ListNodePoolsResponse {
        ::std::default::Default::default()
    }

    // repeated .google.container.v1.NodePool node_pools = 1;


    pub fn get_node_pools(&self) -> &[NodePool] {
        &self.node_pools
    }
    pub fn clear_node_pools(&mut self) {
        self.node_pools.clear();
    }

    // Param is passed by value, moved
    pub fn set_node_pools(&mut self, v: ::protobuf::RepeatedField<NodePool>) {
        self.node_pools = v;
    }

    // Mutable pointer to the field.
    pub fn mut_node_pools(&mut self) -> &mut ::protobuf::RepeatedField<NodePool> {
        &mut self.node_pools
    }

    // Take field
    pub fn take_node_pools(&mut self) -> ::protobuf::RepeatedField<NodePool> {
        ::std::mem::replace(&mut self.node_pools, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ListNodePoolsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.node_pools {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.node_pools)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.node_pools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.node_pools {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListNodePoolsResponse {
        ListNodePoolsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodePool>>(
                "node_pools",
                |m: &ListNodePoolsResponse| { &m.node_pools },
                |m: &mut ListNodePoolsResponse| { &mut m.node_pools },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListNodePoolsResponse>(
                "ListNodePoolsResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListNodePoolsResponse {
        static instance: ::protobuf::rt::LazyV2<ListNodePoolsResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListNodePoolsResponse::new)
    }
}

impl ::protobuf::Clear for ListNodePoolsResponse {
    fn clear(&mut self) {
        self.node_pools.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListNodePoolsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListNodePoolsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClusterAutoscaling {
    // message fields
    pub enable_node_autoprovisioning: bool,
    pub resource_limits: ::protobuf::RepeatedField<ResourceLimit>,
    pub autoprovisioning_node_pool_defaults: ::protobuf::SingularPtrField<AutoprovisioningNodePoolDefaults>,
    pub autoprovisioning_locations: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClusterAutoscaling {
    fn default() -> &'a ClusterAutoscaling {
        <ClusterAutoscaling as ::protobuf::Message>::default_instance()
    }
}

impl ClusterAutoscaling {
    pub fn new() -> ClusterAutoscaling {
        ::std::default::Default::default()
    }

    // bool enable_node_autoprovisioning = 1;


    pub fn get_enable_node_autoprovisioning(&self) -> bool {
        self.enable_node_autoprovisioning
    }
    pub fn clear_enable_node_autoprovisioning(&mut self) {
        self.enable_node_autoprovisioning = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_node_autoprovisioning(&mut self, v: bool) {
        self.enable_node_autoprovisioning = v;
    }

    // repeated .google.container.v1.ResourceLimit resource_limits = 2;


    pub fn get_resource_limits(&self) -> &[ResourceLimit] {
        &self.resource_limits
    }
    pub fn clear_resource_limits(&mut self) {
        self.resource_limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_limits(&mut self, v: ::protobuf::RepeatedField<ResourceLimit>) {
        self.resource_limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_limits(&mut self) -> &mut ::protobuf::RepeatedField<ResourceLimit> {
        &mut self.resource_limits
    }

    // Take field
    pub fn take_resource_limits(&mut self) -> ::protobuf::RepeatedField<ResourceLimit> {
        ::std::mem::replace(&mut self.resource_limits, ::protobuf::RepeatedField::new())
    }

    // .google.container.v1.AutoprovisioningNodePoolDefaults autoprovisioning_node_pool_defaults = 4;


    pub fn get_autoprovisioning_node_pool_defaults(&self) -> &AutoprovisioningNodePoolDefaults {
        self.autoprovisioning_node_pool_defaults.as_ref().unwrap_or_else(|| <AutoprovisioningNodePoolDefaults as ::protobuf::Message>::default_instance())
    }
    pub fn clear_autoprovisioning_node_pool_defaults(&mut self) {
        self.autoprovisioning_node_pool_defaults.clear();
    }

    pub fn has_autoprovisioning_node_pool_defaults(&self) -> bool {
        self.autoprovisioning_node_pool_defaults.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autoprovisioning_node_pool_defaults(&mut self, v: AutoprovisioningNodePoolDefaults) {
        self.autoprovisioning_node_pool_defaults = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_autoprovisioning_node_pool_defaults(&mut self) -> &mut AutoprovisioningNodePoolDefaults {
        if self.autoprovisioning_node_pool_defaults.is_none() {
            self.autoprovisioning_node_pool_defaults.set_default();
        }
        self.autoprovisioning_node_pool_defaults.as_mut().unwrap()
    }

    // Take field
    pub fn take_autoprovisioning_node_pool_defaults(&mut self) -> AutoprovisioningNodePoolDefaults {
        self.autoprovisioning_node_pool_defaults.take().unwrap_or_else(|| AutoprovisioningNodePoolDefaults::new())
    }

    // repeated string autoprovisioning_locations = 5;


    pub fn get_autoprovisioning_locations(&self) -> &[::std::string::String] {
        &self.autoprovisioning_locations
    }
    pub fn clear_autoprovisioning_locations(&mut self) {
        self.autoprovisioning_locations.clear();
    }

    // Param is passed by value, moved
    pub fn set_autoprovisioning_locations(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.autoprovisioning_locations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_autoprovisioning_locations(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.autoprovisioning_locations
    }

    // Take field
    pub fn take_autoprovisioning_locations(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.autoprovisioning_locations, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ClusterAutoscaling {
    fn is_initialized(&self) -> bool {
        for v in &self.resource_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.autoprovisioning_node_pool_defaults {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_node_autoprovisioning = tmp;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resource_limits)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.autoprovisioning_node_pool_defaults)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.autoprovisioning_locations)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enable_node_autoprovisioning != false {
            my_size += 2;
        }
        for value in &self.resource_limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.autoprovisioning_node_pool_defaults.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.autoprovisioning_locations {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enable_node_autoprovisioning != false {
            os.write_bool(1, self.enable_node_autoprovisioning)?;
        }
        for v in &self.resource_limits {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.autoprovisioning_node_pool_defaults.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.autoprovisioning_locations {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClusterAutoscaling {
        ClusterAutoscaling::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_node_autoprovisioning",
                |m: &ClusterAutoscaling| { &m.enable_node_autoprovisioning },
                |m: &mut ClusterAutoscaling| { &mut m.enable_node_autoprovisioning },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceLimit>>(
                "resource_limits",
                |m: &ClusterAutoscaling| { &m.resource_limits },
                |m: &mut ClusterAutoscaling| { &mut m.resource_limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AutoprovisioningNodePoolDefaults>>(
                "autoprovisioning_node_pool_defaults",
                |m: &ClusterAutoscaling| { &m.autoprovisioning_node_pool_defaults },
                |m: &mut ClusterAutoscaling| { &mut m.autoprovisioning_node_pool_defaults },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "autoprovisioning_locations",
                |m: &ClusterAutoscaling| { &m.autoprovisioning_locations },
                |m: &mut ClusterAutoscaling| { &mut m.autoprovisioning_locations },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClusterAutoscaling>(
                "ClusterAutoscaling",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClusterAutoscaling {
        static instance: ::protobuf::rt::LazyV2<ClusterAutoscaling> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClusterAutoscaling::new)
    }
}

impl ::protobuf::Clear for ClusterAutoscaling {
    fn clear(&mut self) {
        self.enable_node_autoprovisioning = false;
        self.resource_limits.clear();
        self.autoprovisioning_node_pool_defaults.clear();
        self.autoprovisioning_locations.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClusterAutoscaling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClusterAutoscaling {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AutoprovisioningNodePoolDefaults {
    // message fields
    pub oauth_scopes: ::protobuf::RepeatedField<::std::string::String>,
    pub service_account: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AutoprovisioningNodePoolDefaults {
    fn default() -> &'a AutoprovisioningNodePoolDefaults {
        <AutoprovisioningNodePoolDefaults as ::protobuf::Message>::default_instance()
    }
}

impl AutoprovisioningNodePoolDefaults {
    pub fn new() -> AutoprovisioningNodePoolDefaults {
        ::std::default::Default::default()
    }

    // repeated string oauth_scopes = 1;


    pub fn get_oauth_scopes(&self) -> &[::std::string::String] {
        &self.oauth_scopes
    }
    pub fn clear_oauth_scopes(&mut self) {
        self.oauth_scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_oauth_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.oauth_scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_oauth_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.oauth_scopes
    }

    // Take field
    pub fn take_oauth_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.oauth_scopes, ::protobuf::RepeatedField::new())
    }

    // string service_account = 2;


    pub fn get_service_account(&self) -> &str {
        &self.service_account
    }
    pub fn clear_service_account(&mut self) {
        self.service_account.clear();
    }

    // Param is passed by value, moved
    pub fn set_service_account(&mut self, v: ::std::string::String) {
        self.service_account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service_account(&mut self) -> &mut ::std::string::String {
        &mut self.service_account
    }

    // Take field
    pub fn take_service_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.service_account, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AutoprovisioningNodePoolDefaults {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.oauth_scopes)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.service_account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.oauth_scopes {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if !self.service_account.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.service_account);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.oauth_scopes {
            os.write_string(1, &v)?;
        };
        if !self.service_account.is_empty() {
            os.write_string(2, &self.service_account)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AutoprovisioningNodePoolDefaults {
        AutoprovisioningNodePoolDefaults::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "oauth_scopes",
                |m: &AutoprovisioningNodePoolDefaults| { &m.oauth_scopes },
                |m: &mut AutoprovisioningNodePoolDefaults| { &mut m.oauth_scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "service_account",
                |m: &AutoprovisioningNodePoolDefaults| { &m.service_account },
                |m: &mut AutoprovisioningNodePoolDefaults| { &mut m.service_account },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AutoprovisioningNodePoolDefaults>(
                "AutoprovisioningNodePoolDefaults",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AutoprovisioningNodePoolDefaults {
        static instance: ::protobuf::rt::LazyV2<AutoprovisioningNodePoolDefaults> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AutoprovisioningNodePoolDefaults::new)
    }
}

impl ::protobuf::Clear for AutoprovisioningNodePoolDefaults {
    fn clear(&mut self) {
        self.oauth_scopes.clear();
        self.service_account.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AutoprovisioningNodePoolDefaults {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AutoprovisioningNodePoolDefaults {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceLimit {
    // message fields
    pub resource_type: ::std::string::String,
    pub minimum: i64,
    pub maximum: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceLimit {
    fn default() -> &'a ResourceLimit {
        <ResourceLimit as ::protobuf::Message>::default_instance()
    }
}

impl ResourceLimit {
    pub fn new() -> ResourceLimit {
        ::std::default::Default::default()
    }

    // string resource_type = 1;


    pub fn get_resource_type(&self) -> &str {
        &self.resource_type
    }
    pub fn clear_resource_type(&mut self) {
        self.resource_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_type(&mut self, v: ::std::string::String) {
        self.resource_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource_type(&mut self) -> &mut ::std::string::String {
        &mut self.resource_type
    }

    // Take field
    pub fn take_resource_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.resource_type, ::std::string::String::new())
    }

    // int64 minimum = 2;


    pub fn get_minimum(&self) -> i64 {
        self.minimum
    }
    pub fn clear_minimum(&mut self) {
        self.minimum = 0;
    }

    // Param is passed by value, moved
    pub fn set_minimum(&mut self, v: i64) {
        self.minimum = v;
    }

    // int64 maximum = 3;


    pub fn get_maximum(&self) -> i64 {
        self.maximum
    }
    pub fn clear_maximum(&mut self) {
        self.maximum = 0;
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i64) {
        self.maximum = v;
    }
}

impl ::protobuf::Message for ResourceLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.resource_type)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.minimum = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maximum = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.resource_type.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.resource_type);
        }
        if self.minimum != 0 {
            my_size += ::protobuf::rt::value_size(2, self.minimum, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.maximum != 0 {
            my_size += ::protobuf::rt::value_size(3, self.maximum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.resource_type.is_empty() {
            os.write_string(1, &self.resource_type)?;
        }
        if self.minimum != 0 {
            os.write_int64(2, self.minimum)?;
        }
        if self.maximum != 0 {
            os.write_int64(3, self.maximum)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceLimit {
        ResourceLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource_type",
                |m: &ResourceLimit| { &m.resource_type },
                |m: &mut ResourceLimit| { &mut m.resource_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "minimum",
                |m: &ResourceLimit| { &m.minimum },
                |m: &mut ResourceLimit| { &mut m.minimum },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "maximum",
                |m: &ResourceLimit| { &m.maximum },
                |m: &mut ResourceLimit| { &mut m.maximum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceLimit>(
                "ResourceLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceLimit {
        static instance: ::protobuf::rt::LazyV2<ResourceLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceLimit::new)
    }
}

impl ::protobuf::Clear for ResourceLimit {
    fn clear(&mut self) {
        self.resource_type.clear();
        self.minimum = 0;
        self.maximum = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodePoolAutoscaling {
    // message fields
    pub enabled: bool,
    pub min_node_count: i32,
    pub max_node_count: i32,
    pub autoprovisioned: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodePoolAutoscaling {
    fn default() -> &'a NodePoolAutoscaling {
        <NodePoolAutoscaling as ::protobuf::Message>::default_instance()
    }
}

impl NodePoolAutoscaling {
    pub fn new() -> NodePoolAutoscaling {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // int32 min_node_count = 2;


    pub fn get_min_node_count(&self) -> i32 {
        self.min_node_count
    }
    pub fn clear_min_node_count(&mut self) {
        self.min_node_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_min_node_count(&mut self, v: i32) {
        self.min_node_count = v;
    }

    // int32 max_node_count = 3;


    pub fn get_max_node_count(&self) -> i32 {
        self.max_node_count
    }
    pub fn clear_max_node_count(&mut self) {
        self.max_node_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_node_count(&mut self, v: i32) {
        self.max_node_count = v;
    }

    // bool autoprovisioned = 4;


    pub fn get_autoprovisioned(&self) -> bool {
        self.autoprovisioned
    }
    pub fn clear_autoprovisioned(&mut self) {
        self.autoprovisioned = false;
    }

    // Param is passed by value, moved
    pub fn set_autoprovisioned(&mut self, v: bool) {
        self.autoprovisioned = v;
    }
}

impl ::protobuf::Message for NodePoolAutoscaling {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.min_node_count = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.max_node_count = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autoprovisioned = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        if self.min_node_count != 0 {
            my_size += ::protobuf::rt::value_size(2, self.min_node_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_node_count != 0 {
            my_size += ::protobuf::rt::value_size(3, self.max_node_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.autoprovisioned != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        if self.min_node_count != 0 {
            os.write_int32(2, self.min_node_count)?;
        }
        if self.max_node_count != 0 {
            os.write_int32(3, self.max_node_count)?;
        }
        if self.autoprovisioned != false {
            os.write_bool(4, self.autoprovisioned)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodePoolAutoscaling {
        NodePoolAutoscaling::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &NodePoolAutoscaling| { &m.enabled },
                |m: &mut NodePoolAutoscaling| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "min_node_count",
                |m: &NodePoolAutoscaling| { &m.min_node_count },
                |m: &mut NodePoolAutoscaling| { &mut m.min_node_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "max_node_count",
                |m: &NodePoolAutoscaling| { &m.max_node_count },
                |m: &mut NodePoolAutoscaling| { &mut m.max_node_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "autoprovisioned",
                |m: &NodePoolAutoscaling| { &m.autoprovisioned },
                |m: &mut NodePoolAutoscaling| { &mut m.autoprovisioned },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodePoolAutoscaling>(
                "NodePoolAutoscaling",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodePoolAutoscaling {
        static instance: ::protobuf::rt::LazyV2<NodePoolAutoscaling> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodePoolAutoscaling::new)
    }
}

impl ::protobuf::Clear for NodePoolAutoscaling {
    fn clear(&mut self) {
        self.enabled = false;
        self.min_node_count = 0;
        self.max_node_count = 0;
        self.autoprovisioned = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodePoolAutoscaling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodePoolAutoscaling {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetLabelsRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub resource_labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub label_fingerprint: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetLabelsRequest {
    fn default() -> &'a SetLabelsRequest {
        <SetLabelsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetLabelsRequest {
    pub fn new() -> SetLabelsRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // repeated .google.container.v1.SetLabelsRequest.ResourceLabelsEntry resource_labels = 4;


    pub fn get_resource_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.resource_labels
    }
    pub fn clear_resource_labels(&mut self) {
        self.resource_labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.resource_labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.resource_labels
    }

    // Take field
    pub fn take_resource_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.resource_labels, ::std::collections::HashMap::new())
    }

    // string label_fingerprint = 5;


    pub fn get_label_fingerprint(&self) -> &str {
        &self.label_fingerprint
    }
    pub fn clear_label_fingerprint(&mut self) {
        self.label_fingerprint.clear();
    }

    // Param is passed by value, moved
    pub fn set_label_fingerprint(&mut self, v: ::std::string::String) {
        self.label_fingerprint = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_label_fingerprint(&mut self) -> &mut ::std::string::String {
        &mut self.label_fingerprint
    }

    // Take field
    pub fn take_label_fingerprint(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.label_fingerprint, ::std::string::String::new())
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetLabelsRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.resource_labels)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.label_fingerprint)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.resource_labels);
        if !self.label_fingerprint.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.label_fingerprint);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.resource_labels, os)?;
        if !self.label_fingerprint.is_empty() {
            os.write_string(5, &self.label_fingerprint)?;
        }
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetLabelsRequest {
        SetLabelsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetLabelsRequest| { &m.project_id },
                |m: &mut SetLabelsRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetLabelsRequest| { &m.zone },
                |m: &mut SetLabelsRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetLabelsRequest| { &m.cluster_id },
                |m: &mut SetLabelsRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "resource_labels",
                |m: &SetLabelsRequest| { &m.resource_labels },
                |m: &mut SetLabelsRequest| { &mut m.resource_labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "label_fingerprint",
                |m: &SetLabelsRequest| { &m.label_fingerprint },
                |m: &mut SetLabelsRequest| { &mut m.label_fingerprint },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetLabelsRequest| { &m.name },
                |m: &mut SetLabelsRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetLabelsRequest>(
                "SetLabelsRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetLabelsRequest {
        static instance: ::protobuf::rt::LazyV2<SetLabelsRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetLabelsRequest::new)
    }
}

impl ::protobuf::Clear for SetLabelsRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.resource_labels.clear();
        self.label_fingerprint.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetLabelsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetLabelsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetLegacyAbacRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub enabled: bool,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetLegacyAbacRequest {
    fn default() -> &'a SetLegacyAbacRequest {
        <SetLegacyAbacRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetLegacyAbacRequest {
    pub fn new() -> SetLegacyAbacRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // bool enabled = 4;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetLegacyAbacRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if self.enabled != false {
            my_size += 2;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if self.enabled != false {
            os.write_bool(4, self.enabled)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetLegacyAbacRequest {
        SetLegacyAbacRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetLegacyAbacRequest| { &m.project_id },
                |m: &mut SetLegacyAbacRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetLegacyAbacRequest| { &m.zone },
                |m: &mut SetLegacyAbacRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetLegacyAbacRequest| { &m.cluster_id },
                |m: &mut SetLegacyAbacRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &SetLegacyAbacRequest| { &m.enabled },
                |m: &mut SetLegacyAbacRequest| { &mut m.enabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetLegacyAbacRequest| { &m.name },
                |m: &mut SetLegacyAbacRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetLegacyAbacRequest>(
                "SetLegacyAbacRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetLegacyAbacRequest {
        static instance: ::protobuf::rt::LazyV2<SetLegacyAbacRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetLegacyAbacRequest::new)
    }
}

impl ::protobuf::Clear for SetLegacyAbacRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.enabled = false;
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetLegacyAbacRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetLegacyAbacRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StartIPRotationRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub name: ::std::string::String,
    pub rotate_credentials: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StartIPRotationRequest {
    fn default() -> &'a StartIPRotationRequest {
        <StartIPRotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl StartIPRotationRequest {
    pub fn new() -> StartIPRotationRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // bool rotate_credentials = 7;


    pub fn get_rotate_credentials(&self) -> bool {
        self.rotate_credentials
    }
    pub fn clear_rotate_credentials(&mut self) {
        self.rotate_credentials = false;
    }

    // Param is passed by value, moved
    pub fn set_rotate_credentials(&mut self, v: bool) {
        self.rotate_credentials = v;
    }
}

impl ::protobuf::Message for StartIPRotationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.rotate_credentials = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        if self.rotate_credentials != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        if self.rotate_credentials != false {
            os.write_bool(7, self.rotate_credentials)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StartIPRotationRequest {
        StartIPRotationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &StartIPRotationRequest| { &m.project_id },
                |m: &mut StartIPRotationRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &StartIPRotationRequest| { &m.zone },
                |m: &mut StartIPRotationRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &StartIPRotationRequest| { &m.cluster_id },
                |m: &mut StartIPRotationRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &StartIPRotationRequest| { &m.name },
                |m: &mut StartIPRotationRequest| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "rotate_credentials",
                |m: &StartIPRotationRequest| { &m.rotate_credentials },
                |m: &mut StartIPRotationRequest| { &mut m.rotate_credentials },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StartIPRotationRequest>(
                "StartIPRotationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StartIPRotationRequest {
        static instance: ::protobuf::rt::LazyV2<StartIPRotationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StartIPRotationRequest::new)
    }
}

impl ::protobuf::Clear for StartIPRotationRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.name.clear();
        self.rotate_credentials = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StartIPRotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StartIPRotationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CompleteIPRotationRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CompleteIPRotationRequest {
    fn default() -> &'a CompleteIPRotationRequest {
        <CompleteIPRotationRequest as ::protobuf::Message>::default_instance()
    }
}

impl CompleteIPRotationRequest {
    pub fn new() -> CompleteIPRotationRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // string name = 7;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for CompleteIPRotationRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(7, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CompleteIPRotationRequest {
        CompleteIPRotationRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &CompleteIPRotationRequest| { &m.project_id },
                |m: &mut CompleteIPRotationRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &CompleteIPRotationRequest| { &m.zone },
                |m: &mut CompleteIPRotationRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &CompleteIPRotationRequest| { &m.cluster_id },
                |m: &mut CompleteIPRotationRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &CompleteIPRotationRequest| { &m.name },
                |m: &mut CompleteIPRotationRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CompleteIPRotationRequest>(
                "CompleteIPRotationRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CompleteIPRotationRequest {
        static instance: ::protobuf::rt::LazyV2<CompleteIPRotationRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CompleteIPRotationRequest::new)
    }
}

impl ::protobuf::Clear for CompleteIPRotationRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CompleteIPRotationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CompleteIPRotationRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AcceleratorConfig {
    // message fields
    pub accelerator_count: i64,
    pub accelerator_type: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AcceleratorConfig {
    fn default() -> &'a AcceleratorConfig {
        <AcceleratorConfig as ::protobuf::Message>::default_instance()
    }
}

impl AcceleratorConfig {
    pub fn new() -> AcceleratorConfig {
        ::std::default::Default::default()
    }

    // int64 accelerator_count = 1;


    pub fn get_accelerator_count(&self) -> i64 {
        self.accelerator_count
    }
    pub fn clear_accelerator_count(&mut self) {
        self.accelerator_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_accelerator_count(&mut self, v: i64) {
        self.accelerator_count = v;
    }

    // string accelerator_type = 2;


    pub fn get_accelerator_type(&self) -> &str {
        &self.accelerator_type
    }
    pub fn clear_accelerator_type(&mut self) {
        self.accelerator_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_accelerator_type(&mut self, v: ::std::string::String) {
        self.accelerator_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accelerator_type(&mut self) -> &mut ::std::string::String {
        &mut self.accelerator_type
    }

    // Take field
    pub fn take_accelerator_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accelerator_type, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AcceleratorConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.accelerator_count = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accelerator_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.accelerator_count != 0 {
            my_size += ::protobuf::rt::value_size(1, self.accelerator_count, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.accelerator_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.accelerator_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.accelerator_count != 0 {
            os.write_int64(1, self.accelerator_count)?;
        }
        if !self.accelerator_type.is_empty() {
            os.write_string(2, &self.accelerator_type)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AcceleratorConfig {
        AcceleratorConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "accelerator_count",
                |m: &AcceleratorConfig| { &m.accelerator_count },
                |m: &mut AcceleratorConfig| { &mut m.accelerator_count },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accelerator_type",
                |m: &AcceleratorConfig| { &m.accelerator_type },
                |m: &mut AcceleratorConfig| { &mut m.accelerator_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AcceleratorConfig>(
                "AcceleratorConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AcceleratorConfig {
        static instance: ::protobuf::rt::LazyV2<AcceleratorConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AcceleratorConfig::new)
    }
}

impl ::protobuf::Clear for AcceleratorConfig {
    fn clear(&mut self) {
        self.accelerator_count = 0;
        self.accelerator_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AcceleratorConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AcceleratorConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetNetworkPolicyRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub network_policy: ::protobuf::SingularPtrField<NetworkPolicy>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetNetworkPolicyRequest {
    fn default() -> &'a SetNetworkPolicyRequest {
        <SetNetworkPolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetNetworkPolicyRequest {
    pub fn new() -> SetNetworkPolicyRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // .google.container.v1.NetworkPolicy network_policy = 4;


    pub fn get_network_policy(&self) -> &NetworkPolicy {
        self.network_policy.as_ref().unwrap_or_else(|| <NetworkPolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_network_policy(&mut self) {
        self.network_policy.clear();
    }

    pub fn has_network_policy(&self) -> bool {
        self.network_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_network_policy(&mut self, v: NetworkPolicy) {
        self.network_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network_policy(&mut self) -> &mut NetworkPolicy {
        if self.network_policy.is_none() {
            self.network_policy.set_default();
        }
        self.network_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_network_policy(&mut self) -> NetworkPolicy {
        self.network_policy.take().unwrap_or_else(|| NetworkPolicy::new())
    }

    // string name = 6;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetNetworkPolicyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.network_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.network_policy)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if let Some(ref v) = self.network_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if let Some(ref v) = self.network_policy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(6, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetNetworkPolicyRequest {
        SetNetworkPolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetNetworkPolicyRequest| { &m.project_id },
                |m: &mut SetNetworkPolicyRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetNetworkPolicyRequest| { &m.zone },
                |m: &mut SetNetworkPolicyRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetNetworkPolicyRequest| { &m.cluster_id },
                |m: &mut SetNetworkPolicyRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NetworkPolicy>>(
                "network_policy",
                |m: &SetNetworkPolicyRequest| { &m.network_policy },
                |m: &mut SetNetworkPolicyRequest| { &mut m.network_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetNetworkPolicyRequest| { &m.name },
                |m: &mut SetNetworkPolicyRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetNetworkPolicyRequest>(
                "SetNetworkPolicyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetNetworkPolicyRequest {
        static instance: ::protobuf::rt::LazyV2<SetNetworkPolicyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetNetworkPolicyRequest::new)
    }
}

impl ::protobuf::Clear for SetNetworkPolicyRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.network_policy.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetNetworkPolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetNetworkPolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SetMaintenancePolicyRequest {
    // message fields
    pub project_id: ::std::string::String,
    pub zone: ::std::string::String,
    pub cluster_id: ::std::string::String,
    pub maintenance_policy: ::protobuf::SingularPtrField<MaintenancePolicy>,
    pub name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SetMaintenancePolicyRequest {
    fn default() -> &'a SetMaintenancePolicyRequest {
        <SetMaintenancePolicyRequest as ::protobuf::Message>::default_instance()
    }
}

impl SetMaintenancePolicyRequest {
    pub fn new() -> SetMaintenancePolicyRequest {
        ::std::default::Default::default()
    }

    // string project_id = 1;


    pub fn get_project_id(&self) -> &str {
        &self.project_id
    }
    pub fn clear_project_id(&mut self) {
        self.project_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_project_id(&mut self, v: ::std::string::String) {
        self.project_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_project_id(&mut self) -> &mut ::std::string::String {
        &mut self.project_id
    }

    // Take field
    pub fn take_project_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.project_id, ::std::string::String::new())
    }

    // string zone = 2;


    pub fn get_zone(&self) -> &str {
        &self.zone
    }
    pub fn clear_zone(&mut self) {
        self.zone.clear();
    }

    // Param is passed by value, moved
    pub fn set_zone(&mut self, v: ::std::string::String) {
        self.zone = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_zone(&mut self) -> &mut ::std::string::String {
        &mut self.zone
    }

    // Take field
    pub fn take_zone(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.zone, ::std::string::String::new())
    }

    // string cluster_id = 3;


    pub fn get_cluster_id(&self) -> &str {
        &self.cluster_id
    }
    pub fn clear_cluster_id(&mut self) {
        self.cluster_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cluster_id(&mut self, v: ::std::string::String) {
        self.cluster_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cluster_id(&mut self) -> &mut ::std::string::String {
        &mut self.cluster_id
    }

    // Take field
    pub fn take_cluster_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cluster_id, ::std::string::String::new())
    }

    // .google.container.v1.MaintenancePolicy maintenance_policy = 4;


    pub fn get_maintenance_policy(&self) -> &MaintenancePolicy {
        self.maintenance_policy.as_ref().unwrap_or_else(|| <MaintenancePolicy as ::protobuf::Message>::default_instance())
    }
    pub fn clear_maintenance_policy(&mut self) {
        self.maintenance_policy.clear();
    }

    pub fn has_maintenance_policy(&self) -> bool {
        self.maintenance_policy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maintenance_policy(&mut self, v: MaintenancePolicy) {
        self.maintenance_policy = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_maintenance_policy(&mut self) -> &mut MaintenancePolicy {
        if self.maintenance_policy.is_none() {
            self.maintenance_policy.set_default();
        }
        self.maintenance_policy.as_mut().unwrap()
    }

    // Take field
    pub fn take_maintenance_policy(&mut self) -> MaintenancePolicy {
        self.maintenance_policy.take().unwrap_or_else(|| MaintenancePolicy::new())
    }

    // string name = 5;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for SetMaintenancePolicyRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.maintenance_policy {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.project_id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.zone)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cluster_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.maintenance_policy)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.project_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.project_id);
        }
        if !self.zone.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.zone);
        }
        if !self.cluster_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cluster_id);
        }
        if let Some(ref v) = self.maintenance_policy.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.project_id.is_empty() {
            os.write_string(1, &self.project_id)?;
        }
        if !self.zone.is_empty() {
            os.write_string(2, &self.zone)?;
        }
        if !self.cluster_id.is_empty() {
            os.write_string(3, &self.cluster_id)?;
        }
        if let Some(ref v) = self.maintenance_policy.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.name.is_empty() {
            os.write_string(5, &self.name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SetMaintenancePolicyRequest {
        SetMaintenancePolicyRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "project_id",
                |m: &SetMaintenancePolicyRequest| { &m.project_id },
                |m: &mut SetMaintenancePolicyRequest| { &mut m.project_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "zone",
                |m: &SetMaintenancePolicyRequest| { &m.zone },
                |m: &mut SetMaintenancePolicyRequest| { &mut m.zone },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cluster_id",
                |m: &SetMaintenancePolicyRequest| { &m.cluster_id },
                |m: &mut SetMaintenancePolicyRequest| { &mut m.cluster_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MaintenancePolicy>>(
                "maintenance_policy",
                |m: &SetMaintenancePolicyRequest| { &m.maintenance_policy },
                |m: &mut SetMaintenancePolicyRequest| { &mut m.maintenance_policy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SetMaintenancePolicyRequest| { &m.name },
                |m: &mut SetMaintenancePolicyRequest| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SetMaintenancePolicyRequest>(
                "SetMaintenancePolicyRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SetMaintenancePolicyRequest {
        static instance: ::protobuf::rt::LazyV2<SetMaintenancePolicyRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SetMaintenancePolicyRequest::new)
    }
}

impl ::protobuf::Clear for SetMaintenancePolicyRequest {
    fn clear(&mut self) {
        self.project_id.clear();
        self.zone.clear();
        self.cluster_id.clear();
        self.maintenance_policy.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SetMaintenancePolicyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SetMaintenancePolicyRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusCondition {
    // message fields
    pub code: StatusCondition_Code,
    pub message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusCondition {
    fn default() -> &'a StatusCondition {
        <StatusCondition as ::protobuf::Message>::default_instance()
    }
}

impl StatusCondition {
    pub fn new() -> StatusCondition {
        ::std::default::Default::default()
    }

    // .google.container.v1.StatusCondition.Code code = 1;


    pub fn get_code(&self) -> StatusCondition_Code {
        self.code
    }
    pub fn clear_code(&mut self) {
        self.code = StatusCondition_Code::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: StatusCondition_Code) {
        self.code = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for StatusCondition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.code, 1, &mut self.unknown_fields)?
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.code != StatusCondition_Code::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(1, self.code);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.code != StatusCondition_Code::UNKNOWN {
            os.write_enum(1, ::protobuf::ProtobufEnum::value(&self.code))?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusCondition {
        StatusCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<StatusCondition_Code>>(
                "code",
                |m: &StatusCondition| { &m.code },
                |m: &mut StatusCondition| { &mut m.code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &StatusCondition| { &m.message },
                |m: &mut StatusCondition| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusCondition>(
                "StatusCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusCondition {
        static instance: ::protobuf::rt::LazyV2<StatusCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusCondition::new)
    }
}

impl ::protobuf::Clear for StatusCondition {
    fn clear(&mut self) {
        self.code = StatusCondition_Code::UNKNOWN;
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum StatusCondition_Code {
    UNKNOWN = 0,
    GCE_STOCKOUT = 1,
    GKE_SERVICE_ACCOUNT_DELETED = 2,
    GCE_QUOTA_EXCEEDED = 3,
    SET_BY_OPERATOR = 4,
    CLOUD_KMS_KEY_ERROR = 7,
}

impl ::protobuf::ProtobufEnum for StatusCondition_Code {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<StatusCondition_Code> {
        match value {
            0 => ::std::option::Option::Some(StatusCondition_Code::UNKNOWN),
            1 => ::std::option::Option::Some(StatusCondition_Code::GCE_STOCKOUT),
            2 => ::std::option::Option::Some(StatusCondition_Code::GKE_SERVICE_ACCOUNT_DELETED),
            3 => ::std::option::Option::Some(StatusCondition_Code::GCE_QUOTA_EXCEEDED),
            4 => ::std::option::Option::Some(StatusCondition_Code::SET_BY_OPERATOR),
            7 => ::std::option::Option::Some(StatusCondition_Code::CLOUD_KMS_KEY_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [StatusCondition_Code] = &[
            StatusCondition_Code::UNKNOWN,
            StatusCondition_Code::GCE_STOCKOUT,
            StatusCondition_Code::GKE_SERVICE_ACCOUNT_DELETED,
            StatusCondition_Code::GCE_QUOTA_EXCEEDED,
            StatusCondition_Code::SET_BY_OPERATOR,
            StatusCondition_Code::CLOUD_KMS_KEY_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<StatusCondition_Code>("StatusCondition.Code", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for StatusCondition_Code {
}

impl ::std::default::Default for StatusCondition_Code {
    fn default() -> Self {
        StatusCondition_Code::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusCondition_Code {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NetworkConfig {
    // message fields
    pub network: ::std::string::String,
    pub subnetwork: ::std::string::String,
    pub enable_intra_node_visibility: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NetworkConfig {
    fn default() -> &'a NetworkConfig {
        <NetworkConfig as ::protobuf::Message>::default_instance()
    }
}

impl NetworkConfig {
    pub fn new() -> NetworkConfig {
        ::std::default::Default::default()
    }

    // string network = 1;


    pub fn get_network(&self) -> &str {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::std::string::String) {
        self.network = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut ::std::string::String {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.network, ::std::string::String::new())
    }

    // string subnetwork = 2;


    pub fn get_subnetwork(&self) -> &str {
        &self.subnetwork
    }
    pub fn clear_subnetwork(&mut self) {
        self.subnetwork.clear();
    }

    // Param is passed by value, moved
    pub fn set_subnetwork(&mut self, v: ::std::string::String) {
        self.subnetwork = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subnetwork(&mut self) -> &mut ::std::string::String {
        &mut self.subnetwork
    }

    // Take field
    pub fn take_subnetwork(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subnetwork, ::std::string::String::new())
    }

    // bool enable_intra_node_visibility = 5;


    pub fn get_enable_intra_node_visibility(&self) -> bool {
        self.enable_intra_node_visibility
    }
    pub fn clear_enable_intra_node_visibility(&mut self) {
        self.enable_intra_node_visibility = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_intra_node_visibility(&mut self, v: bool) {
        self.enable_intra_node_visibility = v;
    }
}

impl ::protobuf::Message for NetworkConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.network)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subnetwork)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_intra_node_visibility = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.network);
        }
        if !self.subnetwork.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.subnetwork);
        }
        if self.enable_intra_node_visibility != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.network.is_empty() {
            os.write_string(1, &self.network)?;
        }
        if !self.subnetwork.is_empty() {
            os.write_string(2, &self.subnetwork)?;
        }
        if self.enable_intra_node_visibility != false {
            os.write_bool(5, self.enable_intra_node_visibility)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NetworkConfig {
        NetworkConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "network",
                |m: &NetworkConfig| { &m.network },
                |m: &mut NetworkConfig| { &mut m.network },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subnetwork",
                |m: &NetworkConfig| { &m.subnetwork },
                |m: &mut NetworkConfig| { &mut m.subnetwork },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_intra_node_visibility",
                |m: &NetworkConfig| { &m.enable_intra_node_visibility },
                |m: &mut NetworkConfig| { &mut m.enable_intra_node_visibility },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NetworkConfig>(
                "NetworkConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NetworkConfig {
        static instance: ::protobuf::rt::LazyV2<NetworkConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NetworkConfig::new)
    }
}

impl ::protobuf::Clear for NetworkConfig {
    fn clear(&mut self) {
        self.network.clear();
        self.subnetwork.clear();
        self.enable_intra_node_visibility = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NetworkConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NetworkConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IntraNodeVisibilityConfig {
    // message fields
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IntraNodeVisibilityConfig {
    fn default() -> &'a IntraNodeVisibilityConfig {
        <IntraNodeVisibilityConfig as ::protobuf::Message>::default_instance()
    }
}

impl IntraNodeVisibilityConfig {
    pub fn new() -> IntraNodeVisibilityConfig {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for IntraNodeVisibilityConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IntraNodeVisibilityConfig {
        IntraNodeVisibilityConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &IntraNodeVisibilityConfig| { &m.enabled },
                |m: &mut IntraNodeVisibilityConfig| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IntraNodeVisibilityConfig>(
                "IntraNodeVisibilityConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IntraNodeVisibilityConfig {
        static instance: ::protobuf::rt::LazyV2<IntraNodeVisibilityConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IntraNodeVisibilityConfig::new)
    }
}

impl ::protobuf::Clear for IntraNodeVisibilityConfig {
    fn clear(&mut self) {
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IntraNodeVisibilityConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IntraNodeVisibilityConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MaxPodsConstraint {
    // message fields
    pub max_pods_per_node: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MaxPodsConstraint {
    fn default() -> &'a MaxPodsConstraint {
        <MaxPodsConstraint as ::protobuf::Message>::default_instance()
    }
}

impl MaxPodsConstraint {
    pub fn new() -> MaxPodsConstraint {
        ::std::default::Default::default()
    }

    // int64 max_pods_per_node = 1;


    pub fn get_max_pods_per_node(&self) -> i64 {
        self.max_pods_per_node
    }
    pub fn clear_max_pods_per_node(&mut self) {
        self.max_pods_per_node = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_pods_per_node(&mut self, v: i64) {
        self.max_pods_per_node = v;
    }
}

impl ::protobuf::Message for MaxPodsConstraint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_pods_per_node = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.max_pods_per_node != 0 {
            my_size += ::protobuf::rt::value_size(1, self.max_pods_per_node, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.max_pods_per_node != 0 {
            os.write_int64(1, self.max_pods_per_node)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MaxPodsConstraint {
        MaxPodsConstraint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "max_pods_per_node",
                |m: &MaxPodsConstraint| { &m.max_pods_per_node },
                |m: &mut MaxPodsConstraint| { &mut m.max_pods_per_node },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MaxPodsConstraint>(
                "MaxPodsConstraint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MaxPodsConstraint {
        static instance: ::protobuf::rt::LazyV2<MaxPodsConstraint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MaxPodsConstraint::new)
    }
}

impl ::protobuf::Clear for MaxPodsConstraint {
    fn clear(&mut self) {
        self.max_pods_per_node = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MaxPodsConstraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MaxPodsConstraint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DatabaseEncryption {
    // message fields
    pub state: DatabaseEncryption_State,
    pub key_name: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DatabaseEncryption {
    fn default() -> &'a DatabaseEncryption {
        <DatabaseEncryption as ::protobuf::Message>::default_instance()
    }
}

impl DatabaseEncryption {
    pub fn new() -> DatabaseEncryption {
        ::std::default::Default::default()
    }

    // .google.container.v1.DatabaseEncryption.State state = 2;


    pub fn get_state(&self) -> DatabaseEncryption_State {
        self.state
    }
    pub fn clear_state(&mut self) {
        self.state = DatabaseEncryption_State::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: DatabaseEncryption_State) {
        self.state = v;
    }

    // string key_name = 1;


    pub fn get_key_name(&self) -> &str {
        &self.key_name
    }
    pub fn clear_key_name(&mut self) {
        self.key_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_key_name(&mut self, v: ::std::string::String) {
        self.key_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key_name(&mut self) -> &mut ::std::string::String {
        &mut self.key_name
    }

    // Take field
    pub fn take_key_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.key_name, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DatabaseEncryption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.state, 2, &mut self.unknown_fields)?
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.key_name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.state != DatabaseEncryption_State::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(2, self.state);
        }
        if !self.key_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key_name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.state != DatabaseEncryption_State::UNKNOWN {
            os.write_enum(2, ::protobuf::ProtobufEnum::value(&self.state))?;
        }
        if !self.key_name.is_empty() {
            os.write_string(1, &self.key_name)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DatabaseEncryption {
        DatabaseEncryption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<DatabaseEncryption_State>>(
                "state",
                |m: &DatabaseEncryption| { &m.state },
                |m: &mut DatabaseEncryption| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key_name",
                |m: &DatabaseEncryption| { &m.key_name },
                |m: &mut DatabaseEncryption| { &mut m.key_name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DatabaseEncryption>(
                "DatabaseEncryption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DatabaseEncryption {
        static instance: ::protobuf::rt::LazyV2<DatabaseEncryption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DatabaseEncryption::new)
    }
}

impl ::protobuf::Clear for DatabaseEncryption {
    fn clear(&mut self) {
        self.state = DatabaseEncryption_State::UNKNOWN;
        self.key_name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DatabaseEncryption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DatabaseEncryption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum DatabaseEncryption_State {
    UNKNOWN = 0,
    ENCRYPTED = 1,
    DECRYPTED = 2,
}

impl ::protobuf::ProtobufEnum for DatabaseEncryption_State {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<DatabaseEncryption_State> {
        match value {
            0 => ::std::option::Option::Some(DatabaseEncryption_State::UNKNOWN),
            1 => ::std::option::Option::Some(DatabaseEncryption_State::ENCRYPTED),
            2 => ::std::option::Option::Some(DatabaseEncryption_State::DECRYPTED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [DatabaseEncryption_State] = &[
            DatabaseEncryption_State::UNKNOWN,
            DatabaseEncryption_State::ENCRYPTED,
            DatabaseEncryption_State::DECRYPTED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<DatabaseEncryption_State>("DatabaseEncryption.State", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for DatabaseEncryption_State {
}

impl ::std::default::Default for DatabaseEncryption_State {
    fn default() -> Self {
        DatabaseEncryption_State::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for DatabaseEncryption_State {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListUsableSubnetworksRequest {
    // message fields
    pub parent: ::std::string::String,
    pub filter: ::std::string::String,
    pub page_size: i32,
    pub page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUsableSubnetworksRequest {
    fn default() -> &'a ListUsableSubnetworksRequest {
        <ListUsableSubnetworksRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListUsableSubnetworksRequest {
    pub fn new() -> ListUsableSubnetworksRequest {
        ::std::default::Default::default()
    }

    // string parent = 1;


    pub fn get_parent(&self) -> &str {
        &self.parent
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: ::std::string::String) {
        self.parent = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut ::std::string::String {
        &mut self.parent
    }

    // Take field
    pub fn take_parent(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent, ::std::string::String::new())
    }

    // string filter = 2;


    pub fn get_filter(&self) -> &str {
        &self.filter
    }
    pub fn clear_filter(&mut self) {
        self.filter.clear();
    }

    // Param is passed by value, moved
    pub fn set_filter(&mut self, v: ::std::string::String) {
        self.filter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_filter(&mut self) -> &mut ::std::string::String {
        &mut self.filter
    }

    // Take field
    pub fn take_filter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.filter, ::std::string::String::new())
    }

    // int32 page_size = 3;


    pub fn get_page_size(&self) -> i32 {
        self.page_size
    }
    pub fn clear_page_size(&mut self) {
        self.page_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_page_size(&mut self, v: i32) {
        self.page_size = v;
    }

    // string page_token = 4;


    pub fn get_page_token(&self) -> &str {
        &self.page_token
    }
    pub fn clear_page_token(&mut self) {
        self.page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_page_token(&mut self, v: ::std::string::String) {
        self.page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.page_token
    }

    // Take field
    pub fn take_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListUsableSubnetworksRequest {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.filter)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.page_size = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.parent.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.parent);
        }
        if !self.filter.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.filter);
        }
        if self.page_size != 0 {
            my_size += ::protobuf::rt::value_size(3, self.page_size, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.parent.is_empty() {
            os.write_string(1, &self.parent)?;
        }
        if !self.filter.is_empty() {
            os.write_string(2, &self.filter)?;
        }
        if self.page_size != 0 {
            os.write_int32(3, self.page_size)?;
        }
        if !self.page_token.is_empty() {
            os.write_string(4, &self.page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUsableSubnetworksRequest {
        ListUsableSubnetworksRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "parent",
                |m: &ListUsableSubnetworksRequest| { &m.parent },
                |m: &mut ListUsableSubnetworksRequest| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "filter",
                |m: &ListUsableSubnetworksRequest| { &m.filter },
                |m: &mut ListUsableSubnetworksRequest| { &mut m.filter },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "page_size",
                |m: &ListUsableSubnetworksRequest| { &m.page_size },
                |m: &mut ListUsableSubnetworksRequest| { &mut m.page_size },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "page_token",
                |m: &ListUsableSubnetworksRequest| { &m.page_token },
                |m: &mut ListUsableSubnetworksRequest| { &mut m.page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListUsableSubnetworksRequest>(
                "ListUsableSubnetworksRequest",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListUsableSubnetworksRequest {
        static instance: ::protobuf::rt::LazyV2<ListUsableSubnetworksRequest> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListUsableSubnetworksRequest::new)
    }
}

impl ::protobuf::Clear for ListUsableSubnetworksRequest {
    fn clear(&mut self) {
        self.parent.clear();
        self.filter.clear();
        self.page_size = 0;
        self.page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUsableSubnetworksRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUsableSubnetworksRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListUsableSubnetworksResponse {
    // message fields
    pub subnetworks: ::protobuf::RepeatedField<UsableSubnetwork>,
    pub next_page_token: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListUsableSubnetworksResponse {
    fn default() -> &'a ListUsableSubnetworksResponse {
        <ListUsableSubnetworksResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListUsableSubnetworksResponse {
    pub fn new() -> ListUsableSubnetworksResponse {
        ::std::default::Default::default()
    }

    // repeated .google.container.v1.UsableSubnetwork subnetworks = 1;


    pub fn get_subnetworks(&self) -> &[UsableSubnetwork] {
        &self.subnetworks
    }
    pub fn clear_subnetworks(&mut self) {
        self.subnetworks.clear();
    }

    // Param is passed by value, moved
    pub fn set_subnetworks(&mut self, v: ::protobuf::RepeatedField<UsableSubnetwork>) {
        self.subnetworks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subnetworks(&mut self) -> &mut ::protobuf::RepeatedField<UsableSubnetwork> {
        &mut self.subnetworks
    }

    // Take field
    pub fn take_subnetworks(&mut self) -> ::protobuf::RepeatedField<UsableSubnetwork> {
        ::std::mem::replace(&mut self.subnetworks, ::protobuf::RepeatedField::new())
    }

    // string next_page_token = 2;


    pub fn get_next_page_token(&self) -> &str {
        &self.next_page_token
    }
    pub fn clear_next_page_token(&mut self) {
        self.next_page_token.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_page_token(&mut self, v: ::std::string::String) {
        self.next_page_token = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_page_token(&mut self) -> &mut ::std::string::String {
        &mut self.next_page_token
    }

    // Take field
    pub fn take_next_page_token(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.next_page_token, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListUsableSubnetworksResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.subnetworks {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subnetworks)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.next_page_token)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subnetworks {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.next_page_token.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.next_page_token);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subnetworks {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.next_page_token.is_empty() {
            os.write_string(2, &self.next_page_token)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListUsableSubnetworksResponse {
        ListUsableSubnetworksResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UsableSubnetwork>>(
                "subnetworks",
                |m: &ListUsableSubnetworksResponse| { &m.subnetworks },
                |m: &mut ListUsableSubnetworksResponse| { &mut m.subnetworks },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "next_page_token",
                |m: &ListUsableSubnetworksResponse| { &m.next_page_token },
                |m: &mut ListUsableSubnetworksResponse| { &mut m.next_page_token },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListUsableSubnetworksResponse>(
                "ListUsableSubnetworksResponse",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListUsableSubnetworksResponse {
        static instance: ::protobuf::rt::LazyV2<ListUsableSubnetworksResponse> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListUsableSubnetworksResponse::new)
    }
}

impl ::protobuf::Clear for ListUsableSubnetworksResponse {
    fn clear(&mut self) {
        self.subnetworks.clear();
        self.next_page_token.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListUsableSubnetworksResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListUsableSubnetworksResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UsableSubnetworkSecondaryRange {
    // message fields
    pub range_name: ::std::string::String,
    pub ip_cidr_range: ::std::string::String,
    pub status: UsableSubnetworkSecondaryRange_Status,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UsableSubnetworkSecondaryRange {
    fn default() -> &'a UsableSubnetworkSecondaryRange {
        <UsableSubnetworkSecondaryRange as ::protobuf::Message>::default_instance()
    }
}

impl UsableSubnetworkSecondaryRange {
    pub fn new() -> UsableSubnetworkSecondaryRange {
        ::std::default::Default::default()
    }

    // string range_name = 1;


    pub fn get_range_name(&self) -> &str {
        &self.range_name
    }
    pub fn clear_range_name(&mut self) {
        self.range_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_range_name(&mut self, v: ::std::string::String) {
        self.range_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range_name(&mut self) -> &mut ::std::string::String {
        &mut self.range_name
    }

    // Take field
    pub fn take_range_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.range_name, ::std::string::String::new())
    }

    // string ip_cidr_range = 2;


    pub fn get_ip_cidr_range(&self) -> &str {
        &self.ip_cidr_range
    }
    pub fn clear_ip_cidr_range(&mut self) {
        self.ip_cidr_range.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_cidr_range(&mut self, v: ::std::string::String) {
        self.ip_cidr_range = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_cidr_range(&mut self) -> &mut ::std::string::String {
        &mut self.ip_cidr_range
    }

    // Take field
    pub fn take_ip_cidr_range(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip_cidr_range, ::std::string::String::new())
    }

    // .google.container.v1.UsableSubnetworkSecondaryRange.Status status = 3;


    pub fn get_status(&self) -> UsableSubnetworkSecondaryRange_Status {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = UsableSubnetworkSecondaryRange_Status::UNKNOWN;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: UsableSubnetworkSecondaryRange_Status) {
        self.status = v;
    }
}

impl ::protobuf::Message for UsableSubnetworkSecondaryRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.range_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip_cidr_range)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.range_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.range_name);
        }
        if !self.ip_cidr_range.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.ip_cidr_range);
        }
        if self.status != UsableSubnetworkSecondaryRange_Status::UNKNOWN {
            my_size += ::protobuf::rt::enum_size(3, self.status);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.range_name.is_empty() {
            os.write_string(1, &self.range_name)?;
        }
        if !self.ip_cidr_range.is_empty() {
            os.write_string(2, &self.ip_cidr_range)?;
        }
        if self.status != UsableSubnetworkSecondaryRange_Status::UNKNOWN {
            os.write_enum(3, ::protobuf::ProtobufEnum::value(&self.status))?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UsableSubnetworkSecondaryRange {
        UsableSubnetworkSecondaryRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "range_name",
                |m: &UsableSubnetworkSecondaryRange| { &m.range_name },
                |m: &mut UsableSubnetworkSecondaryRange| { &mut m.range_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip_cidr_range",
                |m: &UsableSubnetworkSecondaryRange| { &m.ip_cidr_range },
                |m: &mut UsableSubnetworkSecondaryRange| { &mut m.ip_cidr_range },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<UsableSubnetworkSecondaryRange_Status>>(
                "status",
                |m: &UsableSubnetworkSecondaryRange| { &m.status },
                |m: &mut UsableSubnetworkSecondaryRange| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UsableSubnetworkSecondaryRange>(
                "UsableSubnetworkSecondaryRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UsableSubnetworkSecondaryRange {
        static instance: ::protobuf::rt::LazyV2<UsableSubnetworkSecondaryRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UsableSubnetworkSecondaryRange::new)
    }
}

impl ::protobuf::Clear for UsableSubnetworkSecondaryRange {
    fn clear(&mut self) {
        self.range_name.clear();
        self.ip_cidr_range.clear();
        self.status = UsableSubnetworkSecondaryRange_Status::UNKNOWN;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UsableSubnetworkSecondaryRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsableSubnetworkSecondaryRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
pub enum UsableSubnetworkSecondaryRange_Status {
    UNKNOWN = 0,
    UNUSED = 1,
    IN_USE_SERVICE = 2,
    IN_USE_SHAREABLE_POD = 3,
    IN_USE_MANAGED_POD = 4,
}

impl ::protobuf::ProtobufEnum for UsableSubnetworkSecondaryRange_Status {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UsableSubnetworkSecondaryRange_Status> {
        match value {
            0 => ::std::option::Option::Some(UsableSubnetworkSecondaryRange_Status::UNKNOWN),
            1 => ::std::option::Option::Some(UsableSubnetworkSecondaryRange_Status::UNUSED),
            2 => ::std::option::Option::Some(UsableSubnetworkSecondaryRange_Status::IN_USE_SERVICE),
            3 => ::std::option::Option::Some(UsableSubnetworkSecondaryRange_Status::IN_USE_SHAREABLE_POD),
            4 => ::std::option::Option::Some(UsableSubnetworkSecondaryRange_Status::IN_USE_MANAGED_POD),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [UsableSubnetworkSecondaryRange_Status] = &[
            UsableSubnetworkSecondaryRange_Status::UNKNOWN,
            UsableSubnetworkSecondaryRange_Status::UNUSED,
            UsableSubnetworkSecondaryRange_Status::IN_USE_SERVICE,
            UsableSubnetworkSecondaryRange_Status::IN_USE_SHAREABLE_POD,
            UsableSubnetworkSecondaryRange_Status::IN_USE_MANAGED_POD,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<UsableSubnetworkSecondaryRange_Status>("UsableSubnetworkSecondaryRange.Status", file_descriptor_proto())
        })
    }
}

impl ::std::marker::Copy for UsableSubnetworkSecondaryRange_Status {
}

impl ::std::default::Default for UsableSubnetworkSecondaryRange_Status {
    fn default() -> Self {
        UsableSubnetworkSecondaryRange_Status::UNKNOWN
    }
}

impl ::protobuf::reflect::ProtobufValue for UsableSubnetworkSecondaryRange_Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UsableSubnetwork {
    // message fields
    pub subnetwork: ::std::string::String,
    pub network: ::std::string::String,
    pub ip_cidr_range: ::std::string::String,
    pub secondary_ip_ranges: ::protobuf::RepeatedField<UsableSubnetworkSecondaryRange>,
    pub status_message: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UsableSubnetwork {
    fn default() -> &'a UsableSubnetwork {
        <UsableSubnetwork as ::protobuf::Message>::default_instance()
    }
}

impl UsableSubnetwork {
    pub fn new() -> UsableSubnetwork {
        ::std::default::Default::default()
    }

    // string subnetwork = 1;


    pub fn get_subnetwork(&self) -> &str {
        &self.subnetwork
    }
    pub fn clear_subnetwork(&mut self) {
        self.subnetwork.clear();
    }

    // Param is passed by value, moved
    pub fn set_subnetwork(&mut self, v: ::std::string::String) {
        self.subnetwork = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subnetwork(&mut self) -> &mut ::std::string::String {
        &mut self.subnetwork
    }

    // Take field
    pub fn take_subnetwork(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.subnetwork, ::std::string::String::new())
    }

    // string network = 2;


    pub fn get_network(&self) -> &str {
        &self.network
    }
    pub fn clear_network(&mut self) {
        self.network.clear();
    }

    // Param is passed by value, moved
    pub fn set_network(&mut self, v: ::std::string::String) {
        self.network = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_network(&mut self) -> &mut ::std::string::String {
        &mut self.network
    }

    // Take field
    pub fn take_network(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.network, ::std::string::String::new())
    }

    // string ip_cidr_range = 3;


    pub fn get_ip_cidr_range(&self) -> &str {
        &self.ip_cidr_range
    }
    pub fn clear_ip_cidr_range(&mut self) {
        self.ip_cidr_range.clear();
    }

    // Param is passed by value, moved
    pub fn set_ip_cidr_range(&mut self, v: ::std::string::String) {
        self.ip_cidr_range = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip_cidr_range(&mut self) -> &mut ::std::string::String {
        &mut self.ip_cidr_range
    }

    // Take field
    pub fn take_ip_cidr_range(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ip_cidr_range, ::std::string::String::new())
    }

    // repeated .google.container.v1.UsableSubnetworkSecondaryRange secondary_ip_ranges = 4;


    pub fn get_secondary_ip_ranges(&self) -> &[UsableSubnetworkSecondaryRange] {
        &self.secondary_ip_ranges
    }
    pub fn clear_secondary_ip_ranges(&mut self) {
        self.secondary_ip_ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_secondary_ip_ranges(&mut self, v: ::protobuf::RepeatedField<UsableSubnetworkSecondaryRange>) {
        self.secondary_ip_ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secondary_ip_ranges(&mut self) -> &mut ::protobuf::RepeatedField<UsableSubnetworkSecondaryRange> {
        &mut self.secondary_ip_ranges
    }

    // Take field
    pub fn take_secondary_ip_ranges(&mut self) -> ::protobuf::RepeatedField<UsableSubnetworkSecondaryRange> {
        ::std::mem::replace(&mut self.secondary_ip_ranges, ::protobuf::RepeatedField::new())
    }

    // string status_message = 5;


    pub fn get_status_message(&self) -> &str {
        &self.status_message
    }
    pub fn clear_status_message(&mut self) {
        self.status_message.clear();
    }

    // Param is passed by value, moved
    pub fn set_status_message(&mut self, v: ::std::string::String) {
        self.status_message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status_message(&mut self) -> &mut ::std::string::String {
        &mut self.status_message
    }

    // Take field
    pub fn take_status_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.status_message, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UsableSubnetwork {
    fn is_initialized(&self) -> bool {
        for v in &self.secondary_ip_ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.subnetwork)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.network)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ip_cidr_range)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.secondary_ip_ranges)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.status_message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.subnetwork.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.subnetwork);
        }
        if !self.network.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.network);
        }
        if !self.ip_cidr_range.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.ip_cidr_range);
        }
        for value in &self.secondary_ip_ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.status_message.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.status_message);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.subnetwork.is_empty() {
            os.write_string(1, &self.subnetwork)?;
        }
        if !self.network.is_empty() {
            os.write_string(2, &self.network)?;
        }
        if !self.ip_cidr_range.is_empty() {
            os.write_string(3, &self.ip_cidr_range)?;
        }
        for v in &self.secondary_ip_ranges {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.status_message.is_empty() {
            os.write_string(5, &self.status_message)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UsableSubnetwork {
        UsableSubnetwork::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subnetwork",
                |m: &UsableSubnetwork| { &m.subnetwork },
                |m: &mut UsableSubnetwork| { &mut m.subnetwork },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "network",
                |m: &UsableSubnetwork| { &m.network },
                |m: &mut UsableSubnetwork| { &mut m.network },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip_cidr_range",
                |m: &UsableSubnetwork| { &m.ip_cidr_range },
                |m: &mut UsableSubnetwork| { &mut m.ip_cidr_range },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UsableSubnetworkSecondaryRange>>(
                "secondary_ip_ranges",
                |m: &UsableSubnetwork| { &m.secondary_ip_ranges },
                |m: &mut UsableSubnetwork| { &mut m.secondary_ip_ranges },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status_message",
                |m: &UsableSubnetwork| { &m.status_message },
                |m: &mut UsableSubnetwork| { &mut m.status_message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UsableSubnetwork>(
                "UsableSubnetwork",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UsableSubnetwork {
        static instance: ::protobuf::rt::LazyV2<UsableSubnetwork> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UsableSubnetwork::new)
    }
}

impl ::protobuf::Clear for UsableSubnetwork {
    fn clear(&mut self) {
        self.subnetwork.clear();
        self.network.clear();
        self.ip_cidr_range.clear();
        self.secondary_ip_ranges.clear();
        self.status_message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UsableSubnetwork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UsableSubnetwork {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceUsageExportConfig {
    // message fields
    pub bigquery_destination: ::protobuf::SingularPtrField<ResourceUsageExportConfig_BigQueryDestination>,
    pub enable_network_egress_metering: bool,
    pub consumption_metering_config: ::protobuf::SingularPtrField<ResourceUsageExportConfig_ConsumptionMeteringConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceUsageExportConfig {
    fn default() -> &'a ResourceUsageExportConfig {
        <ResourceUsageExportConfig as ::protobuf::Message>::default_instance()
    }
}

impl ResourceUsageExportConfig {
    pub fn new() -> ResourceUsageExportConfig {
        ::std::default::Default::default()
    }

    // .google.container.v1.ResourceUsageExportConfig.BigQueryDestination bigquery_destination = 1;


    pub fn get_bigquery_destination(&self) -> &ResourceUsageExportConfig_BigQueryDestination {
        self.bigquery_destination.as_ref().unwrap_or_else(|| <ResourceUsageExportConfig_BigQueryDestination as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bigquery_destination(&mut self) {
        self.bigquery_destination.clear();
    }

    pub fn has_bigquery_destination(&self) -> bool {
        self.bigquery_destination.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bigquery_destination(&mut self, v: ResourceUsageExportConfig_BigQueryDestination) {
        self.bigquery_destination = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bigquery_destination(&mut self) -> &mut ResourceUsageExportConfig_BigQueryDestination {
        if self.bigquery_destination.is_none() {
            self.bigquery_destination.set_default();
        }
        self.bigquery_destination.as_mut().unwrap()
    }

    // Take field
    pub fn take_bigquery_destination(&mut self) -> ResourceUsageExportConfig_BigQueryDestination {
        self.bigquery_destination.take().unwrap_or_else(|| ResourceUsageExportConfig_BigQueryDestination::new())
    }

    // bool enable_network_egress_metering = 2;


    pub fn get_enable_network_egress_metering(&self) -> bool {
        self.enable_network_egress_metering
    }
    pub fn clear_enable_network_egress_metering(&mut self) {
        self.enable_network_egress_metering = false;
    }

    // Param is passed by value, moved
    pub fn set_enable_network_egress_metering(&mut self, v: bool) {
        self.enable_network_egress_metering = v;
    }

    // .google.container.v1.ResourceUsageExportConfig.ConsumptionMeteringConfig consumption_metering_config = 3;


    pub fn get_consumption_metering_config(&self) -> &ResourceUsageExportConfig_ConsumptionMeteringConfig {
        self.consumption_metering_config.as_ref().unwrap_or_else(|| <ResourceUsageExportConfig_ConsumptionMeteringConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_consumption_metering_config(&mut self) {
        self.consumption_metering_config.clear();
    }

    pub fn has_consumption_metering_config(&self) -> bool {
        self.consumption_metering_config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_consumption_metering_config(&mut self, v: ResourceUsageExportConfig_ConsumptionMeteringConfig) {
        self.consumption_metering_config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_consumption_metering_config(&mut self) -> &mut ResourceUsageExportConfig_ConsumptionMeteringConfig {
        if self.consumption_metering_config.is_none() {
            self.consumption_metering_config.set_default();
        }
        self.consumption_metering_config.as_mut().unwrap()
    }

    // Take field
    pub fn take_consumption_metering_config(&mut self) -> ResourceUsageExportConfig_ConsumptionMeteringConfig {
        self.consumption_metering_config.take().unwrap_or_else(|| ResourceUsageExportConfig_ConsumptionMeteringConfig::new())
    }
}

impl ::protobuf::Message for ResourceUsageExportConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.bigquery_destination {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.consumption_metering_config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bigquery_destination)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable_network_egress_metering = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.consumption_metering_config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bigquery_destination.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.enable_network_egress_metering != false {
            my_size += 2;
        }
        if let Some(ref v) = self.consumption_metering_config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bigquery_destination.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.enable_network_egress_metering != false {
            os.write_bool(2, self.enable_network_egress_metering)?;
        }
        if let Some(ref v) = self.consumption_metering_config.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceUsageExportConfig {
        ResourceUsageExportConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceUsageExportConfig_BigQueryDestination>>(
                "bigquery_destination",
                |m: &ResourceUsageExportConfig| { &m.bigquery_destination },
                |m: &mut ResourceUsageExportConfig| { &mut m.bigquery_destination },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable_network_egress_metering",
                |m: &ResourceUsageExportConfig| { &m.enable_network_egress_metering },
                |m: &mut ResourceUsageExportConfig| { &mut m.enable_network_egress_metering },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceUsageExportConfig_ConsumptionMeteringConfig>>(
                "consumption_metering_config",
                |m: &ResourceUsageExportConfig| { &m.consumption_metering_config },
                |m: &mut ResourceUsageExportConfig| { &mut m.consumption_metering_config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceUsageExportConfig>(
                "ResourceUsageExportConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceUsageExportConfig {
        static instance: ::protobuf::rt::LazyV2<ResourceUsageExportConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceUsageExportConfig::new)
    }
}

impl ::protobuf::Clear for ResourceUsageExportConfig {
    fn clear(&mut self) {
        self.bigquery_destination.clear();
        self.enable_network_egress_metering = false;
        self.consumption_metering_config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceUsageExportConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceUsageExportConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceUsageExportConfig_BigQueryDestination {
    // message fields
    pub dataset_id: ::std::string::String,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceUsageExportConfig_BigQueryDestination {
    fn default() -> &'a ResourceUsageExportConfig_BigQueryDestination {
        <ResourceUsageExportConfig_BigQueryDestination as ::protobuf::Message>::default_instance()
    }
}

impl ResourceUsageExportConfig_BigQueryDestination {
    pub fn new() -> ResourceUsageExportConfig_BigQueryDestination {
        ::std::default::Default::default()
    }

    // string dataset_id = 1;


    pub fn get_dataset_id(&self) -> &str {
        &self.dataset_id
    }
    pub fn clear_dataset_id(&mut self) {
        self.dataset_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_dataset_id(&mut self, v: ::std::string::String) {
        self.dataset_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataset_id(&mut self) -> &mut ::std::string::String {
        &mut self.dataset_id
    }

    // Take field
    pub fn take_dataset_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dataset_id, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ResourceUsageExportConfig_BigQueryDestination {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dataset_id)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.dataset_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.dataset_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.dataset_id.is_empty() {
            os.write_string(1, &self.dataset_id)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceUsageExportConfig_BigQueryDestination {
        ResourceUsageExportConfig_BigQueryDestination::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dataset_id",
                |m: &ResourceUsageExportConfig_BigQueryDestination| { &m.dataset_id },
                |m: &mut ResourceUsageExportConfig_BigQueryDestination| { &mut m.dataset_id },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceUsageExportConfig_BigQueryDestination>(
                "ResourceUsageExportConfig.BigQueryDestination",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceUsageExportConfig_BigQueryDestination {
        static instance: ::protobuf::rt::LazyV2<ResourceUsageExportConfig_BigQueryDestination> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceUsageExportConfig_BigQueryDestination::new)
    }
}

impl ::protobuf::Clear for ResourceUsageExportConfig_BigQueryDestination {
    fn clear(&mut self) {
        self.dataset_id.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceUsageExportConfig_BigQueryDestination {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceUsageExportConfig_BigQueryDestination {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceUsageExportConfig_ConsumptionMeteringConfig {
    // message fields
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceUsageExportConfig_ConsumptionMeteringConfig {
    fn default() -> &'a ResourceUsageExportConfig_ConsumptionMeteringConfig {
        <ResourceUsageExportConfig_ConsumptionMeteringConfig as ::protobuf::Message>::default_instance()
    }
}

impl ResourceUsageExportConfig_ConsumptionMeteringConfig {
    pub fn new() -> ResourceUsageExportConfig_ConsumptionMeteringConfig {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for ResourceUsageExportConfig_ConsumptionMeteringConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceUsageExportConfig_ConsumptionMeteringConfig {
        ResourceUsageExportConfig_ConsumptionMeteringConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &ResourceUsageExportConfig_ConsumptionMeteringConfig| { &m.enabled },
                |m: &mut ResourceUsageExportConfig_ConsumptionMeteringConfig| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceUsageExportConfig_ConsumptionMeteringConfig>(
                "ResourceUsageExportConfig.ConsumptionMeteringConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceUsageExportConfig_ConsumptionMeteringConfig {
        static instance: ::protobuf::rt::LazyV2<ResourceUsageExportConfig_ConsumptionMeteringConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceUsageExportConfig_ConsumptionMeteringConfig::new)
    }
}

impl ::protobuf::Clear for ResourceUsageExportConfig_ConsumptionMeteringConfig {
    fn clear(&mut self) {
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceUsageExportConfig_ConsumptionMeteringConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceUsageExportConfig_ConsumptionMeteringConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VerticalPodAutoscaling {
    // message fields
    pub enabled: bool,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VerticalPodAutoscaling {
    fn default() -> &'a VerticalPodAutoscaling {
        <VerticalPodAutoscaling as ::protobuf::Message>::default_instance()
    }
}

impl VerticalPodAutoscaling {
    pub fn new() -> VerticalPodAutoscaling {
        ::std::default::Default::default()
    }

    // bool enabled = 1;


    pub fn get_enabled(&self) -> bool {
        self.enabled
    }
    pub fn clear_enabled(&mut self) {
        self.enabled = false;
    }

    // Param is passed by value, moved
    pub fn set_enabled(&mut self, v: bool) {
        self.enabled = v;
    }
}

impl ::protobuf::Message for VerticalPodAutoscaling {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enabled = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.enabled != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.enabled != false {
            os.write_bool(1, self.enabled)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VerticalPodAutoscaling {
        VerticalPodAutoscaling::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enabled",
                |m: &VerticalPodAutoscaling| { &m.enabled },
                |m: &mut VerticalPodAutoscaling| { &mut m.enabled },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VerticalPodAutoscaling>(
                "VerticalPodAutoscaling",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VerticalPodAutoscaling {
        static instance: ::protobuf::rt::LazyV2<VerticalPodAutoscaling> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VerticalPodAutoscaling::new)
    }
}

impl ::protobuf::Clear for VerticalPodAutoscaling {
    fn clear(&mut self) {
        self.enabled = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VerticalPodAutoscaling {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VerticalPodAutoscaling {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n)google/container/v1/cluster_service.proto\x12\x13google.container.v1\
    \x1a\x1cgoogle/api/annotations.proto\x1a\x17google/api/client.proto\x1a\
    \x1fgoogle/api/field_behavior.proto\x1a\x1bgoogle/protobuf/empty.proto\
    \x1a\x1fgoogle/protobuf/timestamp.proto\"\xd4\x06\n\nNodeConfig\x12!\n\
    \x0cmachine_type\x18\x01\x20\x01(\tR\x0bmachineType\x12\x20\n\x0cdisk_si\
    ze_gb\x18\x02\x20\x01(\x05R\ndiskSizeGb\x12!\n\x0coauth_scopes\x18\x03\
    \x20\x03(\tR\x0boauthScopes\x12'\n\x0fservice_account\x18\t\x20\x01(\tR\
    \x0eserviceAccount\x12I\n\x08metadata\x18\x04\x20\x03(\x0b2-.google.cont\
    ainer.v1.NodeConfig.MetadataEntryR\x08metadata\x12\x1d\n\nimage_type\x18\
    \x05\x20\x01(\tR\timageType\x12C\n\x06labels\x18\x06\x20\x03(\x0b2+.goog\
    le.container.v1.NodeConfig.LabelsEntryR\x06labels\x12&\n\x0flocal_ssd_co\
    unt\x18\x07\x20\x01(\x05R\rlocalSsdCount\x12\x12\n\x04tags\x18\x08\x20\
    \x03(\tR\x04tags\x12\x20\n\x0bpreemptible\x18\n\x20\x01(\x08R\x0bpreempt\
    ible\x12J\n\x0caccelerators\x18\x0b\x20\x03(\x0b2&.google.container.v1.A\
    cceleratorConfigR\x0caccelerators\x12\x1b\n\tdisk_type\x18\x0c\x20\x01(\
    \tR\x08diskType\x12(\n\x10min_cpu_platform\x18\r\x20\x01(\tR\x0eminCpuPl\
    atform\x126\n\x06taints\x18\x0f\x20\x03(\x0b2\x1e.google.container.v1.No\
    deTaintR\x06taints\x12e\n\x18shielded_instance_config\x18\x14\x20\x01(\
    \x0b2+.google.container.v1.ShieldedInstanceConfigR\x16shieldedInstanceCo\
    nfig\x1a;\n\rMetadataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a9\n\x0bLab\
    elsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\
    \x18\x02\x20\x01(\tR\x05value:\x028\x01\"\x86\x01\n\x16ShieldedInstanceC\
    onfig\x12,\n\x12enable_secure_boot\x18\x01\x20\x01(\x08R\x10enableSecure\
    Boot\x12>\n\x1benable_integrity_monitoring\x18\x02\x20\x01(\x08R\x19enab\
    leIntegrityMonitoring\"\xcd\x01\n\tNodeTaint\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\x12=\
    \n\x06effect\x18\x03\x20\x01(\x0e2%.google.container.v1.NodeTaint.Effect\
    R\x06effect\"Y\n\x06Effect\x12\x16\n\x12EFFECT_UNSPECIFIED\x10\0\x12\x0f\
    \n\x0bNO_SCHEDULE\x10\x01\x12\x16\n\x12PREFER_NO_SCHEDULE\x10\x02\x12\
    \x0e\n\nNO_EXECUTE\x10\x03\"\xb2\x02\n\nMasterAuth\x12\x1a\n\x08username\
    \x18\x01\x20\x01(\tR\x08username\x12\x1a\n\x08password\x18\x02\x20\x01(\
    \tR\x08password\x12h\n\x19client_certificate_config\x18\x03\x20\x01(\x0b\
    2,.google.container.v1.ClientCertificateConfigR\x17clientCertificateConf\
    ig\x124\n\x16cluster_ca_certificate\x18d\x20\x01(\tR\x14clusterCaCertifi\
    cate\x12-\n\x12client_certificate\x18e\x20\x01(\tR\x11clientCertificate\
    \x12\x1d\n\nclient_key\x18f\x20\x01(\tR\tclientKey\"S\n\x17ClientCertifi\
    cateConfig\x128\n\x18issue_client_certificate\x18\x01\x20\x01(\x08R\x16i\
    ssueClientCertificate\"\xe1\x03\n\x0cAddonsConfig\x12V\n\x13http_load_ba\
    lancing\x18\x01\x20\x01(\x0b2&.google.container.v1.HttpLoadBalancingR\
    \x11httpLoadBalancing\x12k\n\x1ahorizontal_pod_autoscaling\x18\x02\x20\
    \x01(\x0b2-.google.container.v1.HorizontalPodAutoscalingR\x18horizontalP\
    odAutoscaling\x12_\n\x14kubernetes_dashboard\x18\x03\x20\x01(\x0b2(.goog\
    le.container.v1.KubernetesDashboardR\x13kubernetesDashboardB\x02\x18\x01\
    \x12\\\n\x15network_policy_config\x18\x04\x20\x01(\x0b2(.google.containe\
    r.v1.NetworkPolicyConfigR\x13networkPolicyConfig\x12M\n\x10cloud_run_con\
    fig\x18\x07\x20\x01(\x0b2#.google.container.v1.CloudRunConfigR\x0ecloudR\
    unConfig\"/\n\x11HttpLoadBalancing\x12\x1a\n\x08disabled\x18\x01\x20\x01\
    (\x08R\x08disabled\"6\n\x18HorizontalPodAutoscaling\x12\x1a\n\x08disable\
    d\x18\x01\x20\x01(\x08R\x08disabled\"1\n\x13KubernetesDashboard\x12\x1a\
    \n\x08disabled\x18\x01\x20\x01(\x08R\x08disabled\"1\n\x13NetworkPolicyCo\
    nfig\x12\x1a\n\x08disabled\x18\x01\x20\x01(\x08R\x08disabled\"\x89\x02\n\
    \x14PrivateClusterConfig\x120\n\x14enable_private_nodes\x18\x01\x20\x01(\
    \x08R\x12enablePrivateNodes\x126\n\x17enable_private_endpoint\x18\x02\
    \x20\x01(\x08R\x15enablePrivateEndpoint\x123\n\x16master_ipv4_cidr_block\
    \x18\x03\x20\x01(\tR\x13masterIpv4CidrBlock\x12)\n\x10private_endpoint\
    \x18\x04\x20\x01(\tR\x0fprivateEndpoint\x12'\n\x0fpublic_endpoint\x18\
    \x05\x20\x01(\tR\x0epublicEndpoint\"\\\n\x19AuthenticatorGroupsConfig\
    \x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12%\n\x0esecurit\
    y_group\x18\x02\x20\x01(\tR\rsecurityGroup\",\n\x0eCloudRunConfig\x12\
    \x1a\n\x08disabled\x18\x01\x20\x01(\x08R\x08disabled\"\xe9\x01\n\x1eMast\
    erAuthorizedNetworksConfig\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\
    \x07enabled\x12^\n\x0bcidr_blocks\x18\x02\x20\x03(\x0b2=.google.containe\
    r.v1.MasterAuthorizedNetworksConfig.CidrBlockR\ncidrBlocks\x1aM\n\tCidrB\
    lock\x12!\n\x0cdisplay_name\x18\x01\x20\x01(\tR\x0bdisplayName\x12\x1d\n\
    \ncidr_block\x18\x02\x20\x01(\tR\tcidrBlock\"&\n\nLegacyAbac\x12\x18\n\
    \x07enabled\x18\x01\x20\x01(\x08R\x07enabled\"\xa4\x01\n\rNetworkPolicy\
    \x12G\n\x08provider\x18\x01\x20\x01(\x0e2+.google.container.v1.NetworkPo\
    licy.ProviderR\x08provider\x12\x18\n\x07enabled\x18\x02\x20\x01(\x08R\
    \x07enabled\"0\n\x08Provider\x12\x18\n\x14PROVIDER_UNSPECIFIED\x10\0\x12\
    \n\n\x06CALICO\x10\x01\"/\n\x13BinaryAuthorization\x12\x18\n\x07enabled\
    \x18\x01\x20\x01(\x08R\x07enabled\"\xf0\x04\n\x12IPAllocationPolicy\x12$\
    \n\x0euse_ip_aliases\x18\x01\x20\x01(\x08R\x0cuseIpAliases\x12+\n\x11cre\
    ate_subnetwork\x18\x02\x20\x01(\x08R\x10createSubnetwork\x12'\n\x0fsubne\
    twork_name\x18\x03\x20\x01(\tR\x0esubnetworkName\x12.\n\x11cluster_ipv4_\
    cidr\x18\x04\x20\x01(\tR\x0fclusterIpv4CidrB\x02\x18\x01\x12(\n\x0enode_\
    ipv4_cidr\x18\x05\x20\x01(\tR\x0cnodeIpv4CidrB\x02\x18\x01\x120\n\x12ser\
    vices_ipv4_cidr\x18\x06\x20\x01(\tR\x10servicesIpv4CidrB\x02\x18\x01\x12\
    ?\n\x1ccluster_secondary_range_name\x18\x07\x20\x01(\tR\x19clusterSecond\
    aryRangeName\x12A\n\x1dservices_secondary_range_name\x18\x08\x20\x01(\tR\
    \x1aservicesSecondaryRangeName\x125\n\x17cluster_ipv4_cidr_block\x18\t\
    \x20\x01(\tR\x14clusterIpv4CidrBlock\x12/\n\x14node_ipv4_cidr_block\x18\
    \n\x20\x01(\tR\x11nodeIpv4CidrBlock\x127\n\x18services_ipv4_cidr_block\
    \x18\x0b\x20\x01(\tR\x15servicesIpv4CidrBlock\x12-\n\x13tpu_ipv4_cidr_bl\
    ock\x18\r\x20\x01(\tR\x10tpuIpv4CidrBlock\"\x81\x18\n\x07Cluster\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x20\n\x0bdescription\x18\x02\
    \x20\x01(\tR\x0bdescription\x120\n\x12initial_node_count\x18\x03\x20\x01\
    (\x05R\x10initialNodeCountB\x02\x18\x01\x12D\n\x0bnode_config\x18\x04\
    \x20\x01(\x0b2\x1f.google.container.v1.NodeConfigR\nnodeConfigB\x02\x18\
    \x01\x12@\n\x0bmaster_auth\x18\x05\x20\x01(\x0b2\x1f.google.container.v1\
    .MasterAuthR\nmasterAuth\x12'\n\x0flogging_service\x18\x06\x20\x01(\tR\
    \x0eloggingService\x12-\n\x12monitoring_service\x18\x07\x20\x01(\tR\x11m\
    onitoringService\x12\x18\n\x07network\x18\x08\x20\x01(\tR\x07network\x12\
    *\n\x11cluster_ipv4_cidr\x18\t\x20\x01(\tR\x0fclusterIpv4Cidr\x12F\n\rad\
    dons_config\x18\n\x20\x01(\x0b2!.google.container.v1.AddonsConfigR\x0cad\
    donsConfig\x12\x1e\n\nsubnetwork\x18\x0b\x20\x01(\tR\nsubnetwork\x12<\n\
    \nnode_pools\x18\x0c\x20\x03(\x0b2\x1d.google.container.v1.NodePoolR\tno\
    dePools\x12\x1c\n\tlocations\x18\r\x20\x03(\tR\tlocations\x126\n\x17enab\
    le_kubernetes_alpha\x18\x0e\x20\x01(\x08R\x15enableKubernetesAlpha\x12Y\
    \n\x0fresource_labels\x18\x0f\x20\x03(\x0b20.google.container.v1.Cluster\
    .ResourceLabelsEntryR\x0eresourceLabels\x12+\n\x11label_fingerprint\x18\
    \x10\x20\x01(\tR\x10labelFingerprint\x12@\n\x0blegacy_abac\x18\x12\x20\
    \x01(\x0b2\x1f.google.container.v1.LegacyAbacR\nlegacyAbac\x12I\n\x0enet\
    work_policy\x18\x13\x20\x01(\x0b2\".google.container.v1.NetworkPolicyR\r\
    networkPolicy\x12Y\n\x14ip_allocation_policy\x18\x14\x20\x01(\x0b2'.goog\
    le.container.v1.IPAllocationPolicyR\x12ipAllocationPolicy\x12~\n!master_\
    authorized_networks_config\x18\x16\x20\x01(\x0b23.google.container.v1.Ma\
    sterAuthorizedNetworksConfigR\x1emasterAuthorizedNetworksConfig\x12U\n\
    \x12maintenance_policy\x18\x17\x20\x01(\x0b2&.google.container.v1.Mainte\
    nancePolicyR\x11maintenancePolicy\x12[\n\x14binary_authorization\x18\x18\
    \x20\x01(\x0b2(.google.container.v1.BinaryAuthorizationR\x13binaryAuthor\
    ization\x12I\n\x0bautoscaling\x18\x1a\x20\x01(\x0b2'.google.container.v1\
    .ClusterAutoscalingR\x0bautoscaling\x12I\n\x0enetwork_config\x18\x1b\x20\
    \x01(\x0b2\".google.container.v1.NetworkConfigR\rnetworkConfig\x12e\n\
    \x1bdefault_max_pods_constraint\x18\x1e\x20\x01(\x0b2&.google.container.\
    v1.MaxPodsConstraintR\x18defaultMaxPodsConstraint\x12o\n\x1cresource_usa\
    ge_export_config\x18!\x20\x01(\x0b2..google.container.v1.ResourceUsageEx\
    portConfigR\x19resourceUsageExportConfig\x12n\n\x1bauthenticator_groups_\
    config\x18\"\x20\x01(\x0b2..google.container.v1.AuthenticatorGroupsConfi\
    gR\x19authenticatorGroupsConfig\x12_\n\x16private_cluster_config\x18%\
    \x20\x01(\x0b2).google.container.v1.PrivateClusterConfigR\x14privateClus\
    terConfig\x12X\n\x13database_encryption\x18&\x20\x01(\x0b2'.google.conta\
    iner.v1.DatabaseEncryptionR\x12databaseEncryption\x12e\n\x18vertical_pod\
    _autoscaling\x18'\x20\x01(\x0b2+.google.container.v1.VerticalPodAutoscal\
    ingR\x16verticalPodAutoscaling\x12\x1b\n\tself_link\x18d\x20\x01(\tR\x08\
    selfLink\x12\x16\n\x04zone\x18e\x20\x01(\tR\x04zoneB\x02\x18\x01\x12\x1a\
    \n\x08endpoint\x18f\x20\x01(\tR\x08endpoint\x126\n\x17initial_cluster_ve\
    rsion\x18g\x20\x01(\tR\x15initialClusterVersion\x124\n\x16current_master\
    _version\x18h\x20\x01(\tR\x14currentMasterVersion\x124\n\x14current_node\
    _version\x18i\x20\x01(\tR\x12currentNodeVersionB\x02\x18\x01\x12\x1f\n\
    \x0bcreate_time\x18j\x20\x01(\tR\ncreateTime\x12;\n\x06status\x18k\x20\
    \x01(\x0e2#.google.container.v1.Cluster.StatusR\x06status\x12%\n\x0estat\
    us_message\x18l\x20\x01(\tR\rstatusMessage\x12-\n\x13node_ipv4_cidr_size\
    \x18m\x20\x01(\x05R\x10nodeIpv4CidrSize\x12,\n\x12services_ipv4_cidr\x18\
    n\x20\x01(\tR\x10servicesIpv4Cidr\x122\n\x13instance_group_urls\x18o\x20\
    \x03(\tR\x11instanceGroupUrlsB\x02\x18\x01\x120\n\x12current_node_count\
    \x18p\x20\x01(\x05R\x10currentNodeCountB\x02\x18\x01\x12\x1f\n\x0bexpire\
    _time\x18q\x20\x01(\tR\nexpireTime\x12\x1a\n\x08location\x18r\x20\x01(\t\
    R\x08location\x12\x1d\n\nenable_tpu\x18s\x20\x01(\x08R\tenableTpu\x12-\n\
    \x13tpu_ipv4_cidr_block\x18t\x20\x01(\tR\x10tpuIpv4CidrBlock\x12D\n\ncon\
    ditions\x18v\x20\x03(\x0b2$.google.container.v1.StatusConditionR\ncondit\
    ions\x1aA\n\x13ResourceLabelsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"w\n\
    \x06Status\x12\x16\n\x12STATUS_UNSPECIFIED\x10\0\x12\x10\n\x0cPROVISIONI\
    NG\x10\x01\x12\x0b\n\x07RUNNING\x10\x02\x12\x0f\n\x0bRECONCILING\x10\x03\
    \x12\x0c\n\x08STOPPING\x10\x04\x12\t\n\x05ERROR\x10\x05\x12\x0c\n\x08DEG\
    RADED\x10\x06\"\x81\x0b\n\rClusterUpdate\x120\n\x14desired_node_version\
    \x18\x04\x20\x01(\tR\x12desiredNodeVersion\x12<\n\x1adesired_monitoring_\
    service\x18\x05\x20\x01(\tR\x18desiredMonitoringService\x12U\n\x15desire\
    d_addons_config\x18\x06\x20\x01(\x0b2!.google.container.v1.AddonsConfigR\
    \x13desiredAddonsConfig\x12/\n\x14desired_node_pool_id\x18\x07\x20\x01(\
    \tR\x11desiredNodePoolId\x12,\n\x12desired_image_type\x18\x08\x20\x01(\t\
    R\x10desiredImageType\x12g\n\x1bdesired_database_encryption\x18.\x20\x01\
    (\x0b2'.google.container.v1.DatabaseEncryptionR\x19desiredDatabaseEncryp\
    tion\x12k\n\x1ddesired_node_pool_autoscaling\x18\t\x20\x01(\x0b2(.google\
    .container.v1.NodePoolAutoscalingR\x1adesiredNodePoolAutoscaling\x12+\n\
    \x11desired_locations\x18\n\x20\x03(\tR\x10desiredLocations\x12\x8d\x01\
    \n)desired_master_authorized_networks_config\x18\x0c\x20\x01(\x0b23.goog\
    le.container.v1.MasterAuthorizedNetworksConfigR%desiredMasterAuthorizedN\
    etworksConfig\x12g\n\x1bdesired_cluster_autoscaling\x18\x0f\x20\x01(\x0b\
    2'.google.container.v1.ClusterAutoscalingR\x19desiredClusterAutoscaling\
    \x12j\n\x1cdesired_binary_authorization\x18\x10\x20\x01(\x0b2(.google.co\
    ntainer.v1.BinaryAuthorizationR\x1adesiredBinaryAuthorization\x126\n\x17\
    desired_logging_service\x18\x13\x20\x01(\tR\x15desiredLoggingService\x12\
    ~\n$desired_resource_usage_export_config\x18\x15\x20\x01(\x0b2..google.c\
    ontainer.v1.ResourceUsageExportConfigR\x20desiredResourceUsageExportConf\
    ig\x12t\n\x20desired_vertical_pod_autoscaling\x18\x16\x20\x01(\x0b2+.goo\
    gle.container.v1.VerticalPodAutoscalingR\x1ddesiredVerticalPodAutoscalin\
    g\x12~\n$desired_intra_node_visibility_config\x18\x1a\x20\x01(\x0b2..goo\
    gle.container.v1.IntraNodeVisibilityConfigR\x20desiredIntraNodeVisibilit\
    yConfig\x124\n\x16desired_master_version\x18d\x20\x01(\tR\x14desiredMast\
    erVersion\"\x95\x08\n\tOperation\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12\x16\n\x04zone\x18\x02\x20\x01(\tR\x04zoneB\x02\x18\x01\x12J\
    \n\x0eoperation_type\x18\x03\x20\x01(\x0e2#.google.container.v1.Operatio\
    n.TypeR\roperationType\x12=\n\x06status\x18\x04\x20\x01(\x0e2%.google.co\
    ntainer.v1.Operation.StatusR\x06status\x12\x16\n\x06detail\x18\x08\x20\
    \x01(\tR\x06detail\x12%\n\x0estatus_message\x18\x05\x20\x01(\tR\rstatusM\
    essage\x12\x1b\n\tself_link\x18\x06\x20\x01(\tR\x08selfLink\x12\x1f\n\
    \x0btarget_link\x18\x07\x20\x01(\tR\ntargetLink\x12\x1a\n\x08location\
    \x18\t\x20\x01(\tR\x08location\x12\x1d\n\nstart_time\x18\n\x20\x01(\tR\t\
    startTime\x12\x19\n\x08end_time\x18\x0b\x20\x01(\tR\x07endTime\x12S\n\
    \x12cluster_conditions\x18\r\x20\x03(\x0b2$.google.container.v1.StatusCo\
    nditionR\x11clusterConditions\x12U\n\x13nodepool_conditions\x18\x0e\x20\
    \x03(\x0b2$.google.container.v1.StatusConditionR\x12nodepoolConditions\"\
    R\n\x06Status\x12\x16\n\x12STATUS_UNSPECIFIED\x10\0\x12\x0b\n\x07PENDING\
    \x10\x01\x12\x0b\n\x07RUNNING\x10\x02\x12\x08\n\x04DONE\x10\x03\x12\x0c\
    \n\x08ABORTING\x10\x04\"\xfd\x02\n\x04Type\x12\x14\n\x10TYPE_UNSPECIFIED\
    \x10\0\x12\x12\n\x0eCREATE_CLUSTER\x10\x01\x12\x12\n\x0eDELETE_CLUSTER\
    \x10\x02\x12\x12\n\x0eUPGRADE_MASTER\x10\x03\x12\x11\n\rUPGRADE_NODES\
    \x10\x04\x12\x12\n\x0eREPAIR_CLUSTER\x10\x05\x12\x12\n\x0eUPDATE_CLUSTER\
    \x10\x06\x12\x14\n\x10CREATE_NODE_POOL\x10\x07\x12\x14\n\x10DELETE_NODE_\
    POOL\x10\x08\x12\x1c\n\x18SET_NODE_POOL_MANAGEMENT\x10\t\x12\x15\n\x11AU\
    TO_REPAIR_NODES\x10\n\x12\x16\n\x12AUTO_UPGRADE_NODES\x10\x0b\x12\x0e\n\
    \nSET_LABELS\x10\x0c\x12\x13\n\x0fSET_MASTER_AUTH\x10\r\x12\x16\n\x12SET\
    _NODE_POOL_SIZE\x10\x0e\x12\x16\n\x12SET_NETWORK_POLICY\x10\x0f\x12\x1a\
    \n\x16SET_MAINTENANCE_POLICY\x10\x10\"\xac\x01\n\x14CreateClusterRequest\
    \x12$\n\nproject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\
    \x12\x19\n\x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12\
    ;\n\x07cluster\x18\x03\x20\x01(\x0b2\x1c.google.container.v1.ClusterR\
    \x07clusterB\x03\xe0A\x02\x12\x16\n\x06parent\x18\x05\x20\x01(\tR\x06par\
    ent\"\x8e\x01\n\x11GetClusterRequest\x12$\n\nproject_id\x18\x01\x20\x01(\
    \tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\x01(\
    \tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\x20\x01(\tR\
    \tclusterIdB\x05\x18\x01\xe0A\x02\x12\x12\n\x04name\x18\x05\x20\x01(\tR\
    \x04name\"\xd2\x01\n\x14UpdateClusterRequest\x12$\n\nproject_id\x18\x01\
    \x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\
    \x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\
    \x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12?\n\x06update\x18\x04\
    \x20\x01(\x0b2\".google.container.v1.ClusterUpdateR\x06updateB\x03\xe0A\
    \x02\x12\x12\n\x04name\x18\x05\x20\x01(\tR\x04name\"\x87\x02\n\x15Update\
    NodePoolRequest\x12$\n\nproject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\
    \x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\
    \x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\
    \x01\xe0A\x02\x12'\n\x0cnode_pool_id\x18\x04\x20\x01(\tR\nnodePoolIdB\
    \x05\x18\x01\xe0A\x02\x12&\n\x0cnode_version\x18\x05\x20\x01(\tR\x0bnode\
    VersionB\x03\xe0A\x02\x12\"\n\nimage_type\x18\x06\x20\x01(\tR\timageType\
    B\x03\xe0A\x02\x12\x12\n\x04name\x18\x08\x20\x01(\tR\x04name\"\x94\x02\n\
    \x1dSetNodePoolAutoscalingRequest\x12$\n\nproject_id\x18\x01\x20\x01(\tR\
    \tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\x01(\tR\
    \x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\x20\x01(\tR\tc\
    lusterIdB\x05\x18\x01\xe0A\x02\x12'\n\x0cnode_pool_id\x18\x04\x20\x01(\t\
    R\nnodePoolIdB\x05\x18\x01\xe0A\x02\x12O\n\x0bautoscaling\x18\x05\x20\
    \x01(\x0b2(.google.container.v1.NodePoolAutoscalingR\x0bautoscalingB\x03\
    \xe0A\x02\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\"\xc1\x01\n\x18S\
    etLoggingServiceRequest\x12$\n\nproject_id\x18\x01\x20\x01(\tR\tprojectI\
    dB\x05\x18\x01\xe0A\x02\x12\x17\n\x04zone\x18\x02\x20\x01(\tR\x04zoneB\
    \x03\xe0A\x02\x12$\n\ncluster_id\x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\
    \x01\xe0A\x02\x12,\n\x0flogging_service\x18\x04\x20\x01(\tR\x0eloggingSe\
    rviceB\x03\xe0A\x02\x12\x12\n\x04name\x18\x05\x20\x01(\tR\x04name\"\xcc\
    \x01\n\x1bSetMonitoringServiceRequest\x12$\n\nproject_id\x18\x01\x20\x01\
    (\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\x01(\
    \tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\x20\x01(\tR\
    \tclusterIdB\x05\x18\x01\xe0A\x02\x122\n\x12monitoring_service\x18\x04\
    \x20\x01(\tR\x11monitoringServiceB\x03\xe0A\x02\x12\x12\n\x04name\x18\
    \x06\x20\x01(\tR\x04name\"\xe0\x01\n\x16SetAddonsConfigRequest\x12$\n\np\
    roject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\
    \x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\nclust\
    er_id\x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12K\n\raddon\
    s_config\x18\x04\x20\x01(\x0b2!.google.container.v1.AddonsConfigR\x0cadd\
    onsConfigB\x03\xe0A\x02\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\"\
    \xb3\x01\n\x13SetLocationsRequest\x12$\n\nproject_id\x18\x01\x20\x01(\tR\
    \tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\x01(\tR\
    \x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\x20\x01(\tR\tc\
    lusterIdB\x05\x18\x01\xe0A\x02\x12!\n\tlocations\x18\x04\x20\x03(\tR\tlo\
    cationsB\x03\xe0A\x02\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\"\
    \xbc\x01\n\x13UpdateMasterRequest\x12$\n\nproject_id\x18\x01\x20\x01(\tR\
    \tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\x01(\tR\
    \x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\x20\x01(\tR\tc\
    lusterIdB\x05\x18\x01\xe0A\x02\x12*\n\x0emaster_version\x18\x04\x20\x01(\
    \tR\rmasterVersionB\x03\xe0A\x02\x12\x12\n\x04name\x18\x07\x20\x01(\tR\
    \x04name\"\xf0\x02\n\x14SetMasterAuthRequest\x12$\n\nproject_id\x18\x01\
    \x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\
    \x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\
    \x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12M\n\x06action\x18\x04\
    \x20\x01(\x0e20.google.container.v1.SetMasterAuthRequest.ActionR\x06acti\
    onB\x03\xe0A\x02\x12<\n\x06update\x18\x05\x20\x01(\x0b2\x1f.google.conta\
    iner.v1.MasterAuthR\x06updateB\x03\xe0A\x02\x12\x12\n\x04name\x18\x07\
    \x20\x01(\tR\x04name\"P\n\x06Action\x12\x0b\n\x07UNKNOWN\x10\0\x12\x10\n\
    \x0cSET_PASSWORD\x10\x01\x12\x15\n\x11GENERATE_PASSWORD\x10\x02\x12\x10\
    \n\x0cSET_USERNAME\x10\x03\"\x91\x01\n\x14DeleteClusterRequest\x12$\n\np\
    roject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\
    \x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\nclust\
    er_id\x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12\x12\n\x04\
    name\x18\x04\x20\x01(\tR\x04name\"n\n\x13ListClustersRequest\x12$\n\npro\
    ject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\
    \x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12\x16\n\x06\
    parent\x18\x04\x20\x01(\tR\x06parent\"u\n\x14ListClustersResponse\x128\n\
    \x08clusters\x18\x01\x20\x03(\x0b2\x1c.google.container.v1.ClusterR\x08c\
    lusters\x12#\n\rmissing_zones\x18\x02\x20\x03(\tR\x0cmissingZones\"\x94\
    \x01\n\x13GetOperationRequest\x12$\n\nproject_id\x18\x01\x20\x01(\tR\tpr\
    ojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\x01(\tR\x04z\
    oneB\x05\x18\x01\xe0A\x02\x12(\n\x0coperation_id\x18\x03\x20\x01(\tR\x0b\
    operationIdB\x05\x18\x01\xe0A\x02\x12\x12\n\x04name\x18\x05\x20\x01(\tR\
    \x04name\"p\n\x15ListOperationsRequest\x12$\n\nproject_id\x18\x01\x20\
    \x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\
    \x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12\x16\n\x06parent\x18\x04\x20\
    \x01(\tR\x06parent\"\x97\x01\n\x16CancelOperationRequest\x12$\n\nproject\
    _id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zo\
    ne\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12(\n\x0coperation\
    _id\x18\x03\x20\x01(\tR\x0boperationIdB\x05\x18\x01\xe0A\x02\x12\x12\n\
    \x04name\x18\x04\x20\x01(\tR\x04name\"}\n\x16ListOperationsResponse\x12>\
    \n\noperations\x18\x01\x20\x03(\x0b2\x1e.google.container.v1.OperationR\
    \noperations\x12#\n\rmissing_zones\x18\x02\x20\x03(\tR\x0cmissingZones\"\
    m\n\x16GetServerConfigRequest\x12$\n\nproject_id\x18\x01\x20\x01(\tR\tpr\
    ojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\x01(\tR\x04z\
    oneB\x05\x18\x01\xe0A\x02\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name\
    \"\x84\x02\n\x0cServerConfig\x126\n\x17default_cluster_version\x18\x01\
    \x20\x01(\tR\x15defaultClusterVersion\x12.\n\x13valid_node_versions\x18\
    \x03\x20\x03(\tR\x11validNodeVersions\x12,\n\x12default_image_type\x18\
    \x04\x20\x01(\tR\x10defaultImageType\x12*\n\x11valid_image_types\x18\x05\
    \x20\x03(\tR\x0fvalidImageTypes\x122\n\x15valid_master_versions\x18\x06\
    \x20\x03(\tR\x13validMasterVersions\"\xd7\x01\n\x15CreateNodePoolRequest\
    \x12$\n\nproject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\
    \x12\x19\n\x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12\
    $\n\ncluster_id\x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12\
    ?\n\tnode_pool\x18\x04\x20\x01(\x0b2\x1d.google.container.v1.NodePoolR\
    \x08nodePoolB\x03\xe0A\x02\x12\x16\n\x06parent\x18\x06\x20\x01(\tR\x06pa\
    rent\"\xbb\x01\n\x15DeleteNodePoolRequest\x12$\n\nproject_id\x18\x01\x20\
    \x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\
    \x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\x20\
    \x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12'\n\x0cnode_pool_id\x18\x04\
    \x20\x01(\tR\nnodePoolIdB\x05\x18\x01\xe0A\x02\x12\x12\n\x04name\x18\x06\
    \x20\x01(\tR\x04name\"\x95\x01\n\x14ListNodePoolsRequest\x12$\n\nproject\
    _id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zo\
    ne\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\
    \x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12\x16\n\x06paren\
    t\x18\x05\x20\x01(\tR\x06parent\"\xb8\x01\n\x12GetNodePoolRequest\x12$\n\
    \nproject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\
    \x19\n\x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\
    \ncluster_id\x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12'\n\
    \x0cnode_pool_id\x18\x04\x20\x01(\tR\nnodePoolIdB\x05\x18\x01\xe0A\x02\
    \x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\"\xb1\x06\n\x08NodePool\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x127\n\x06config\x18\x02\
    \x20\x01(\x0b2\x1f.google.container.v1.NodeConfigR\x06config\x12,\n\x12i\
    nitial_node_count\x18\x03\x20\x01(\x05R\x10initialNodeCount\x12\x1b\n\ts\
    elf_link\x18d\x20\x01(\tR\x08selfLink\x12\x18\n\x07version\x18e\x20\x01(\
    \tR\x07version\x12.\n\x13instance_group_urls\x18f\x20\x03(\tR\x11instanc\
    eGroupUrls\x12<\n\x06status\x18g\x20\x01(\x0e2$.google.container.v1.Node\
    Pool.StatusR\x06status\x12%\n\x0estatus_message\x18h\x20\x01(\tR\rstatus\
    Message\x12J\n\x0bautoscaling\x18\x04\x20\x01(\x0b2(.google.container.v1\
    .NodePoolAutoscalingR\x0bautoscaling\x12C\n\nmanagement\x18\x05\x20\x01(\
    \x0b2#.google.container.v1.NodeManagementR\nmanagement\x12V\n\x13max_pod\
    s_constraint\x18\x06\x20\x01(\x0b2&.google.container.v1.MaxPodsConstrain\
    tR\x11maxPodsConstraint\x12D\n\nconditions\x18i\x20\x03(\x0b2$.google.co\
    ntainer.v1.StatusConditionR\nconditions\x12+\n\x12pod_ipv4_cidr_size\x18\
    \x07\x20\x01(\x05R\x0fpodIpv4CidrSize\"\x81\x01\n\x06Status\x12\x16\n\
    \x12STATUS_UNSPECIFIED\x10\0\x12\x10\n\x0cPROVISIONING\x10\x01\x12\x0b\n\
    \x07RUNNING\x10\x02\x12\x16\n\x12RUNNING_WITH_ERROR\x10\x03\x12\x0f\n\
    \x0bRECONCILING\x10\x04\x12\x0c\n\x08STOPPING\x10\x05\x12\t\n\x05ERROR\
    \x10\x06\"\xa6\x01\n\x0eNodeManagement\x12!\n\x0cauto_upgrade\x18\x01\
    \x20\x01(\x08R\x0bautoUpgrade\x12\x1f\n\x0bauto_repair\x18\x02\x20\x01(\
    \x08R\nautoRepair\x12P\n\x0fupgrade_options\x18\n\x20\x01(\x0b2'.google.\
    container.v1.AutoUpgradeOptionsR\x0eupgradeOptions\"m\n\x12AutoUpgradeOp\
    tions\x125\n\x17auto_upgrade_start_time\x18\x01\x20\x01(\tR\x14autoUpgra\
    deStartTime\x12\x20\n\x0bdescription\x18\x02\x20\x01(\tR\x0bdescription\
    \"~\n\x11MaintenancePolicy\x12>\n\x06window\x18\x01\x20\x01(\x0b2&.googl\
    e.container.v1.MaintenanceWindowR\x06window\x12)\n\x10resource_version\
    \x18\x03\x20\x01(\tR\x0fresourceVersion\"\xc2\x03\n\x11MaintenanceWindow\
    \x12g\n\x18daily_maintenance_window\x18\x02\x20\x01(\x0b2+.google.contai\
    ner.v1.DailyMaintenanceWindowH\0R\x16dailyMaintenanceWindow\x12U\n\x10re\
    curring_window\x18\x03\x20\x01(\x0b2(.google.container.v1.RecurringTimeW\
    indowH\0R\x0frecurringWindow\x12x\n\x16maintenance_exclusions\x18\x04\
    \x20\x03(\x0b2A.google.container.v1.MaintenanceWindow.MaintenanceExclusi\
    onsEntryR\x15maintenanceExclusions\x1ai\n\x1aMaintenanceExclusionsEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x125\n\x05value\x18\x02\x20\
    \x01(\x0b2\x1f.google.container.v1.TimeWindowR\x05value:\x028\x01B\x08\n\
    \x06policy\"~\n\nTimeWindow\x129\n\nstart_time\x18\x01\x20\x01(\x0b2\x1a\
    .google.protobuf.TimestampR\tstartTime\x125\n\x08end_time\x18\x02\x20\
    \x01(\x0b2\x1a.google.protobuf.TimestampR\x07endTime\"n\n\x13RecurringTi\
    meWindow\x127\n\x06window\x18\x01\x20\x01(\x0b2\x1f.google.container.v1.\
    TimeWindowR\x06window\x12\x1e\n\nrecurrence\x18\x02\x20\x01(\tR\nrecurre\
    nce\"S\n\x16DailyMaintenanceWindow\x12\x1d\n\nstart_time\x18\x02\x20\x01\
    (\tR\tstartTime\x12\x1a\n\x08duration\x18\x03\x20\x01(\tR\x08duration\"\
    \x8c\x02\n\x1cSetNodePoolManagementRequest\x12$\n\nproject_id\x18\x01\
    \x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\
    \x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\
    \x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12'\n\x0cnode_pool_id\x18\
    \x04\x20\x01(\tR\nnodePoolIdB\x05\x18\x01\xe0A\x02\x12H\n\nmanagement\
    \x18\x05\x20\x01(\x0b2#.google.container.v1.NodeManagementR\nmanagementB\
    \x03\xe0A\x02\x12\x12\n\x04name\x18\x07\x20\x01(\tR\x04name\"\xe0\x01\n\
    \x16SetNodePoolSizeRequest\x12$\n\nproject_id\x18\x01\x20\x01(\tR\tproje\
    ctIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\x01(\tR\x04zone\
    B\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\x20\x01(\tR\tclusterId\
    B\x05\x18\x01\xe0A\x02\x12'\n\x0cnode_pool_id\x18\x04\x20\x01(\tR\nnodeP\
    oolIdB\x05\x18\x01\xe0A\x02\x12\"\n\nnode_count\x18\x05\x20\x01(\x05R\tn\
    odeCountB\x03\xe0A\x02\x12\x12\n\x04name\x18\x07\x20\x01(\tR\x04name\"\
    \xc4\x01\n\x1eRollbackNodePoolUpgradeRequest\x12$\n\nproject_id\x18\x01\
    \x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\
    \x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\
    \x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12'\n\x0cnode_pool_id\x18\
    \x04\x20\x01(\tR\nnodePoolIdB\x05\x18\x01\xe0A\x02\x12\x12\n\x04name\x18\
    \x06\x20\x01(\tR\x04name\"U\n\x15ListNodePoolsResponse\x12<\n\nnode_pool\
    s\x18\x01\x20\x03(\x0b2\x1d.google.container.v1.NodePoolR\tnodePools\"\
    \xe9\x02\n\x12ClusterAutoscaling\x12@\n\x1cenable_node_autoprovisioning\
    \x18\x01\x20\x01(\x08R\x1aenableNodeAutoprovisioning\x12K\n\x0fresource_\
    limits\x18\x02\x20\x03(\x0b2\".google.container.v1.ResourceLimitR\x0eres\
    ourceLimits\x12\x84\x01\n#autoprovisioning_node_pool_defaults\x18\x04\
    \x20\x01(\x0b25.google.container.v1.AutoprovisioningNodePoolDefaultsR\
    \x20autoprovisioningNodePoolDefaults\x12=\n\x1aautoprovisioning_location\
    s\x18\x05\x20\x03(\tR\x19autoprovisioningLocations\"n\n\x20Autoprovision\
    ingNodePoolDefaults\x12!\n\x0coauth_scopes\x18\x01\x20\x03(\tR\x0boauthS\
    copes\x12'\n\x0fservice_account\x18\x02\x20\x01(\tR\x0eserviceAccount\"h\
    \n\rResourceLimit\x12#\n\rresource_type\x18\x01\x20\x01(\tR\x0cresourceT\
    ype\x12\x18\n\x07minimum\x18\x02\x20\x01(\x03R\x07minimum\x12\x18\n\x07m\
    aximum\x18\x03\x20\x01(\x03R\x07maximum\"\xa5\x01\n\x13NodePoolAutoscali\
    ng\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\x12$\n\x0emin_n\
    ode_count\x18\x02\x20\x01(\x05R\x0cminNodeCount\x12$\n\x0emax_node_count\
    \x18\x03\x20\x01(\x05R\x0cmaxNodeCount\x12(\n\x0fautoprovisioned\x18\x04\
    \x20\x01(\x08R\x0fautoprovisioned\"\xeb\x02\n\x10SetLabelsRequest\x12$\n\
    \nproject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\
    \x19\n\x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\
    \ncluster_id\x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12g\n\
    \x0fresource_labels\x18\x04\x20\x03(\x0b29.google.container.v1.SetLabels\
    Request.ResourceLabelsEntryR\x0eresourceLabelsB\x03\xe0A\x02\x120\n\x11l\
    abel_fingerprint\x18\x05\x20\x01(\tR\x10labelFingerprintB\x03\xe0A\x02\
    \x12\x12\n\x04name\x18\x07\x20\x01(\tR\x04name\x1aA\n\x13ResourceLabelsE\
    ntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value:\x028\x01\"\xb0\x01\n\x14SetLegacyAbacRequest\
    \x12$\n\nproject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\
    \x12\x19\n\x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12\
    $\n\ncluster_id\x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12\
    \x1d\n\x07enabled\x18\x04\x20\x01(\x08R\x07enabledB\x03\xe0A\x02\x12\x12\
    \n\x04name\x18\x06\x20\x01(\tR\x04name\"\xc2\x01\n\x16StartIPRotationReq\
    uest\x12$\n\nproject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\
    \x02\x12\x19\n\x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\
    \x12$\n\ncluster_id\x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\
    \x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\x12-\n\x12rotate_credenti\
    als\x18\x07\x20\x01(\x08R\x11rotateCredentials\"\x96\x01\n\x19CompleteIP\
    RotationRequest\x12$\n\nproject_id\x18\x01\x20\x01(\tR\tprojectIdB\x05\
    \x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\x20\x01(\tR\x04zoneB\x05\x18\
    \x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\x20\x01(\tR\tclusterIdB\x05\x18\
    \x01\xe0A\x02\x12\x12\n\x04name\x18\x07\x20\x01(\tR\x04name\"k\n\x11Acce\
    leratorConfig\x12+\n\x11accelerator_count\x18\x01\x20\x01(\x03R\x10accel\
    eratorCount\x12)\n\x10accelerator_type\x18\x02\x20\x01(\tR\x0faccelerato\
    rType\"\xe4\x01\n\x17SetNetworkPolicyRequest\x12$\n\nproject_id\x18\x01\
    \x20\x01(\tR\tprojectIdB\x05\x18\x01\xe0A\x02\x12\x19\n\x04zone\x18\x02\
    \x20\x01(\tR\x04zoneB\x05\x18\x01\xe0A\x02\x12$\n\ncluster_id\x18\x03\
    \x20\x01(\tR\tclusterIdB\x05\x18\x01\xe0A\x02\x12N\n\x0enetwork_policy\
    \x18\x04\x20\x01(\x0b2\".google.container.v1.NetworkPolicyR\rnetworkPoli\
    cyB\x03\xe0A\x02\x12\x12\n\x04name\x18\x06\x20\x01(\tR\x04name\"\xee\x01\
    \n\x1bSetMaintenancePolicyRequest\x12\"\n\nproject_id\x18\x01\x20\x01(\t\
    R\tprojectIdB\x03\xe0A\x02\x12\x17\n\x04zone\x18\x02\x20\x01(\tR\x04zone\
    B\x03\xe0A\x02\x12\"\n\ncluster_id\x18\x03\x20\x01(\tR\tclusterIdB\x03\
    \xe0A\x02\x12Z\n\x12maintenance_policy\x18\x04\x20\x01(\x0b2&.google.con\
    tainer.v1.MaintenancePolicyR\x11maintenancePolicyB\x03\xe0A\x02\x12\x12\
    \n\x04name\x18\x05\x20\x01(\tR\x04name\"\xf9\x01\n\x0fStatusCondition\
    \x12=\n\x04code\x18\x01\x20\x01(\x0e2).google.container.v1.StatusConditi\
    on.CodeR\x04code\x12\x18\n\x07message\x18\x02\x20\x01(\tR\x07message\"\
    \x8c\x01\n\x04Code\x12\x0b\n\x07UNKNOWN\x10\0\x12\x10\n\x0cGCE_STOCKOUT\
    \x10\x01\x12\x1f\n\x1bGKE_SERVICE_ACCOUNT_DELETED\x10\x02\x12\x16\n\x12G\
    CE_QUOTA_EXCEEDED\x10\x03\x12\x13\n\x0fSET_BY_OPERATOR\x10\x04\x12\x17\n\
    \x13CLOUD_KMS_KEY_ERROR\x10\x07\"\x8a\x01\n\rNetworkConfig\x12\x18\n\x07\
    network\x18\x01\x20\x01(\tR\x07network\x12\x1e\n\nsubnetwork\x18\x02\x20\
    \x01(\tR\nsubnetwork\x12?\n\x1cenable_intra_node_visibility\x18\x05\x20\
    \x01(\x08R\x19enableIntraNodeVisibility\"5\n\x19IntraNodeVisibilityConfi\
    g\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\">\n\x11MaxPodsC\
    onstraint\x12)\n\x11max_pods_per_node\x18\x01\x20\x01(\x03R\x0emaxPodsPe\
    rNode\"\xa8\x01\n\x12DatabaseEncryption\x12C\n\x05state\x18\x02\x20\x01(\
    \x0e2-.google.container.v1.DatabaseEncryption.StateR\x05state\x12\x19\n\
    \x08key_name\x18\x01\x20\x01(\tR\x07keyName\"2\n\x05State\x12\x0b\n\x07U\
    NKNOWN\x10\0\x12\r\n\tENCRYPTED\x10\x01\x12\r\n\tDECRYPTED\x10\x02\"\x8a\
    \x01\n\x1cListUsableSubnetworksRequest\x12\x16\n\x06parent\x18\x01\x20\
    \x01(\tR\x06parent\x12\x16\n\x06filter\x18\x02\x20\x01(\tR\x06filter\x12\
    \x1b\n\tpage_size\x18\x03\x20\x01(\x05R\x08pageSize\x12\x1d\n\npage_toke\
    n\x18\x04\x20\x01(\tR\tpageToken\"\x90\x01\n\x1dListUsableSubnetworksRes\
    ponse\x12G\n\x0bsubnetworks\x18\x01\x20\x03(\x0b2%.google.container.v1.U\
    sableSubnetworkR\x0bsubnetworks\x12&\n\x0fnext_page_token\x18\x02\x20\
    \x01(\tR\rnextPageToken\"\xa0\x02\n\x1eUsableSubnetworkSecondaryRange\
    \x12\x1d\n\nrange_name\x18\x01\x20\x01(\tR\trangeName\x12\"\n\rip_cidr_r\
    ange\x18\x02\x20\x01(\tR\x0bipCidrRange\x12R\n\x06status\x18\x03\x20\x01\
    (\x0e2:.google.container.v1.UsableSubnetworkSecondaryRange.StatusR\x06st\
    atus\"g\n\x06Status\x12\x0b\n\x07UNKNOWN\x10\0\x12\n\n\x06UNUSED\x10\x01\
    \x12\x12\n\x0eIN_USE_SERVICE\x10\x02\x12\x18\n\x14IN_USE_SHAREABLE_POD\
    \x10\x03\x12\x16\n\x12IN_USE_MANAGED_POD\x10\x04\"\xfc\x01\n\x10UsableSu\
    bnetwork\x12\x1e\n\nsubnetwork\x18\x01\x20\x01(\tR\nsubnetwork\x12\x18\n\
    \x07network\x18\x02\x20\x01(\tR\x07network\x12\"\n\rip_cidr_range\x18\
    \x03\x20\x01(\tR\x0bipCidrRange\x12c\n\x13secondary_ip_ranges\x18\x04\
    \x20\x03(\x0b23.google.container.v1.UsableSubnetworkSecondaryRangeR\x11s\
    econdaryIpRanges\x12%\n\x0estatus_message\x18\x05\x20\x01(\tR\rstatusMes\
    sage\"\xcf\x03\n\x19ResourceUsageExportConfig\x12u\n\x14bigquery_destina\
    tion\x18\x01\x20\x01(\x0b2B.google.container.v1.ResourceUsageExportConfi\
    g.BigQueryDestinationR\x13bigqueryDestination\x12C\n\x1eenable_network_e\
    gress_metering\x18\x02\x20\x01(\x08R\x1benableNetworkEgressMetering\x12\
    \x88\x01\n\x1bconsumption_metering_config\x18\x03\x20\x01(\x0b2H.google.\
    container.v1.ResourceUsageExportConfig.ConsumptionMeteringConfigR\x19con\
    sumptionMeteringConfig\x1a4\n\x13BigQueryDestination\x12\x1d\n\ndataset_\
    id\x18\x01\x20\x01(\tR\tdatasetId\x1a5\n\x19ConsumptionMeteringConfig\
    \x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled\"2\n\x16VerticalP\
    odAutoscaling\x12\x18\n\x07enabled\x18\x01\x20\x01(\x08R\x07enabled2\xa1\
    B\n\x0eClusterManager\x12\xde\x01\n\x0cListClusters\x12(.google.containe\
    r.v1.ListClustersRequest\x1a).google.container.v1.ListClustersResponse\"\
    y\x82\xd3\xe4\x93\x02a\x12,/v1/{parent=projects/*/locations/*}/clustersZ\
    1\x12//v1/projects/{project_id}/zones/{zone}/clusters\xdaA\x0fproject_id\
    ,zone\x12\xe6\x01\n\nGetCluster\x12&.google.container.v1.GetClusterReque\
    st\x1a\x1c.google.container.v1.Cluster\"\x91\x01\x82\xd3\xe4\x93\x02n\
    \x12,/v1/{name=projects/*/locations/*/clusters/*}Z>\x12</v1/projects/{pr\
    oject_id}/zones/{zone}/clusters/{cluster_id}\xdaA\x1aproject_id,zone,clu\
    ster_id\x12\xe4\x01\n\rCreateCluster\x12).google.container.v1.CreateClus\
    terRequest\x1a\x1e.google.container.v1.Operation\"\x87\x01\x82\xd3\xe4\
    \x93\x02g\",/v1/{parent=projects/*/locations/*}/clusters:\x01*Z4\"//v1/p\
    rojects/{project_id}/zones/{zone}/clusters:\x01*\xdaA\x17project_id,zone\
    ,cluster\x12\xfb\x01\n\rUpdateCluster\x12).google.container.v1.UpdateClu\
    sterRequest\x1a\x1e.google.container.v1.Operation\"\x9e\x01\x82\xd3\xe4\
    \x93\x02t\x1a,/v1/{name=projects/*/locations/*/clusters/*}:\x01*ZA\x1a</\
    v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}:\x01*\xdaA!p\
    roject_id,zone,cluster_id,update\x12\x86\x02\n\x0eUpdateNodePool\x12*.go\
    ogle.container.v1.UpdateNodePoolRequest\x1a\x1e.google.container.v1.Oper\
    ation\"\xa7\x01\x82\xd3\xe4\x93\x02\xa0\x01\x1a8/v1/{name=projects/*/loc\
    ations/*/clusters/*/nodePools/*}:\x01*Za\"\\/v1/projects/{project_id}/zo\
    nes/{zone}/clusters/{cluster_id}/nodePools/{node_pool_id}/update:\x01*\
    \x12\xaa\x02\n\x16SetNodePoolAutoscaling\x122.google.container.v1.SetNod\
    ePoolAutoscalingRequest\x1a\x1e.google.container.v1.Operation\"\xbb\x01\
    \x82\xd3\xe4\x93\x02\xb4\x01\"G/v1/{name=projects/*/locations/*/clusters\
    /*/nodePools/*}:setAutoscaling:\x01*Zf\"a/v1/projects/{project_id}/zones\
    /{zone}/clusters/{cluster_id}/nodePools/{node_pool_id}/autoscaling:\x01*\
    \x12\xa0\x02\n\x11SetLoggingService\x12-.google.container.v1.SetLoggingS\
    erviceRequest\x1a\x1e.google.container.v1.Operation\"\xbb\x01\x82\xd3\
    \xe4\x93\x02\x87\x01\"7/v1/{name=projects/*/locations/*/clusters/*}:setL\
    ogging:\x01*ZI\"D/v1/projects/{project_id}/zones/{zone}/clusters/{cluste\
    r_id}/logging:\x01*\xdaA*project_id,zone,cluster_id,logging_service\x12\
    \xaf\x02\n\x14SetMonitoringService\x120.google.container.v1.SetMonitorin\
    gServiceRequest\x1a\x1e.google.container.v1.Operation\"\xc4\x01\x82\xd3\
    \xe4\x93\x02\x8d\x01\":/v1/{name=projects/*/locations/*/clusters/*}:setM\
    onitoring:\x01*ZL\"G/v1/projects/{project_id}/zones/{zone}/clusters/{clu\
    ster_id}/monitoring:\x01*\xdaA-project_id,zone,cluster_id,monitoring_ser\
    vice\x12\x98\x02\n\x0fSetAddonsConfig\x12+.google.container.v1.SetAddons\
    ConfigRequest\x1a\x1e.google.container.v1.Operation\"\xb7\x01\x82\xd3\
    \xe4\x93\x02\x85\x01\"6/v1/{name=projects/*/locations/*/clusters/*}:setA\
    ddons:\x01*ZH\"C/v1/projects/{project_id}/zones/{zone}/clusters/{cluster\
    _id}/addons:\x01*\xdaA(project_id,zone,cluster_id,addons_config\x12\x94\
    \x02\n\x0cSetLocations\x12(.google.container.v1.SetLocationsRequest\x1a\
    \x1e.google.container.v1.Operation\"\xb9\x01\x82\xd3\xe4\x93\x02\x8b\x01\
    \"9/v1/{name=projects/*/locations/*/clusters/*}:setLocations:\x01*ZK\"F/\
    v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/locations:\
    \x01*\xdaA$project_id,zone,cluster_id,locations\x12\x96\x02\n\x0cUpdateM\
    aster\x12(.google.container.v1.UpdateMasterRequest\x1a\x1e.google.contai\
    ner.v1.Operation\"\xbb\x01\x82\xd3\xe4\x93\x02\x88\x01\"9/v1/{name=proje\
    cts/*/locations/*/clusters/*}:updateMaster:\x01*ZH\"C/v1/projects/{proje\
    ct_id}/zones/{zone}/clusters/{cluster_id}/master:\x01*\xdaA)project_id,z\
    one,cluster_id,master_version\x12\xf4\x01\n\rSetMasterAuth\x12).google.c\
    ontainer.v1.SetMasterAuthRequest\x1a\x1e.google.container.v1.Operation\"\
    \x97\x01\x82\xd3\xe4\x93\x02\x90\x01\":/v1/{name=projects/*/locations/*/\
    clusters/*}:setMasterAuth:\x01*ZO\"J/v1/projects/{project_id}/zones/{zon\
    e}/clusters/{cluster_id}:setMasterAuth:\x01*\x12\xee\x01\n\rDeleteCluste\
    r\x12).google.container.v1.DeleteClusterRequest\x1a\x1e.google.container\
    .v1.Operation\"\x91\x01\x82\xd3\xe4\x93\x02n*,/v1/{name=projects/*/locat\
    ions/*/clusters/*}Z>*</v1/projects/{project_id}/zones/{zone}/clusters/{c\
    luster_id}\xdaA\x1aproject_id,zone,cluster_id\x12\xe8\x01\n\x0eListOpera\
    tions\x12*.google.container.v1.ListOperationsRequest\x1a+.google.contain\
    er.v1.ListOperationsResponse\"}\x82\xd3\xe4\x93\x02e\x12./v1/{parent=pro\
    jects/*/locations/*}/operationsZ3\x121/v1/projects/{project_id}/zones/{z\
    one}/operations\xdaA\x0fproject_id,zone\x12\xf4\x01\n\x0cGetOperation\
    \x12(.google.container.v1.GetOperationRequest\x1a\x1e.google.container.v\
    1.Operation\"\x99\x01\x82\xd3\xe4\x93\x02t\x12./v1/{name=projects/*/loca\
    tions/*/operations/*}ZB\x12@/v1/projects/{project_id}/zones/{zone}/opera\
    tions/{operation_id}\xdaA\x1cproject_id,zone,operation_id\x12\x87\x02\n\
    \x0fCancelOperation\x12+.google.container.v1.CancelOperationRequest\x1a\
    \x16.google.protobuf.Empty\"\xae\x01\x82\xd3\xe4\x93\x02\x88\x01\"5/v1/{\
    name=projects/*/locations/*/operations/*}:cancel:\x01*ZL\"G/v1/projects/\
    {project_id}/zones/{zone}/operations/{operation_id}:cancel:\x01*\xdaA\
    \x1cproject_id,zone,operation_id\x12\xe2\x01\n\x0fGetServerConfig\x12+.g\
    oogle.container.v1.GetServerConfigRequest\x1a!.google.container.v1.Serve\
    rConfig\"\x7f\x82\xd3\xe4\x93\x02g\x12./v1/{name=projects/*/locations/*}\
    /serverConfigZ5\x123/v1/projects/{project_id}/zones/{zone}/serverconfig\
    \xdaA\x0fproject_id,zone\x12\x91\x02\n\rListNodePools\x12).google.contai\
    ner.v1.ListNodePoolsRequest\x1a*.google.container.v1.ListNodePoolsRespon\
    se\"\xa8\x01\x82\xd3\xe4\x93\x02\x84\x01\x128/v1/{parent=projects/*/loca\
    tions/*/clusters/*}/nodePoolsZH\x12F/v1/projects/{project_id}/zones/{zon\
    e}/clusters/{cluster_id}/nodePools\xdaA\x1aproject_id,zone,cluster_id\
    \x12\x9c\x02\n\x0bGetNodePool\x12'.google.container.v1.GetNodePoolReques\
    t\x1a\x1d.google.container.v1.NodePool\"\xc4\x01\x82\xd3\xe4\x93\x02\x93\
    \x01\x128/v1/{name=projects/*/locations/*/clusters/*/nodePools/*}ZW\x12U\
    /v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools/{\
    node_pool_id}\xdaA'project_id,zone,cluster_id,node_pool_id\x12\x97\x02\n\
    \x0eCreateNodePool\x12*.google.container.v1.CreateNodePoolRequest\x1a\
    \x1e.google.container.v1.Operation\"\xb8\x01\x82\xd3\xe4\x93\x02\x8a\x01\
    \"8/v1/{parent=projects/*/locations/*/clusters/*}/nodePools:\x01*ZK\"F/v\
    1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools:\
    \x01*\xdaA$project_id,zone,cluster_id,node_pool\x12\xa3\x02\n\x0eDeleteN\
    odePool\x12*.google.container.v1.DeleteNodePoolRequest\x1a\x1e.google.co\
    ntainer.v1.Operation\"\xc4\x01\x82\xd3\xe4\x93\x02\x93\x01*8/v1/{name=pr\
    ojects/*/locations/*/clusters/*/nodePools/*}ZW*U/v1/projects/{project_id\
    }/zones/{zone}/clusters/{cluster_id}/nodePools/{node_pool_id}\xdaA'proje\
    ct_id,zone,cluster_id,node_pool_id\x12\xcd\x02\n\x17RollbackNodePoolUpgr\
    ade\x123.google.container.v1.RollbackNodePoolUpgradeRequest\x1a\x1e.goog\
    le.container.v1.Operation\"\xdc\x01\x82\xd3\xe4\x93\x02\xab\x01\"A/v1/{n\
    ame=projects/*/locations/*/clusters/*/nodePools/*}:rollback:\x01*Zc\"^/v\
    1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/nodePools/{no\
    de_pool_id}:rollback:\x01*\xdaA'project_id,zone,cluster_id,node_pool_id\
    \x12\xa9\x02\n\x15SetNodePoolManagement\x121.google.container.v1.SetNode\
    PoolManagementRequest\x1a\x1e.google.container.v1.Operation\"\xbc\x01\
    \x82\xd3\xe4\x93\x02\xb5\x01\"F/v1/{name=projects/*/locations/*/clusters\
    /*/nodePools/*}:setManagement:\x01*Zh\"c/v1/projects/{project_id}/zones/\
    {zone}/clusters/{cluster_id}/nodePools/{node_pool_id}/setManagement:\x01\
    *\x12\xf1\x01\n\tSetLabels\x12%.google.container.v1.SetLabelsRequest\x1a\
    \x1e.google.container.v1.Operation\"\x9c\x01\x82\xd3\xe4\x93\x02\x95\x01\
    \">/v1/{name=projects/*/locations/*/clusters/*}:setResourceLabels:\x01*Z\
    P\"K/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}/resourc\
    eLabels:\x01*\x12\x96\x02\n\rSetLegacyAbac\x12).google.container.v1.SetL\
    egacyAbacRequest\x1a\x1e.google.container.v1.Operation\"\xb9\x01\x82\xd3\
    \xe4\x93\x02\x8d\x01\":/v1/{name=projects/*/locations/*/clusters/*}:setL\
    egacyAbac:\x01*ZL\"G/v1/projects/{project_id}/zones/{zone}/clusters/{clu\
    ster_id}/legacyAbac:\x01*\xdaA\"project_id,zone,cluster_id,enabled\x12\
    \x99\x02\n\x0fStartIPRotation\x12+.google.container.v1.StartIPRotationRe\
    quest\x1a\x1e.google.container.v1.Operation\"\xb8\x01\x82\xd3\xe4\x93\
    \x02\x94\x01\"</v1/{name=projects/*/locations/*/clusters/*}:startIpRotat\
    ion:\x01*ZQ\"L/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_i\
    d}:startIpRotation:\x01*\xdaA\x1aproject_id,zone,cluster_id\x12\xa5\x02\
    \n\x12CompleteIPRotation\x12..google.container.v1.CompleteIPRotationRequ\
    est\x1a\x1e.google.container.v1.Operation\"\xbe\x01\x82\xd3\xe4\x93\x02\
    \x9a\x01\"?/v1/{name=projects/*/locations/*/clusters/*}:completeIpRotati\
    on:\x01*ZT\"O/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id\
    }:completeIpRotation:\x01*\xdaA\x1aproject_id,zone,cluster_id\x12\x91\
    \x02\n\x0fSetNodePoolSize\x12+.google.container.v1.SetNodePoolSizeReques\
    t\x1a\x1e.google.container.v1.Operation\"\xb0\x01\x82\xd3\xe4\x93\x02\
    \xa9\x01\"@/v1/{name=projects/*/locations/*/clusters/*/nodePools/*}:setS\
    ize:\x01*Zb\"]/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_i\
    d}/nodePools/{node_pool_id}/setSize:\x01*\x12\xac\x02\n\x10SetNetworkPol\
    icy\x12,.google.container.v1.SetNetworkPolicyRequest\x1a\x1e.google.cont\
    ainer.v1.Operation\"\xc9\x01\x82\xd3\xe4\x93\x02\x96\x01\"=/v1/{name=pro\
    jects/*/locations/*/clusters/*}:setNetworkPolicy:\x01*ZR\"M/v1/projects/\
    {project_id}/zones/{zone}/clusters/{cluster_id}:setNetworkPolicy:\x01*\
    \xdaA)project_id,zone,cluster_id,network_policy\x12\xc0\x02\n\x14SetMain\
    tenancePolicy\x120.google.container.v1.SetMaintenancePolicyRequest\x1a\
    \x1e.google.container.v1.Operation\"\xd5\x01\x82\xd3\xe4\x93\x02\x9e\x01\
    \"A/v1/{name=projects/*/locations/*/clusters/*}:setMaintenancePolicy:\
    \x01*ZV\"Q/v1/projects/{project_id}/zones/{zone}/clusters/{cluster_id}:s\
    etMaintenancePolicy:\x01*\xdaA-project_id,zone,cluster_id,maintenance_po\
    licy\x12\xbc\x01\n\x15ListUsableSubnetworks\x121.google.container.v1.Lis\
    tUsableSubnetworksRequest\x1a2.google.container.v1.ListUsableSubnetworks\
    Response\"<\x82\xd3\xe4\x93\x026\x124/v1/{parent=projects/*}/aggregated/\
    usableSubnetworks\x1aL\xd2A.https://www.googleapis.com/auth/cloud-platfo\
    rm\xcaA\x18container.googleapis.comB\xa6\x01\n\x17com.google.container.v\
    1B\x13ClusterServiceProtoP\x01Z<google.golang.org/genproto/googleapis/co\
    ntainer/v1;container\xaa\x02\x19Google.Cloud.Container.V1\xca\x02\x19Goo\
    gle\\Cloud\\Container\\V1J\xd9\xdf\x06\n\x07\x12\x05\x0f\0\xe0\x17\x01\n\
    \xbe\x04\n\x01\x0c\x12\x03\x0f\0\x122\xb3\x04\x20Copyright\x202019\x20Go\
    ogle\x20LLC.\n\n\x20Licensed\x20under\x20the\x20Apache\x20License,\x20Ve\
    rsion\x202.0\x20(the\x20\"License\");\n\x20you\x20may\x20not\x20use\x20t\
    his\x20file\x20except\x20in\x20compliance\x20with\x20the\x20License.\n\
    \x20You\x20may\x20obtain\x20a\x20copy\x20of\x20the\x20License\x20at\n\n\
    \x20\x20\x20\x20\x20http://www.apache.org/licenses/LICENSE-2.0\n\n\x20Un\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\n\x20distributed\x20under\x20the\x20License\x20\
    is\x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\n\x20WITHOUT\x20\
    WARRANTIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20expres\
    s\x20or\x20implied.\n\x20See\x20the\x20License\x20for\x20the\x20specific\
    \x20language\x20governing\x20permissions\x20and\n\x20limitations\x20unde\
    r\x20the\x20License.\n\n\n\x08\n\x01\x02\x12\x03\x11\0\x1c\n\t\n\x02\x03\
    \0\x12\x03\x13\0&\n\t\n\x02\x03\x01\x12\x03\x14\0!\n\t\n\x02\x03\x02\x12\
    \x03\x15\0)\n\t\n\x02\x03\x03\x12\x03\x16\0%\n\t\n\x02\x03\x04\x12\x03\
    \x17\0)\n\x08\n\x01\x08\x12\x03\x19\06\n\t\n\x02\x08%\x12\x03\x19\06\n\
    \x08\n\x01\x08\x12\x03\x1a\0S\n\t\n\x02\x08\x0b\x12\x03\x1a\0S\n\x08\n\
    \x01\x08\x12\x03\x1b\0\"\n\t\n\x02\x08\n\x12\x03\x1b\0\"\n\x08\n\x01\x08\
    \x12\x03\x1c\04\n\t\n\x02\x08\x08\x12\x03\x1c\04\n\x08\n\x01\x08\x12\x03\
    \x1d\00\n\t\n\x02\x08\x01\x12\x03\x1d\00\n\x08\n\x01\x08\x12\x03\x1e\06\
    \n\t\n\x02\x08)\x12\x03\x1e\06\n:\n\x02\x06\0\x12\x05!\0\xb1\x03\x01\x1a\
    -\x20Google\x20Kubernetes\x20Engine\x20Cluster\x20Manager\x20v1\n\n\n\n\
    \x03\x06\0\x01\x12\x03!\x08\x16\n\n\n\x03\x06\0\x03\x12\x03\"\x02@\n\x0c\
    \n\x05\x06\0\x03\x99\x08\x12\x03\"\x02@\n\n\n\x03\x06\0\x03\x12\x03#\x02\
    V\n\x0c\n\x05\x06\0\x03\x9a\x08\x12\x03#\x02V\na\n\x04\x06\0\x02\0\x12\
    \x04'\x02/\x03\x1aS\x20Lists\x20all\x20clusters\x20owned\x20by\x20a\x20p\
    roject\x20in\x20either\x20the\x20specified\x20zone\x20or\x20all\n\x20zon\
    es.\n\n\x0c\n\x05\x06\0\x02\0\x01\x12\x03'\x06\x12\n\x0c\n\x05\x06\0\x02\
    \0\x02\x12\x03'\x13&\n\x0c\n\x05\x06\0\x02\0\x03\x12\x03'1E\n\r\n\x05\
    \x06\0\x02\0\x04\x12\x04(\x04-\x06\n\x11\n\t\x06\0\x02\0\x04\xb0\xca\xbc\
    \"\x12\x04(\x04-\x06\n\x0c\n\x05\x06\0\x02\0\x04\x12\x03.\x04=\n\x0f\n\
    \x08\x06\0\x02\0\x04\x9b\x08\0\x12\x03.\x04=\n7\n\x04\x06\0\x02\x01\x12\
    \x042\x02:\x03\x1a)\x20Gets\x20the\x20details\x20of\x20a\x20specific\x20\
    cluster.\n\n\x0c\n\x05\x06\0\x02\x01\x01\x12\x032\x06\x10\n\x0c\n\x05\
    \x06\0\x02\x01\x02\x12\x032\x11\"\n\x0c\n\x05\x06\0\x02\x01\x03\x12\x032\
    -4\n\r\n\x05\x06\0\x02\x01\x04\x12\x043\x048\x06\n\x11\n\t\x06\0\x02\x01\
    \x04\xb0\xca\xbc\"\x12\x043\x048\x06\n\x0c\n\x05\x06\0\x02\x01\x04\x12\
    \x039\x04H\n\x0f\n\x08\x06\0\x02\x01\x04\x9b\x08\0\x12\x039\x04H\n\xa8\
    \x04\n\x04\x06\0\x02\x02\x12\x04I\x02S\x03\x1a\x99\x04\x20Creates\x20a\
    \x20cluster,\x20consisting\x20of\x20the\x20specified\x20number\x20and\
    \x20type\x20of\x20Google\n\x20Compute\x20Engine\x20instances.\n\n\x20By\
    \x20default,\x20the\x20cluster\x20is\x20created\x20in\x20the\x20project'\
    s\n\x20[default\x20network](/compute/docs/networks-and-firewalls#network\
    s).\n\n\x20One\x20firewall\x20is\x20added\x20for\x20the\x20cluster.\x20A\
    fter\x20cluster\x20creation,\n\x20the\x20Kubelet\x20creates\x20routes\
    \x20for\x20each\x20node\x20to\x20allow\x20the\x20containers\n\x20on\x20t\
    hat\x20node\x20to\x20communicate\x20with\x20all\x20other\x20instances\
    \x20in\x20the\n\x20cluster.\n\n\x20Finally,\x20an\x20entry\x20is\x20adde\
    d\x20to\x20the\x20project's\x20global\x20metadata\x20indicating\n\x20whi\
    ch\x20CIDR\x20range\x20the\x20cluster\x20is\x20using.\n\n\x0c\n\x05\x06\
    \0\x02\x02\x01\x12\x03I\x06\x13\n\x0c\n\x05\x06\0\x02\x02\x02\x12\x03I\
    \x14(\n\x0c\n\x05\x06\0\x02\x02\x03\x12\x03I3<\n\r\n\x05\x06\0\x02\x02\
    \x04\x12\x04J\x04Q\x06\n\x11\n\t\x06\0\x02\x02\x04\xb0\xca\xbc\"\x12\x04\
    J\x04Q\x06\n\x0c\n\x05\x06\0\x02\x02\x04\x12\x03R\x04E\n\x0f\n\x08\x06\0\
    \x02\x02\x04\x9b\x08\0\x12\x03R\x04E\n;\n\x04\x06\0\x02\x03\x12\x04V\x02\
    `\x03\x1a-\x20Updates\x20the\x20settings\x20of\x20a\x20specific\x20clust\
    er.\n\n\x0c\n\x05\x06\0\x02\x03\x01\x12\x03V\x06\x13\n\x0c\n\x05\x06\0\
    \x02\x03\x02\x12\x03V\x14(\n\x0c\n\x05\x06\0\x02\x03\x03\x12\x03V3<\n\r\
    \n\x05\x06\0\x02\x03\x04\x12\x04W\x04^\x06\n\x11\n\t\x06\0\x02\x03\x04\
    \xb0\xca\xbc\"\x12\x04W\x04^\x06\n\x0c\n\x05\x06\0\x02\x03\x04\x12\x03_\
    \x04O\n\x0f\n\x08\x06\0\x02\x03\x04\x9b\x08\0\x12\x03_\x04O\nR\n\x04\x06\
    \0\x02\x04\x12\x04c\x02l\x03\x1aD\x20Updates\x20the\x20version\x20and/or\
    \x20image\x20type\x20for\x20the\x20specified\x20node\x20pool.\n\n\x0c\n\
    \x05\x06\0\x02\x04\x01\x12\x03c\x06\x14\n\x0c\n\x05\x06\0\x02\x04\x02\
    \x12\x03c\x15*\n\x0c\n\x05\x06\0\x02\x04\x03\x12\x03c5>\n\r\n\x05\x06\0\
    \x02\x04\x04\x12\x04d\x04k\x06\n\x11\n\t\x06\0\x02\x04\x04\xb0\xca\xbc\"\
    \x12\x04d\x04k\x06\nJ\n\x04\x06\0\x02\x05\x12\x04o\x02x\x03\x1a<\x20Sets\
    \x20the\x20autoscaling\x20settings\x20for\x20the\x20specified\x20node\
    \x20pool.\n\n\x0c\n\x05\x06\0\x02\x05\x01\x12\x03o\x06\x1c\n\x0c\n\x05\
    \x06\0\x02\x05\x02\x12\x03o\x1d:\n\x0c\n\x05\x06\0\x02\x05\x03\x12\x03oE\
    N\n\r\n\x05\x06\0\x02\x05\x04\x12\x04p\x04w\x06\n\x11\n\t\x06\0\x02\x05\
    \x04\xb0\xca\xbc\"\x12\x04p\x04w\x06\nA\n\x04\x06\0\x02\x06\x12\x05{\x02\
    \x85\x01\x03\x1a2\x20Sets\x20the\x20logging\x20service\x20for\x20a\x20sp\
    ecific\x20cluster.\n\n\x0c\n\x05\x06\0\x02\x06\x01\x12\x03{\x06\x17\n\
    \x0c\n\x05\x06\0\x02\x06\x02\x12\x03{\x180\n\x0c\n\x05\x06\0\x02\x06\x03\
    \x12\x03{;D\n\x0e\n\x05\x06\0\x02\x06\x04\x12\x05|\x04\x83\x01\x06\n\x12\
    \n\t\x06\0\x02\x06\x04\xb0\xca\xbc\"\x12\x05|\x04\x83\x01\x06\n\r\n\x05\
    \x06\0\x02\x06\x04\x12\x04\x84\x01\x04X\n\x10\n\x08\x06\0\x02\x06\x04\
    \x9b\x08\0\x12\x04\x84\x01\x04X\nE\n\x04\x06\0\x02\x07\x12\x06\x88\x01\
    \x02\x92\x01\x03\x1a5\x20Sets\x20the\x20monitoring\x20service\x20for\x20\
    a\x20specific\x20cluster.\n\n\r\n\x05\x06\0\x02\x07\x01\x12\x04\x88\x01\
    \x06\x1a\n\r\n\x05\x06\0\x02\x07\x02\x12\x04\x88\x01\x1b6\n\r\n\x05\x06\
    \0\x02\x07\x03\x12\x04\x88\x01AJ\n\x0f\n\x05\x06\0\x02\x07\x04\x12\x06\
    \x89\x01\x04\x90\x01\x06\n\x13\n\t\x06\0\x02\x07\x04\xb0\xca\xbc\"\x12\
    \x06\x89\x01\x04\x90\x01\x06\n\r\n\x05\x06\0\x02\x07\x04\x12\x04\x91\x01\
    \x04[\n\x10\n\x08\x06\0\x02\x07\x04\x9b\x08\0\x12\x04\x91\x01\x04[\n9\n\
    \x04\x06\0\x02\x08\x12\x06\x95\x01\x02\x9f\x01\x03\x1a)\x20Sets\x20the\
    \x20addons\x20for\x20a\x20specific\x20cluster.\n\n\r\n\x05\x06\0\x02\x08\
    \x01\x12\x04\x95\x01\x06\x15\n\r\n\x05\x06\0\x02\x08\x02\x12\x04\x95\x01\
    \x16,\n\r\n\x05\x06\0\x02\x08\x03\x12\x04\x95\x017@\n\x0f\n\x05\x06\0\
    \x02\x08\x04\x12\x06\x96\x01\x04\x9d\x01\x06\n\x13\n\t\x06\0\x02\x08\x04\
    \xb0\xca\xbc\"\x12\x06\x96\x01\x04\x9d\x01\x06\n\r\n\x05\x06\0\x02\x08\
    \x04\x12\x04\x9e\x01\x04V\n\x10\n\x08\x06\0\x02\x08\x04\x9b\x08\0\x12\
    \x04\x9e\x01\x04V\n<\n\x04\x06\0\x02\t\x12\x06\xa2\x01\x02\xac\x01\x03\
    \x1a,\x20Sets\x20the\x20locations\x20for\x20a\x20specific\x20cluster.\n\
    \n\r\n\x05\x06\0\x02\t\x01\x12\x04\xa2\x01\x06\x12\n\r\n\x05\x06\0\x02\t\
    \x02\x12\x04\xa2\x01\x13&\n\r\n\x05\x06\0\x02\t\x03\x12\x04\xa2\x011:\n\
    \x0f\n\x05\x06\0\x02\t\x04\x12\x06\xa3\x01\x04\xaa\x01\x06\n\x13\n\t\x06\
    \0\x02\t\x04\xb0\xca\xbc\"\x12\x06\xa3\x01\x04\xaa\x01\x06\n\r\n\x05\x06\
    \0\x02\t\x04\x12\x04\xab\x01\x04R\n\x10\n\x08\x06\0\x02\t\x04\x9b\x08\0\
    \x12\x04\xab\x01\x04R\n<\n\x04\x06\0\x02\n\x12\x06\xaf\x01\x02\xb9\x01\
    \x03\x1a,\x20Updates\x20the\x20master\x20for\x20a\x20specific\x20cluster\
    .\n\n\r\n\x05\x06\0\x02\n\x01\x12\x04\xaf\x01\x06\x12\n\r\n\x05\x06\0\
    \x02\n\x02\x12\x04\xaf\x01\x13&\n\r\n\x05\x06\0\x02\n\x03\x12\x04\xaf\
    \x011:\n\x0f\n\x05\x06\0\x02\n\x04\x12\x06\xb0\x01\x04\xb7\x01\x06\n\x13\
    \n\t\x06\0\x02\n\x04\xb0\xca\xbc\"\x12\x06\xb0\x01\x04\xb7\x01\x06\n\r\n\
    \x05\x06\0\x02\n\x04\x12\x04\xb8\x01\x04W\n\x10\n\x08\x06\0\x02\n\x04\
    \x9b\x08\0\x12\x04\xb8\x01\x04W\n\xb9\x01\n\x04\x06\0\x02\x0b\x12\x06\
    \xbe\x01\x02\xc7\x01\x03\x1a\xa8\x01\x20Sets\x20master\x20auth\x20materi\
    als.\x20Currently\x20supports\x20changing\x20the\x20admin\x20password\n\
    \x20or\x20a\x20specific\x20cluster,\x20either\x20via\x20password\x20gene\
    ration\x20or\x20explicitly\x20setting\n\x20the\x20password.\n\n\r\n\x05\
    \x06\0\x02\x0b\x01\x12\x04\xbe\x01\x06\x13\n\r\n\x05\x06\0\x02\x0b\x02\
    \x12\x04\xbe\x01\x14(\n\r\n\x05\x06\0\x02\x0b\x03\x12\x04\xbe\x013<\n\
    \x0f\n\x05\x06\0\x02\x0b\x04\x12\x06\xbf\x01\x04\xc6\x01\x06\n\x13\n\t\
    \x06\0\x02\x0b\x04\xb0\xca\xbc\"\x12\x06\xbf\x01\x04\xc6\x01\x06\n\xf7\
    \x02\n\x04\x06\0\x02\x0c\x12\x06\xd2\x01\x02\xda\x01\x03\x1a\xe6\x02\x20\
    Deletes\x20the\x20cluster,\x20including\x20the\x20Kubernetes\x20endpoint\
    \x20and\x20all\x20worker\n\x20nodes.\n\n\x20Firewalls\x20and\x20routes\
    \x20that\x20were\x20configured\x20during\x20cluster\x20creation\n\x20are\
    \x20also\x20deleted.\n\n\x20Other\x20Google\x20Compute\x20Engine\x20reso\
    urces\x20that\x20might\x20be\x20in\x20use\x20by\x20the\x20cluster,\n\x20\
    such\x20as\x20load\x20balancer\x20resources,\x20are\x20not\x20deleted\
    \x20if\x20they\x20weren't\x20present\n\x20when\x20the\x20cluster\x20was\
    \x20initially\x20created.\n\n\r\n\x05\x06\0\x02\x0c\x01\x12\x04\xd2\x01\
    \x06\x13\n\r\n\x05\x06\0\x02\x0c\x02\x12\x04\xd2\x01\x14(\n\r\n\x05\x06\
    \0\x02\x0c\x03\x12\x04\xd2\x013<\n\x0f\n\x05\x06\0\x02\x0c\x04\x12\x06\
    \xd3\x01\x04\xd8\x01\x06\n\x13\n\t\x06\0\x02\x0c\x04\xb0\xca\xbc\"\x12\
    \x06\xd3\x01\x04\xd8\x01\x06\n\r\n\x05\x06\0\x02\x0c\x04\x12\x04\xd9\x01\
    \x04H\n\x10\n\x08\x06\0\x02\x0c\x04\x9b\x08\0\x12\x04\xd9\x01\x04H\nT\n\
    \x04\x06\0\x02\r\x12\x06\xdd\x01\x02\xe5\x01\x03\x1aD\x20Lists\x20all\
    \x20operations\x20in\x20a\x20project\x20in\x20a\x20specific\x20zone\x20o\
    r\x20all\x20zones.\n\n\r\n\x05\x06\0\x02\r\x01\x12\x04\xdd\x01\x06\x14\n\
    \r\n\x05\x06\0\x02\r\x02\x12\x04\xdd\x01\x15*\n\r\n\x05\x06\0\x02\r\x03\
    \x12\x04\xdd\x015K\n\x0f\n\x05\x06\0\x02\r\x04\x12\x06\xde\x01\x04\xe3\
    \x01\x06\n\x13\n\t\x06\0\x02\r\x04\xb0\xca\xbc\"\x12\x06\xde\x01\x04\xe3\
    \x01\x06\n\r\n\x05\x06\0\x02\r\x04\x12\x04\xe4\x01\x04=\n\x10\n\x08\x06\
    \0\x02\r\x04\x9b\x08\0\x12\x04\xe4\x01\x04=\n/\n\x04\x06\0\x02\x0e\x12\
    \x06\xe8\x01\x02\xf0\x01\x03\x1a\x1f\x20Gets\x20the\x20specified\x20oper\
    ation.\n\n\r\n\x05\x06\0\x02\x0e\x01\x12\x04\xe8\x01\x06\x12\n\r\n\x05\
    \x06\0\x02\x0e\x02\x12\x04\xe8\x01\x13&\n\r\n\x05\x06\0\x02\x0e\x03\x12\
    \x04\xe8\x011:\n\x0f\n\x05\x06\0\x02\x0e\x04\x12\x06\xe9\x01\x04\xee\x01\
    \x06\n\x13\n\t\x06\0\x02\x0e\x04\xb0\xca\xbc\"\x12\x06\xe9\x01\x04\xee\
    \x01\x06\n\r\n\x05\x06\0\x02\x0e\x04\x12\x04\xef\x01\x04J\n\x10\n\x08\
    \x06\0\x02\x0e\x04\x9b\x08\0\x12\x04\xef\x01\x04J\n2\n\x04\x06\0\x02\x0f\
    \x12\x06\xf3\x01\x02\xfd\x01\x03\x1a\"\x20Cancels\x20the\x20specified\
    \x20operation.\n\n\r\n\x05\x06\0\x02\x0f\x01\x12\x04\xf3\x01\x06\x15\n\r\
    \n\x05\x06\0\x02\x0f\x02\x12\x04\xf3\x01\x16,\n\r\n\x05\x06\0\x02\x0f\
    \x03\x12\x04\xf3\x017L\n\x0f\n\x05\x06\0\x02\x0f\x04\x12\x06\xf4\x01\x04\
    \xfb\x01\x06\n\x13\n\t\x06\0\x02\x0f\x04\xb0\xca\xbc\"\x12\x06\xf4\x01\
    \x04\xfb\x01\x06\n\r\n\x05\x06\0\x02\x0f\x04\x12\x04\xfc\x01\x04J\n\x10\
    \n\x08\x06\0\x02\x0f\x04\x9b\x08\0\x12\x04\xfc\x01\x04J\nX\n\x04\x06\0\
    \x02\x10\x12\x06\x80\x02\x02\x88\x02\x03\x1aH\x20Returns\x20configuratio\
    n\x20info\x20about\x20the\x20Google\x20Kubernetes\x20Engine\x20service.\
    \n\n\r\n\x05\x06\0\x02\x10\x01\x12\x04\x80\x02\x06\x15\n\r\n\x05\x06\0\
    \x02\x10\x02\x12\x04\x80\x02\x16,\n\r\n\x05\x06\0\x02\x10\x03\x12\x04\
    \x80\x027C\n\x0f\n\x05\x06\0\x02\x10\x04\x12\x06\x81\x02\x04\x86\x02\x06\
    \n\x13\n\t\x06\0\x02\x10\x04\xb0\xca\xbc\"\x12\x06\x81\x02\x04\x86\x02\
    \x06\n\r\n\x05\x06\0\x02\x10\x04\x12\x04\x87\x02\x04=\n\x10\n\x08\x06\0\
    \x02\x10\x04\x9b\x08\0\x12\x04\x87\x02\x04=\n5\n\x04\x06\0\x02\x11\x12\
    \x06\x8b\x02\x02\x93\x02\x03\x1a%\x20Lists\x20the\x20node\x20pools\x20fo\
    r\x20a\x20cluster.\n\n\r\n\x05\x06\0\x02\x11\x01\x12\x04\x8b\x02\x06\x13\
    \n\r\n\x05\x06\0\x02\x11\x02\x12\x04\x8b\x02\x14(\n\r\n\x05\x06\0\x02\
    \x11\x03\x12\x04\x8b\x023H\n\x0f\n\x05\x06\0\x02\x11\x04\x12\x06\x8c\x02\
    \x04\x91\x02\x06\n\x13\n\t\x06\0\x02\x11\x04\xb0\xca\xbc\"\x12\x06\x8c\
    \x02\x04\x91\x02\x06\n\r\n\x05\x06\0\x02\x11\x04\x12\x04\x92\x02\x04H\n\
    \x10\n\x08\x06\0\x02\x11\x04\x9b\x08\0\x12\x04\x92\x02\x04H\n4\n\x04\x06\
    \0\x02\x12\x12\x06\x96\x02\x02\x9e\x02\x03\x1a$\x20Retrieves\x20the\x20r\
    equested\x20node\x20pool.\n\n\r\n\x05\x06\0\x02\x12\x01\x12\x04\x96\x02\
    \x06\x11\n\r\n\x05\x06\0\x02\x12\x02\x12\x04\x96\x02\x12$\n\r\n\x05\x06\
    \0\x02\x12\x03\x12\x04\x96\x02/7\n\x0f\n\x05\x06\0\x02\x12\x04\x12\x06\
    \x97\x02\x04\x9c\x02\x06\n\x13\n\t\x06\0\x02\x12\x04\xb0\xca\xbc\"\x12\
    \x06\x97\x02\x04\x9c\x02\x06\n\r\n\x05\x06\0\x02\x12\x04\x12\x04\x9d\x02\
    \x04U\n\x10\n\x08\x06\0\x02\x12\x04\x9b\x08\0\x12\x04\x9d\x02\x04U\n4\n\
    \x04\x06\0\x02\x13\x12\x06\xa1\x02\x02\xab\x02\x03\x1a$\x20Creates\x20a\
    \x20node\x20pool\x20for\x20a\x20cluster.\n\n\r\n\x05\x06\0\x02\x13\x01\
    \x12\x04\xa1\x02\x06\x14\n\r\n\x05\x06\0\x02\x13\x02\x12\x04\xa1\x02\x15\
    *\n\r\n\x05\x06\0\x02\x13\x03\x12\x04\xa1\x025>\n\x0f\n\x05\x06\0\x02\
    \x13\x04\x12\x06\xa2\x02\x04\xa9\x02\x06\n\x13\n\t\x06\0\x02\x13\x04\xb0\
    \xca\xbc\"\x12\x06\xa2\x02\x04\xa9\x02\x06\n\r\n\x05\x06\0\x02\x13\x04\
    \x12\x04\xaa\x02\x04R\n\x10\n\x08\x06\0\x02\x13\x04\x9b\x08\0\x12\x04\
    \xaa\x02\x04R\n5\n\x04\x06\0\x02\x14\x12\x06\xae\x02\x02\xb6\x02\x03\x1a\
    %\x20Deletes\x20a\x20node\x20pool\x20from\x20a\x20cluster.\n\n\r\n\x05\
    \x06\0\x02\x14\x01\x12\x04\xae\x02\x06\x14\n\r\n\x05\x06\0\x02\x14\x02\
    \x12\x04\xae\x02\x15*\n\r\n\x05\x06\0\x02\x14\x03\x12\x04\xae\x025>\n\
    \x0f\n\x05\x06\0\x02\x14\x04\x12\x06\xaf\x02\x04\xb4\x02\x06\n\x13\n\t\
    \x06\0\x02\x14\x04\xb0\xca\xbc\"\x12\x06\xaf\x02\x04\xb4\x02\x06\n\r\n\
    \x05\x06\0\x02\x14\x04\x12\x04\xb5\x02\x04U\n\x10\n\x08\x06\0\x02\x14\
    \x04\x9b\x08\0\x12\x04\xb5\x02\x04U\n\x91\x01\n\x04\x06\0\x02\x15\x12\
    \x06\xba\x02\x02\xc4\x02\x03\x1a\x80\x01\x20Rolls\x20back\x20a\x20previo\
    usly\x20Aborted\x20or\x20Failed\x20NodePool\x20upgrade.\n\x20This\x20mak\
    es\x20no\x20changes\x20if\x20the\x20last\x20upgrade\x20successfully\x20c\
    ompleted.\n\n\r\n\x05\x06\0\x02\x15\x01\x12\x04\xba\x02\x06\x1d\n\r\n\
    \x05\x06\0\x02\x15\x02\x12\x04\xba\x02\x1e<\n\r\n\x05\x06\0\x02\x15\x03\
    \x12\x04\xba\x02GP\n\x0f\n\x05\x06\0\x02\x15\x04\x12\x06\xbb\x02\x04\xc2\
    \x02\x06\n\x13\n\t\x06\0\x02\x15\x04\xb0\xca\xbc\"\x12\x06\xbb\x02\x04\
    \xc2\x02\x06\n\r\n\x05\x06\0\x02\x15\x04\x12\x04\xc3\x02\x04U\n\x10\n\
    \x08\x06\0\x02\x15\x04\x9b\x08\0\x12\x04\xc3\x02\x04U\nB\n\x04\x06\0\x02\
    \x16\x12\x06\xc7\x02\x02\xd0\x02\x03\x1a2\x20Sets\x20the\x20NodeManageme\
    nt\x20options\x20for\x20a\x20node\x20pool.\n\n\r\n\x05\x06\0\x02\x16\x01\
    \x12\x04\xc7\x02\x06\x1b\n\r\n\x05\x06\0\x02\x16\x02\x12\x04\xc7\x02\x1c\
    8\n\r\n\x05\x06\0\x02\x16\x03\x12\x04\xc7\x02CL\n\x0f\n\x05\x06\0\x02\
    \x16\x04\x12\x06\xc8\x02\x04\xcf\x02\x06\n\x13\n\t\x06\0\x02\x16\x04\xb0\
    \xca\xbc\"\x12\x06\xc8\x02\x04\xcf\x02\x06\n+\n\x04\x06\0\x02\x17\x12\
    \x06\xd3\x02\x02\xdc\x02\x03\x1a\x1b\x20Sets\x20labels\x20on\x20a\x20clu\
    ster.\n\n\r\n\x05\x06\0\x02\x17\x01\x12\x04\xd3\x02\x06\x0f\n\r\n\x05\
    \x06\0\x02\x17\x02\x12\x04\xd3\x02\x10\x20\n\r\n\x05\x06\0\x02\x17\x03\
    \x12\x04\xd3\x02+4\n\x0f\n\x05\x06\0\x02\x17\x04\x12\x06\xd4\x02\x04\xdb\
    \x02\x06\n\x13\n\t\x06\0\x02\x17\x04\xb0\xca\xbc\"\x12\x06\xd4\x02\x04\
    \xdb\x02\x06\nT\n\x04\x06\0\x02\x18\x12\x06\xdf\x02\x02\xe9\x02\x03\x1aD\
    \x20Enables\x20or\x20disables\x20the\x20ABAC\x20authorization\x20mechani\
    sm\x20on\x20a\x20cluster.\n\n\r\n\x05\x06\0\x02\x18\x01\x12\x04\xdf\x02\
    \x06\x13\n\r\n\x05\x06\0\x02\x18\x02\x12\x04\xdf\x02\x14(\n\r\n\x05\x06\
    \0\x02\x18\x03\x12\x04\xdf\x023<\n\x0f\n\x05\x06\0\x02\x18\x04\x12\x06\
    \xe0\x02\x04\xe7\x02\x06\n\x13\n\t\x06\0\x02\x18\x04\xb0\xca\xbc\"\x12\
    \x06\xe0\x02\x04\xe7\x02\x06\n\r\n\x05\x06\0\x02\x18\x04\x12\x04\xe8\x02\
    \x04P\n\x10\n\x08\x06\0\x02\x18\x04\x9b\x08\0\x12\x04\xe8\x02\x04P\n,\n\
    \x04\x06\0\x02\x19\x12\x06\xec\x02\x02\xf6\x02\x03\x1a\x1c\x20Starts\x20\
    master\x20IP\x20rotation.\n\n\r\n\x05\x06\0\x02\x19\x01\x12\x04\xec\x02\
    \x06\x15\n\r\n\x05\x06\0\x02\x19\x02\x12\x04\xec\x02\x16,\n\r\n\x05\x06\
    \0\x02\x19\x03\x12\x04\xec\x027@\n\x0f\n\x05\x06\0\x02\x19\x04\x12\x06\
    \xed\x02\x04\xf4\x02\x06\n\x13\n\t\x06\0\x02\x19\x04\xb0\xca\xbc\"\x12\
    \x06\xed\x02\x04\xf4\x02\x06\n\r\n\x05\x06\0\x02\x19\x04\x12\x04\xf5\x02\
    \x04H\n\x10\n\x08\x06\0\x02\x19\x04\x9b\x08\0\x12\x04\xf5\x02\x04H\n/\n\
    \x04\x06\0\x02\x1a\x12\x06\xf9\x02\x02\x83\x03\x03\x1a\x1f\x20Completes\
    \x20master\x20IP\x20rotation.\n\n\r\n\x05\x06\0\x02\x1a\x01\x12\x04\xf9\
    \x02\x06\x18\n\r\n\x05\x06\0\x02\x1a\x02\x12\x04\xf9\x02\x192\n\r\n\x05\
    \x06\0\x02\x1a\x03\x12\x04\xf9\x02=F\n\x0f\n\x05\x06\0\x02\x1a\x04\x12\
    \x06\xfa\x02\x04\x81\x03\x06\n\x13\n\t\x06\0\x02\x1a\x04\xb0\xca\xbc\"\
    \x12\x06\xfa\x02\x04\x81\x03\x06\n\r\n\x05\x06\0\x02\x1a\x04\x12\x04\x82\
    \x03\x04H\n\x10\n\x08\x06\0\x02\x1a\x04\x9b\x08\0\x12\x04\x82\x03\x04H\n\
    9\n\x04\x06\0\x02\x1b\x12\x06\x86\x03\x02\x8f\x03\x03\x1a)\x20Sets\x20th\
    e\x20size\x20for\x20a\x20specific\x20node\x20pool.\n\n\r\n\x05\x06\0\x02\
    \x1b\x01\x12\x04\x86\x03\x06\x15\n\r\n\x05\x06\0\x02\x1b\x02\x12\x04\x86\
    \x03\x16,\n\r\n\x05\x06\0\x02\x1b\x03\x12\x04\x86\x037@\n\x0f\n\x05\x06\
    \0\x02\x1b\x04\x12\x06\x87\x03\x04\x8e\x03\x06\n\x13\n\t\x06\0\x02\x1b\
    \x04\xb0\xca\xbc\"\x12\x06\x87\x03\x04\x8e\x03\x06\nC\n\x04\x06\0\x02\
    \x1c\x12\x06\x92\x03\x02\x9c\x03\x03\x1a3\x20Enables\x20or\x20disables\
    \x20Network\x20Policy\x20for\x20a\x20cluster.\n\n\r\n\x05\x06\0\x02\x1c\
    \x01\x12\x04\x92\x03\x06\x16\n\r\n\x05\x06\0\x02\x1c\x02\x12\x04\x92\x03\
    \x17.\n\r\n\x05\x06\0\x02\x1c\x03\x12\x04\x92\x039B\n\x0f\n\x05\x06\0\
    \x02\x1c\x04\x12\x06\x93\x03\x04\x9a\x03\x06\n\x13\n\t\x06\0\x02\x1c\x04\
    \xb0\xca\xbc\"\x12\x06\x93\x03\x04\x9a\x03\x06\n\r\n\x05\x06\0\x02\x1c\
    \x04\x12\x04\x9b\x03\x04W\n\x10\n\x08\x06\0\x02\x1c\x04\x9b\x08\0\x12\
    \x04\x9b\x03\x04W\n<\n\x04\x06\0\x02\x1d\x12\x06\x9f\x03\x02\xa9\x03\x03\
    \x1a,\x20Sets\x20the\x20maintenance\x20policy\x20for\x20a\x20cluster.\n\
    \n\r\n\x05\x06\0\x02\x1d\x01\x12\x04\x9f\x03\x06\x1a\n\r\n\x05\x06\0\x02\
    \x1d\x02\x12\x04\x9f\x03\x1b6\n\r\n\x05\x06\0\x02\x1d\x03\x12\x04\x9f\
    \x03AJ\n\x0f\n\x05\x06\0\x02\x1d\x04\x12\x06\xa0\x03\x04\xa7\x03\x06\n\
    \x13\n\t\x06\0\x02\x1d\x04\xb0\xca\xbc\"\x12\x06\xa0\x03\x04\xa7\x03\x06\
    \n\r\n\x05\x06\0\x02\x1d\x04\x12\x04\xa8\x03\x04[\n\x10\n\x08\x06\0\x02\
    \x1d\x04\x9b\x08\0\x12\x04\xa8\x03\x04[\nW\n\x04\x06\0\x02\x1e\x12\x06\
    \xac\x03\x02\xb0\x03\x03\x1aG\x20Lists\x20subnetworks\x20that\x20are\x20\
    usable\x20for\x20creating\x20clusters\x20in\x20a\x20project.\n\n\r\n\x05\
    \x06\0\x02\x1e\x01\x12\x04\xac\x03\x06\x1b\n\r\n\x05\x06\0\x02\x1e\x02\
    \x12\x04\xac\x03\x1c8\n\r\n\x05\x06\0\x02\x1e\x03\x12\x04\xac\x03C`\n\
    \x0f\n\x05\x06\0\x02\x1e\x04\x12\x06\xad\x03\x04\xaf\x03\x06\n\x13\n\t\
    \x06\0\x02\x1e\x04\xb0\xca\xbc\"\x12\x06\xad\x03\x04\xaf\x03\x06\n@\n\
    \x02\x04\0\x12\x06\xb4\x03\0\xb4\x04\x01\x1a2\x20Parameters\x20that\x20d\
    escribe\x20the\x20nodes\x20in\x20a\x20cluster.\n\n\x0b\n\x03\x04\0\x01\
    \x12\x04\xb4\x03\x08\x12\n\xba\x01\n\x04\x04\0\x02\0\x12\x04\xbb\x03\x02\
    \x1a\x1a\xab\x01\x20The\x20name\x20of\x20a\x20Google\x20Compute\x20Engin\
    e\x20[machine\n\x20type](/compute/docs/machine-types)\x20(e.g.\n\x20`n1-\
    standard-1`).\n\n\x20If\x20unspecified,\x20the\x20default\x20machine\x20\
    type\x20is\n\x20`n1-standard-1`.\n\n\r\n\x05\x04\0\x02\0\x05\x12\x04\xbb\
    \x03\x02\x08\n\r\n\x05\x04\0\x02\0\x01\x12\x04\xbb\x03\t\x15\n\r\n\x05\
    \x04\0\x02\0\x03\x12\x04\xbb\x03\x18\x19\n\xa4\x01\n\x04\x04\0\x02\x01\
    \x12\x04\xc1\x03\x02\x19\x1a\x95\x01\x20Size\x20of\x20the\x20disk\x20att\
    ached\x20to\x20each\x20node,\x20specified\x20in\x20GB.\n\x20The\x20small\
    est\x20allowed\x20disk\x20size\x20is\x2010GB.\n\n\x20If\x20unspecified,\
    \x20the\x20default\x20disk\x20size\x20is\x20100GB.\n\n\r\n\x05\x04\0\x02\
    \x01\x05\x12\x04\xc1\x03\x02\x07\n\r\n\x05\x04\0\x02\x01\x01\x12\x04\xc1\
    \x03\x08\x14\n\r\n\x05\x04\0\x02\x01\x03\x12\x04\xc1\x03\x17\x18\n\xf9\
    \x04\n\x04\x04\0\x02\x02\x12\x04\xd1\x03\x02#\x1a\xea\x04\x20The\x20set\
    \x20of\x20Google\x20API\x20scopes\x20to\x20be\x20made\x20available\x20on\
    \x20all\x20of\x20the\n\x20node\x20VMs\x20under\x20the\x20\"default\"\x20\
    service\x20account.\n\n\x20The\x20following\x20scopes\x20are\x20recommen\
    ded,\x20but\x20not\x20required,\x20and\x20by\x20default\x20are\n\x20not\
    \x20included:\n\n\x20*\x20`https://www.googleapis.com/auth/compute`\x20i\
    s\x20required\x20for\x20mounting\n\x20persistent\x20storage\x20on\x20you\
    r\x20nodes.\n\x20*\x20`https://www.googleapis.com/auth/devstorage.read_o\
    nly`\x20is\x20required\x20for\n\x20communicating\x20with\x20**gcr.io**\n\
    \x20(the\x20[Google\x20Container\x20Registry](/container-registry/)).\n\
    \n\x20If\x20unspecified,\x20no\x20scopes\x20are\x20added,\x20unless\x20C\
    loud\x20Logging\x20or\x20Cloud\n\x20Monitoring\x20are\x20enabled,\x20in\
    \x20which\x20case\x20their\x20required\x20scopes\x20will\x20be\x20added.\
    \n\n\r\n\x05\x04\0\x02\x02\x04\x12\x04\xd1\x03\x02\n\n\r\n\x05\x04\0\x02\
    \x02\x05\x12\x04\xd1\x03\x0b\x11\n\r\n\x05\x04\0\x02\x02\x01\x12\x04\xd1\
    \x03\x12\x1e\n\r\n\x05\x04\0\x02\x02\x03\x12\x04\xd1\x03!\"\n\xa2\x01\n\
    \x04\x04\0\x02\x03\x12\x04\xd5\x03\x02\x1d\x1a\x93\x01\x20The\x20Google\
    \x20Cloud\x20Platform\x20Service\x20Account\x20to\x20be\x20used\x20by\
    \x20the\x20node\x20VMs.\x20If\n\x20no\x20Service\x20Account\x20is\x20spe\
    cified,\x20the\x20\"default\"\x20service\x20account\x20is\x20used.\n\n\r\
    \n\x05\x04\0\x02\x03\x05\x12\x04\xd5\x03\x02\x08\n\r\n\x05\x04\0\x02\x03\
    \x01\x12\x04\xd5\x03\t\x18\n\r\n\x05\x04\0\x02\x03\x03\x12\x04\xd5\x03\
    \x1b\x1c\n\x9c\x08\n\x04\x04\0\x02\x04\x12\x04\xf6\x03\x02#\x1a\x8d\x08\
    \x20The\x20metadata\x20key/value\x20pairs\x20assigned\x20to\x20instances\
    \x20in\x20the\x20cluster.\n\n\x20Keys\x20must\x20conform\x20to\x20the\
    \x20regexp\x20[a-zA-Z0-9-_]+\x20and\x20be\x20less\x20than\x20128\x20byte\
    s\n\x20in\x20length.\x20These\x20are\x20reflected\x20as\x20part\x20of\
    \x20a\x20URL\x20in\x20the\x20metadata\x20server.\n\x20Additionally,\x20t\
    o\x20avoid\x20ambiguity,\x20keys\x20must\x20not\x20conflict\x20with\x20a\
    ny\x20other\n\x20metadata\x20keys\x20for\x20the\x20project\x20or\x20be\
    \x20one\x20of\x20the\x20reserved\x20keys:\n\x20\x20\"cluster-location\"\
    \n\x20\x20\"cluster-name\"\n\x20\x20\"cluster-uid\"\n\x20\x20\"configure\
    -sh\"\n\x20\x20\"containerd-configure-sh\"\n\x20\x20\"enable-os-login\"\
    \n\x20\x20\"gci-update-strategy\"\n\x20\x20\"gci-ensure-gke-docker\"\n\
    \x20\x20\"instance-template\"\n\x20\x20\"kube-env\"\n\x20\x20\"startup-s\
    cript\"\n\x20\x20\"user-data\"\n\x20\x20\"disable-address-manager\"\n\
    \x20\x20\"windows-startup-script-ps1\"\n\x20\x20\"common-psm1\"\n\x20\
    \x20\"k8s-node-setup-psm1\"\n\x20\x20\"install-ssh-psm1\"\n\x20\x20\"use\
    r-profile-psm1\"\n\x20\x20\"serial-port-logging-enable\"\n\n\x20Values\
    \x20are\x20free-form\x20strings,\x20and\x20only\x20have\x20meaning\x20as\
    \x20interpreted\x20by\n\x20the\x20image\x20running\x20in\x20the\x20insta\
    nce.\x20The\x20only\x20restriction\x20placed\x20on\x20them\x20is\n\x20th\
    at\x20each\x20value's\x20size\x20must\x20be\x20less\x20than\x20or\x20equ\
    al\x20to\x2032\x20KB.\n\n\x20The\x20total\x20size\x20of\x20all\x20keys\
    \x20and\x20values\x20must\x20be\x20less\x20than\x20512\x20KB.\n\n\r\n\
    \x05\x04\0\x02\x04\x06\x12\x04\xf6\x03\x02\x15\n\r\n\x05\x04\0\x02\x04\
    \x01\x12\x04\xf6\x03\x16\x1e\n\r\n\x05\x04\0\x02\x04\x03\x12\x04\xf6\x03\
    !\"\n~\n\x04\x04\0\x02\x05\x12\x04\xfa\x03\x02\x18\x1ap\x20The\x20image\
    \x20type\x20to\x20use\x20for\x20this\x20node.\x20Note\x20that\x20for\x20\
    a\x20given\x20image\x20type,\n\x20the\x20latest\x20version\x20of\x20it\
    \x20will\x20be\x20used.\n\n\r\n\x05\x04\0\x02\x05\x05\x12\x04\xfa\x03\
    \x02\x08\n\r\n\x05\x04\0\x02\x05\x01\x12\x04\xfa\x03\t\x13\n\r\n\x05\x04\
    \0\x02\x05\x03\x12\x04\xfa\x03\x16\x17\n\xfd\x03\n\x04\x04\0\x02\x06\x12\
    \x04\x84\x04\x02!\x1a\xee\x03\x20The\x20map\x20of\x20Kubernetes\x20label\
    s\x20(key/value\x20pairs)\x20to\x20be\x20applied\x20to\x20each\x20node.\
    \n\x20These\x20will\x20added\x20in\x20addition\x20to\x20any\x20default\
    \x20label(s)\x20that\n\x20Kubernetes\x20may\x20apply\x20to\x20the\x20nod\
    e.\n\x20In\x20case\x20of\x20conflict\x20in\x20label\x20keys,\x20the\x20a\
    pplied\x20set\x20may\x20differ\x20depending\x20on\n\x20the\x20Kubernetes\
    \x20version\x20--\x20it's\x20best\x20to\x20assume\x20the\x20behavior\x20\
    is\x20undefined\n\x20and\x20conflicts\x20should\x20be\x20avoided.\n\x20F\
    or\x20more\x20information,\x20including\x20usage\x20and\x20the\x20valid\
    \x20values,\x20see:\n\x20https://kubernetes.io/docs/concepts/overview/wo\
    rking-with-objects/labels/\n\n\r\n\x05\x04\0\x02\x06\x06\x12\x04\x84\x04\
    \x02\x15\n\r\n\x05\x04\0\x02\x06\x01\x12\x04\x84\x04\x16\x1c\n\r\n\x05\
    \x04\0\x02\x06\x03\x12\x04\x84\x04\x1f\x20\n\x88\x02\n\x04\x04\0\x02\x07\
    \x12\x04\x8c\x04\x02\x1c\x1a\xf9\x01\x20The\x20number\x20of\x20local\x20\
    SSD\x20disks\x20to\x20be\x20attached\x20to\x20the\x20node.\n\n\x20The\
    \x20limit\x20for\x20this\x20value\x20is\x20dependent\x20upon\x20the\x20m\
    aximum\x20number\x20of\n\x20disks\x20available\x20on\x20a\x20machine\x20\
    per\x20zone.\x20See:\n\x20https://cloud.google.com/compute/docs/disks/lo\
    cal-ssd\n\x20for\x20more\x20information.\n\n\r\n\x05\x04\0\x02\x07\x05\
    \x12\x04\x8c\x04\x02\x07\n\r\n\x05\x04\0\x02\x07\x01\x12\x04\x8c\x04\x08\
    \x17\n\r\n\x05\x04\0\x02\x07\x03\x12\x04\x8c\x04\x1a\x1b\n\x85\x02\n\x04\
    \x04\0\x02\x08\x12\x04\x92\x04\x02\x1b\x1a\xf6\x01\x20The\x20list\x20of\
    \x20instance\x20tags\x20applied\x20to\x20all\x20nodes.\x20Tags\x20are\
    \x20used\x20to\x20identify\n\x20valid\x20sources\x20or\x20targets\x20for\
    \x20network\x20firewalls\x20and\x20are\x20specified\x20by\n\x20the\x20cl\
    ient\x20during\x20cluster\x20or\x20node\x20pool\x20creation.\x20Each\x20\
    tag\x20within\x20the\x20list\n\x20must\x20comply\x20with\x20RFC1035.\n\n\
    \r\n\x05\x04\0\x02\x08\x04\x12\x04\x92\x04\x02\n\n\r\n\x05\x04\0\x02\x08\
    \x05\x12\x04\x92\x04\x0b\x11\n\r\n\x05\x04\0\x02\x08\x01\x12\x04\x92\x04\
    \x12\x16\n\r\n\x05\x04\0\x02\x08\x03\x12\x04\x92\x04\x19\x1a\n\xc3\x01\n\
    \x04\x04\0\x02\t\x12\x04\x97\x04\x02\x18\x1a\xb4\x01\x20Whether\x20the\
    \x20nodes\x20are\x20created\x20as\x20preemptible\x20VM\x20instances.\x20\
    See:\n\x20https://cloud.google.com/compute/docs/instances/preemptible\
    \x20for\x20more\n\x20information\x20about\x20preemptible\x20VM\x20instan\
    ces.\n\n\r\n\x05\x04\0\x02\t\x05\x12\x04\x97\x04\x02\x06\n\r\n\x05\x04\0\
    \x02\t\x01\x12\x04\x97\x04\x07\x12\n\r\n\x05\x04\0\x02\t\x03\x12\x04\x97\
    \x04\x15\x17\n\xab\x01\n\x04\x04\0\x02\n\x12\x04\x9c\x04\x02/\x1a\x9c\
    \x01\x20A\x20list\x20of\x20hardware\x20accelerators\x20to\x20be\x20attac\
    hed\x20to\x20each\x20node.\n\x20See\x20https://cloud.google.com/compute/\
    docs/gpus\x20for\x20more\x20information\x20about\n\x20support\x20for\x20\
    GPUs.\n\n\r\n\x05\x04\0\x02\n\x04\x12\x04\x9c\x04\x02\n\n\r\n\x05\x04\0\
    \x02\n\x06\x12\x04\x9c\x04\x0b\x1c\n\r\n\x05\x04\0\x02\n\x01\x12\x04\x9c\
    \x04\x1d)\n\r\n\x05\x04\0\x02\n\x03\x12\x04\x9c\x04,.\n\x91\x01\n\x04\
    \x04\0\x02\x0b\x12\x04\xa1\x04\x02\x18\x1a\x82\x01\x20Type\x20of\x20the\
    \x20disk\x20attached\x20to\x20each\x20node\x20(e.g.\x20'pd-standard'\x20\
    or\x20'pd-ssd')\n\n\x20If\x20unspecified,\x20the\x20default\x20disk\x20t\
    ype\x20is\x20'pd-standard'\n\n\r\n\x05\x04\0\x02\x0b\x05\x12\x04\xa1\x04\
    \x02\x08\n\r\n\x05\x04\0\x02\x0b\x01\x12\x04\xa1\x04\t\x12\n\r\n\x05\x04\
    \0\x02\x0b\x03\x12\x04\xa1\x04\x15\x17\n\xcf\x03\n\x04\x04\0\x02\x0c\x12\
    \x04\xaa\x04\x02\x1f\x1a\xc0\x03\x20Minimum\x20CPU\x20platform\x20to\x20\
    be\x20used\x20by\x20this\x20instance.\x20The\x20instance\x20may\x20be\n\
    \x20scheduled\x20on\x20the\x20specified\x20or\x20newer\x20CPU\x20platfor\
    m.\x20Applicable\x20values\x20are\x20the\n\x20friendly\x20names\x20of\
    \x20CPU\x20platforms,\x20such\x20as\n\x20<code>minCpuPlatform:\x20&quot;\
    Intel\x20Haswell&quot;</code>\x20or\n\x20<code>minCpuPlatform:\x20&quot;\
    Intel\x20Sandy\x20Bridge&quot;</code>.\x20For\x20more\n\x20information,\
    \x20read\x20[how\x20to\x20specify\x20min\x20CPU\n\x20platform](https://c\
    loud.google.com/compute/docs/instances/specify-min-cpu-platform)\n\n\r\n\
    \x05\x04\0\x02\x0c\x05\x12\x04\xaa\x04\x02\x08\n\r\n\x05\x04\0\x02\x0c\
    \x01\x12\x04\xaa\x04\t\x19\n\r\n\x05\x04\0\x02\x0c\x03\x12\x04\xaa\x04\
    \x1c\x1e\n\xd2\x01\n\x04\x04\0\x02\r\x12\x04\xb0\x04\x02!\x1a\xc3\x01\
    \x20List\x20of\x20kubernetes\x20taints\x20to\x20be\x20applied\x20to\x20e\
    ach\x20node.\n\n\x20For\x20more\x20information,\x20including\x20usage\
    \x20and\x20the\x20valid\x20values,\x20see:\n\x20https://kubernetes.io/do\
    cs/concepts/configuration/taint-and-toleration/\n\n\r\n\x05\x04\0\x02\r\
    \x04\x12\x04\xb0\x04\x02\n\n\r\n\x05\x04\0\x02\r\x06\x12\x04\xb0\x04\x0b\
    \x14\n\r\n\x05\x04\0\x02\r\x01\x12\x04\xb0\x04\x15\x1b\n\r\n\x05\x04\0\
    \x02\r\x03\x12\x04\xb0\x04\x1e\x20\n*\n\x04\x04\0\x02\x0e\x12\x04\xb3\
    \x04\x027\x1a\x1c\x20Shielded\x20Instance\x20options.\n\n\r\n\x05\x04\0\
    \x02\x0e\x06\x12\x04\xb3\x04\x02\x18\n\r\n\x05\x04\0\x02\x0e\x01\x12\x04\
    \xb3\x04\x191\n\r\n\x05\x04\0\x02\x0e\x03\x12\x04\xb3\x0446\n3\n\x02\x04\
    \x01\x12\x06\xb7\x04\0\xc6\x04\x01\x1a%\x20A\x20set\x20of\x20Shielded\
    \x20Instance\x20options.\n\n\x0b\n\x03\x04\x01\x01\x12\x04\xb7\x04\x08\
    \x1e\n\x89\x02\n\x04\x04\x01\x02\0\x12\x04\xbd\x04\x02\x1e\x1a\xfa\x01\
    \x20Defines\x20whether\x20the\x20instance\x20has\x20Secure\x20Boot\x20en\
    abled.\n\n\x20Secure\x20Boot\x20helps\x20ensure\x20that\x20the\x20system\
    \x20only\x20runs\x20authentic\x20software\x20by\n\x20verifying\x20the\
    \x20digital\x20signature\x20of\x20all\x20boot\x20components,\x20and\x20h\
    alting\x20the\n\x20boot\x20process\x20if\x20signature\x20verification\
    \x20fails.\n\n\r\n\x05\x04\x01\x02\0\x05\x12\x04\xbd\x04\x02\x06\n\r\n\
    \x05\x04\x01\x02\0\x01\x12\x04\xbd\x04\x07\x19\n\r\n\x05\x04\x01\x02\0\
    \x03\x12\x04\xbd\x04\x1c\x1d\n\xca\x02\n\x04\x04\x01\x02\x01\x12\x04\xc5\
    \x04\x02'\x1a\xbb\x02\x20Defines\x20whether\x20the\x20instance\x20has\
    \x20integrity\x20monitoring\x20enabled.\n\n\x20Enables\x20monitoring\x20\
    and\x20attestation\x20of\x20the\x20boot\x20integrity\x20of\x20the\x20ins\
    tance.\n\x20The\x20attestation\x20is\x20performed\x20against\x20the\x20i\
    ntegrity\x20policy\x20baseline.\x20This\n\x20baseline\x20is\x20initially\
    \x20derived\x20from\x20the\x20implicitly\x20trusted\x20boot\x20image\x20\
    when\n\x20the\x20instance\x20is\x20created.\n\n\r\n\x05\x04\x01\x02\x01\
    \x05\x12\x04\xc5\x04\x02\x06\n\r\n\x05\x04\x01\x02\x01\x01\x12\x04\xc5\
    \x04\x07\"\n\r\n\x05\x04\x01\x02\x01\x03\x12\x04\xc5\x04%&\n\xb7\x02\n\
    \x02\x04\x02\x12\x06\xcd\x04\0\xe5\x04\x01\x1a\xa8\x02\x20Kubernetes\x20\
    taint\x20is\x20comprised\x20of\x20three\x20fields:\x20key,\x20value,\x20\
    and\x20effect.\x20Effect\n\x20can\x20only\x20be\x20one\x20of\x20three\
    \x20types:\x20\x20NoSchedule,\x20PreferNoSchedule\x20or\x20NoExecute.\n\
    \n\x20For\x20more\x20information,\x20including\x20usage\x20and\x20the\
    \x20valid\x20values,\x20see:\n\x20https://kubernetes.io/docs/concepts/co\
    nfiguration/taint-and-toleration/\n\n\x0b\n\x03\x04\x02\x01\x12\x04\xcd\
    \x04\x08\x11\n6\n\x04\x04\x02\x04\0\x12\x06\xcf\x04\x02\xdb\x04\x03\x1a&\
    \x20Possible\x20values\x20for\x20Effect\x20in\x20taint.\n\n\r\n\x05\x04\
    \x02\x04\0\x01\x12\x04\xcf\x04\x07\r\n\x19\n\x06\x04\x02\x04\0\x02\0\x12\
    \x04\xd1\x04\x04\x1b\x1a\t\x20Not\x20set\n\n\x0f\n\x07\x04\x02\x04\0\x02\
    \0\x01\x12\x04\xd1\x04\x04\x16\n\x0f\n\x07\x04\x02\x04\0\x02\0\x02\x12\
    \x04\xd1\x04\x19\x1a\n\x1c\n\x06\x04\x02\x04\0\x02\x01\x12\x04\xd4\x04\
    \x04\x14\x1a\x0c\x20NoSchedule\n\n\x0f\n\x07\x04\x02\x04\0\x02\x01\x01\
    \x12\x04\xd4\x04\x04\x0f\n\x0f\n\x07\x04\x02\x04\0\x02\x01\x02\x12\x04\
    \xd4\x04\x12\x13\n\"\n\x06\x04\x02\x04\0\x02\x02\x12\x04\xd7\x04\x04\x1b\
    \x1a\x12\x20PreferNoSchedule\n\n\x0f\n\x07\x04\x02\x04\0\x02\x02\x01\x12\
    \x04\xd7\x04\x04\x16\n\x0f\n\x07\x04\x02\x04\0\x02\x02\x02\x12\x04\xd7\
    \x04\x19\x1a\n\x1b\n\x06\x04\x02\x04\0\x02\x03\x12\x04\xda\x04\x04\x13\
    \x1a\x0b\x20NoExecute\n\n\x0f\n\x07\x04\x02\x04\0\x02\x03\x01\x12\x04\
    \xda\x04\x04\x0e\n\x0f\n\x07\x04\x02\x04\0\x02\x03\x02\x12\x04\xda\x04\
    \x11\x12\n\x1e\n\x04\x04\x02\x02\0\x12\x04\xde\x04\x02\x11\x1a\x10\x20Ke\
    y\x20for\x20taint.\n\n\r\n\x05\x04\x02\x02\0\x05\x12\x04\xde\x04\x02\x08\
    \n\r\n\x05\x04\x02\x02\0\x01\x12\x04\xde\x04\t\x0c\n\r\n\x05\x04\x02\x02\
    \0\x03\x12\x04\xde\x04\x0f\x10\n\x20\n\x04\x04\x02\x02\x01\x12\x04\xe1\
    \x04\x02\x13\x1a\x12\x20Value\x20for\x20taint.\n\n\r\n\x05\x04\x02\x02\
    \x01\x05\x12\x04\xe1\x04\x02\x08\n\r\n\x05\x04\x02\x02\x01\x01\x12\x04\
    \xe1\x04\t\x0e\n\r\n\x05\x04\x02\x02\x01\x03\x12\x04\xe1\x04\x11\x12\n!\
    \n\x04\x04\x02\x02\x02\x12\x04\xe4\x04\x02\x14\x1a\x13\x20Effect\x20for\
    \x20taint.\n\n\r\n\x05\x04\x02\x02\x02\x06\x12\x04\xe4\x04\x02\x08\n\r\n\
    \x05\x04\x02\x02\x02\x01\x12\x04\xe4\x04\t\x0f\n\r\n\x05\x04\x02\x02\x02\
    \x03\x12\x04\xe4\x04\x12\x13\n\xa3\x01\n\x02\x04\x03\x12\x06\xea\x04\0\
    \x86\x05\x01\x1a\x94\x01\x20The\x20authentication\x20information\x20for\
    \x20accessing\x20the\x20master\x20endpoint.\n\x20Authentication\x20can\
    \x20be\x20done\x20using\x20HTTP\x20basic\x20auth\x20or\x20using\x20clien\
    t\n\x20certificates.\n\n\x0b\n\x03\x04\x03\x01\x12\x04\xea\x04\x08\x12\n\
    \xe5\x01\n\x04\x04\x03\x02\0\x12\x04\xee\x04\x02\x16\x1a\xd6\x01\x20The\
    \x20username\x20to\x20use\x20for\x20HTTP\x20basic\x20authentication\x20t\
    o\x20the\x20master\x20endpoint.\n\x20For\x20clusters\x20v1.6.0\x20and\
    \x20later,\x20basic\x20authentication\x20can\x20be\x20disabled\x20by\n\
    \x20leaving\x20username\x20unspecified\x20(or\x20setting\x20it\x20to\x20\
    the\x20empty\x20string).\n\n\r\n\x05\x04\x03\x02\0\x05\x12\x04\xee\x04\
    \x02\x08\n\r\n\x05\x04\x03\x02\0\x01\x12\x04\xee\x04\t\x11\n\r\n\x05\x04\
    \x03\x02\0\x03\x12\x04\xee\x04\x14\x15\n\x84\x02\n\x04\x04\x03\x02\x01\
    \x12\x04\xf4\x04\x02\x16\x1a\xf5\x01\x20The\x20password\x20to\x20use\x20\
    for\x20HTTP\x20basic\x20authentication\x20to\x20the\x20master\x20endpoin\
    t.\n\x20Because\x20the\x20master\x20endpoint\x20is\x20open\x20to\x20the\
    \x20Internet,\x20you\x20should\x20create\x20a\n\x20strong\x20password.\
    \x20\x20If\x20a\x20password\x20is\x20provided\x20for\x20cluster\x20creat\
    ion,\x20username\n\x20must\x20be\x20non-empty.\n\n\r\n\x05\x04\x03\x02\
    \x01\x05\x12\x04\xf4\x04\x02\x08\n\r\n\x05\x04\x03\x02\x01\x01\x12\x04\
    \xf4\x04\t\x11\n\r\n\x05\x04\x03\x02\x01\x03\x12\x04\xf4\x04\x14\x15\n\
    \xb3\x01\n\x04\x04\x03\x02\x02\x12\x04\xf9\x04\x028\x1a\xa4\x01\x20Confi\
    guration\x20for\x20client\x20certificate\x20authentication\x20on\x20the\
    \x20cluster.\x20For\n\x20clusters\x20before\x20v1.12,\x20if\x20no\x20con\
    figuration\x20is\x20specified,\x20a\x20client\n\x20certificate\x20is\x20\
    issued.\n\n\r\n\x05\x04\x03\x02\x02\x06\x12\x04\xf9\x04\x02\x19\n\r\n\
    \x05\x04\x03\x02\x02\x01\x12\x04\xf9\x04\x1a3\n\r\n\x05\x04\x03\x02\x02\
    \x03\x12\x04\xf9\x0467\nk\n\x04\x04\x03\x02\x03\x12\x04\xfd\x04\x02&\x1a\
    ]\x20[Output\x20only]\x20Base64-encoded\x20public\x20certificate\x20that\
    \x20is\x20the\x20root\x20of\n\x20trust\x20for\x20the\x20cluster.\n\n\r\n\
    \x05\x04\x03\x02\x03\x05\x12\x04\xfd\x04\x02\x08\n\r\n\x05\x04\x03\x02\
    \x03\x01\x12\x04\xfd\x04\t\x1f\n\r\n\x05\x04\x03\x02\x03\x03\x12\x04\xfd\
    \x04\"%\ny\n\x04\x04\x03\x02\x04\x12\x04\x81\x05\x02\"\x1ak\x20[Output\
    \x20only]\x20Base64-encoded\x20public\x20certificate\x20used\x20by\x20cl\
    ients\x20to\n\x20authenticate\x20to\x20the\x20cluster\x20endpoint.\n\n\r\
    \n\x05\x04\x03\x02\x04\x05\x12\x04\x81\x05\x02\x08\n\r\n\x05\x04\x03\x02\
    \x04\x01\x12\x04\x81\x05\t\x1b\n\r\n\x05\x04\x03\x02\x04\x03\x12\x04\x81\
    \x05\x1e!\nr\n\x04\x04\x03\x02\x05\x12\x04\x85\x05\x02\x1a\x1ad\x20[Outp\
    ut\x20only]\x20Base64-encoded\x20private\x20key\x20used\x20by\x20clients\
    \x20to\x20authenticate\n\x20to\x20the\x20cluster\x20endpoint.\n\n\r\n\
    \x05\x04\x03\x02\x05\x05\x12\x04\x85\x05\x02\x08\n\r\n\x05\x04\x03\x02\
    \x05\x01\x12\x04\x85\x05\t\x13\n\r\n\x05\x04\x03\x02\x05\x03\x12\x04\x85\
    \x05\x16\x19\nE\n\x02\x04\x04\x12\x06\x89\x05\0\x8c\x05\x01\x1a7\x20Conf\
    iguration\x20for\x20client\x20certificates\x20on\x20the\x20cluster.\n\n\
    \x0b\n\x03\x04\x04\x01\x12\x04\x89\x05\x08\x1f\n+\n\x04\x04\x04\x02\0\
    \x12\x04\x8b\x05\x02$\x1a\x1d\x20Issue\x20a\x20client\x20certificate.\n\
    \n\r\n\x05\x04\x04\x02\0\x05\x12\x04\x8b\x05\x02\x06\n\r\n\x05\x04\x04\
    \x02\0\x01\x12\x04\x8b\x05\x07\x1f\n\r\n\x05\x04\x04\x02\0\x03\x12\x04\
    \x8b\x05\"#\n\x82\x01\n\x02\x04\x05\x12\x06\x90\x05\0\xa9\x05\x01\x1at\
    \x20Configuration\x20for\x20the\x20addons\x20that\x20can\x20be\x20automa\
    tically\x20spun\x20up\x20in\x20the\n\x20cluster,\x20enabling\x20addition\
    al\x20functionality.\n\n\x0b\n\x03\x04\x05\x01\x12\x04\x90\x05\x08\x14\n\
    \x9f\x01\n\x04\x04\x05\x02\0\x12\x04\x93\x05\x02,\x1a\x90\x01\x20Configu\
    ration\x20for\x20the\x20HTTP\x20(L7)\x20load\x20balancing\x20controller\
    \x20addon,\x20which\n\x20makes\x20it\x20easy\x20to\x20set\x20up\x20HTTP\
    \x20load\x20balancers\x20for\x20services\x20in\x20a\x20cluster.\n\n\r\n\
    \x05\x04\x05\x02\0\x06\x12\x04\x93\x05\x02\x13\n\r\n\x05\x04\x05\x02\0\
    \x01\x12\x04\x93\x05\x14'\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x93\x05*+\
    \n\xd3\x01\n\x04\x04\x05\x02\x01\x12\x04\x98\x05\x02:\x1a\xc4\x01\x20Con\
    figuration\x20for\x20the\x20horizontal\x20pod\x20autoscaling\x20feature,\
    \x20which\n\x20increases\x20or\x20decreases\x20the\x20number\x20of\x20re\
    plica\x20pods\x20a\x20replication\x20controller\n\x20has\x20based\x20on\
    \x20the\x20resource\x20usage\x20of\x20the\x20existing\x20pods.\n\n\r\n\
    \x05\x04\x05\x02\x01\x06\x12\x04\x98\x05\x02\x1a\n\r\n\x05\x04\x05\x02\
    \x01\x01\x12\x04\x98\x05\x1b5\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\x98\
    \x0589\n\xce\x02\n\x04\x04\x05\x02\x02\x12\x04\x9f\x05\x02C\x1a\xbf\x02\
    \x20Configuration\x20for\x20the\x20Kubernetes\x20Dashboard.\n\x20This\
    \x20addon\x20is\x20deprecated,\x20and\x20will\x20be\x20disabled\x20in\
    \x201.15.\x20It\x20is\x20recommended\n\x20to\x20use\x20the\x20Cloud\x20C\
    onsole\x20to\x20manage\x20and\x20monitor\x20your\x20Kubernetes\x20cluste\
    rs,\n\x20workloads\x20and\x20applications.\x20For\x20more\x20information\
    ,\x20see:\n\x20https://cloud.google.com/kubernetes-engine/docs/concepts/\
    dashboards\n\n\r\n\x05\x04\x05\x02\x02\x06\x12\x04\x9f\x05\x02\x15\n\r\n\
    \x05\x04\x05\x02\x02\x01\x12\x04\x9f\x05\x16*\n\r\n\x05\x04\x05\x02\x02\
    \x03\x12\x04\x9f\x05-.\n\r\n\x05\x04\x05\x02\x02\x08\x12\x04\x9f\x05/B\n\
    \x0e\n\x06\x04\x05\x02\x02\x08\x03\x12\x04\x9f\x050A\n\xba\x01\n\x04\x04\
    \x05\x02\x03\x12\x04\xa4\x05\x020\x1a\xab\x01\x20Configuration\x20for\
    \x20NetworkPolicy.\x20This\x20only\x20tracks\x20whether\x20the\x20addon\
    \n\x20is\x20enabled\x20or\x20not\x20on\x20the\x20Master,\x20it\x20does\
    \x20not\x20track\x20whether\x20network\x20policy\n\x20is\x20enabled\x20f\
    or\x20the\x20nodes.\n\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\xa4\x05\x02\
    \x15\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\xa4\x05\x16+\n\r\n\x05\x04\
    \x05\x02\x03\x03\x12\x04\xa4\x05./\no\n\x04\x04\x05\x02\x04\x12\x04\xa8\
    \x05\x02&\x1aa\x20Configuration\x20for\x20the\x20Cloud\x20Run\x20addon,\
    \x20which\x20allows\x20the\x20user\x20to\x20use\x20a\n\x20managed\x20Kna\
    tive\x20service.\n\n\r\n\x05\x04\x05\x02\x04\x06\x12\x04\xa8\x05\x02\x10\
    \n\r\n\x05\x04\x05\x02\x04\x01\x12\x04\xa8\x05\x11!\n\r\n\x05\x04\x05\
    \x02\x04\x03\x12\x04\xa8\x05$%\n\xa7\x01\n\x02\x04\x06\x12\x06\xad\x05\0\
    \xb2\x05\x01\x1a\x98\x01\x20Configuration\x20options\x20for\x20the\x20HT\
    TP\x20(L7)\x20load\x20balancing\x20controller\x20addon,\n\x20which\x20ma\
    kes\x20it\x20easy\x20to\x20set\x20up\x20HTTP\x20load\x20balancers\x20for\
    \x20services\x20in\x20a\x20cluster.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\
    \xad\x05\x08\x19\n\xaa\x01\n\x04\x04\x06\x02\0\x12\x04\xb1\x05\x02\x14\
    \x1a\x9b\x01\x20Whether\x20the\x20HTTP\x20Load\x20Balancing\x20controlle\
    r\x20is\x20enabled\x20in\x20the\x20cluster.\n\x20When\x20enabled,\x20it\
    \x20runs\x20a\x20small\x20pod\x20in\x20the\x20cluster\x20that\x20manages\
    \x20the\x20load\n\x20balancers.\n\n\r\n\x05\x04\x06\x02\0\x05\x12\x04\
    \xb1\x05\x02\x06\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xb1\x05\x07\x0f\n\r\
    \n\x05\x04\x06\x02\0\x03\x12\x04\xb1\x05\x12\x13\n\xdb\x01\n\x02\x04\x07\
    \x12\x06\xb7\x05\0\xbc\x05\x01\x1a\xcc\x01\x20Configuration\x20options\
    \x20for\x20the\x20horizontal\x20pod\x20autoscaling\x20feature,\x20which\
    \n\x20increases\x20or\x20decreases\x20the\x20number\x20of\x20replica\x20\
    pods\x20a\x20replication\x20controller\n\x20has\x20based\x20on\x20the\
    \x20resource\x20usage\x20of\x20the\x20existing\x20pods.\n\n\x0b\n\x03\
    \x04\x07\x01\x12\x04\xb7\x05\x08\x20\n\xd8\x01\n\x04\x04\x07\x02\0\x12\
    \x04\xbb\x05\x02\x14\x1a\xc9\x01\x20Whether\x20the\x20Horizontal\x20Pod\
    \x20Autoscaling\x20feature\x20is\x20enabled\x20in\x20the\x20cluster.\n\
    \x20When\x20enabled,\x20it\x20ensures\x20that\x20a\x20Heapster\x20pod\
    \x20is\x20running\x20in\x20the\x20cluster,\n\x20which\x20is\x20also\x20u\
    sed\x20by\x20the\x20Cloud\x20Monitoring\x20service.\n\n\r\n\x05\x04\x07\
    \x02\0\x05\x12\x04\xbb\x05\x02\x06\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\
    \xbb\x05\x07\x0f\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xbb\x05\x12\x13\n;\
    \n\x02\x04\x08\x12\x06\xbf\x05\0\xc2\x05\x01\x1a-\x20Configuration\x20fo\
    r\x20the\x20Kubernetes\x20Dashboard.\n\n\x0b\n\x03\x04\x08\x01\x12\x04\
    \xbf\x05\x08\x1b\nM\n\x04\x04\x08\x02\0\x12\x04\xc1\x05\x02\x14\x1a?\x20\
    Whether\x20the\x20Kubernetes\x20Dashboard\x20is\x20enabled\x20for\x20thi\
    s\x20cluster.\n\n\r\n\x05\x04\x08\x02\0\x05\x12\x04\xc1\x05\x02\x06\n\r\
    \n\x05\x04\x08\x02\0\x01\x12\x04\xc1\x05\x07\x0f\n\r\n\x05\x04\x08\x02\0\
    \x03\x12\x04\xc1\x05\x12\x13\n\xba\x01\n\x02\x04\t\x12\x06\xc7\x05\0\xca\
    \x05\x01\x1a\xab\x01\x20Configuration\x20for\x20NetworkPolicy.\x20This\
    \x20only\x20tracks\x20whether\x20the\x20addon\n\x20is\x20enabled\x20or\
    \x20not\x20on\x20the\x20Master,\x20it\x20does\x20not\x20track\x20whether\
    \x20network\x20policy\n\x20is\x20enabled\x20for\x20the\x20nodes.\n\n\x0b\
    \n\x03\x04\t\x01\x12\x04\xc7\x05\x08\x1b\nB\n\x04\x04\t\x02\0\x12\x04\
    \xc9\x05\x02\x14\x1a4\x20Whether\x20NetworkPolicy\x20is\x20enabled\x20fo\
    r\x20this\x20cluster.\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xc9\x05\x02\
    \x06\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xc9\x05\x07\x0f\n\r\n\x05\x04\t\
    \x02\0\x03\x12\x04\xc9\x05\x12\x13\n;\n\x02\x04\n\x12\x06\xcd\x05\0\xe1\
    \x05\x01\x1a-\x20Configuration\x20options\x20for\x20private\x20clusters.\
    \n\n\x0b\n\x03\x04\n\x01\x12\x04\xcd\x05\x08\x1c\n\xb9\x01\n\x04\x04\n\
    \x02\0\x12\x04\xd1\x05\x02\x20\x1a\xaa\x01\x20Whether\x20nodes\x20have\
    \x20internal\x20IP\x20addresses\x20only.\x20If\x20enabled,\x20all\x20nod\
    es\x20are\n\x20given\x20only\x20RFC\x201918\x20private\x20addresses\x20a\
    nd\x20communicate\x20with\x20the\x20master\x20via\n\x20private\x20networ\
    king.\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xd1\x05\x02\x06\n\r\n\x05\x04\
    \n\x02\0\x01\x12\x04\xd1\x05\x07\x1b\n\r\n\x05\x04\n\x02\0\x03\x12\x04\
    \xd1\x05\x1e\x1f\nY\n\x04\x04\n\x02\x01\x12\x04\xd4\x05\x02#\x1aK\x20Whe\
    ther\x20the\x20master's\x20internal\x20IP\x20address\x20is\x20used\x20as\
    \x20the\x20cluster\x20endpoint.\n\n\r\n\x05\x04\n\x02\x01\x05\x12\x04\
    \xd4\x05\x02\x06\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\xd4\x05\x07\x1e\n\r\
    \n\x05\x04\n\x02\x01\x03\x12\x04\xd4\x05!\"\n\xa3\x02\n\x04\x04\n\x02\
    \x02\x12\x04\xda\x05\x02$\x1a\x94\x02\x20The\x20IP\x20range\x20in\x20CID\
    R\x20notation\x20to\x20use\x20for\x20the\x20hosted\x20master\x20network.\
    \x20This\n\x20range\x20will\x20be\x20used\x20for\x20assigning\x20interna\
    l\x20IP\x20addresses\x20to\x20the\x20master\x20or\n\x20set\x20of\x20mast\
    ers,\x20as\x20well\x20as\x20the\x20ILB\x20VIP.\x20This\x20range\x20must\
    \x20not\x20overlap\x20with\n\x20any\x20other\x20ranges\x20in\x20use\x20w\
    ithin\x20the\x20cluster's\x20network.\n\n\r\n\x05\x04\n\x02\x02\x05\x12\
    \x04\xda\x05\x02\x08\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\xda\x05\t\x1f\n\
    \r\n\x05\x04\n\x02\x02\x03\x12\x04\xda\x05\"#\nW\n\x04\x04\n\x02\x03\x12\
    \x04\xdd\x05\x02\x1e\x1aI\x20Output\x20only.\x20The\x20internal\x20IP\
    \x20address\x20of\x20this\x20cluster's\x20master\x20endpoint.\n\n\r\n\
    \x05\x04\n\x02\x03\x05\x12\x04\xdd\x05\x02\x08\n\r\n\x05\x04\n\x02\x03\
    \x01\x12\x04\xdd\x05\t\x19\n\r\n\x05\x04\n\x02\x03\x03\x12\x04\xdd\x05\
    \x1c\x1d\nW\n\x04\x04\n\x02\x04\x12\x04\xe0\x05\x02\x1d\x1aI\x20Output\
    \x20only.\x20The\x20external\x20IP\x20address\x20of\x20this\x20cluster's\
    \x20master\x20endpoint.\n\n\r\n\x05\x04\n\x02\x04\x05\x12\x04\xe0\x05\
    \x02\x08\n\r\n\x05\x04\n\x02\x04\x01\x12\x04\xe0\x05\t\x18\n\r\n\x05\x04\
    \n\x02\x04\x03\x12\x04\xe0\x05\x1b\x1c\nR\n\x02\x04\x0b\x12\x06\xe4\x05\
    \0\xec\x05\x01\x1aD\x20Configuration\x20for\x20returning\x20group\x20inf\
    ormation\x20from\x20authenticators.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\
    \xe4\x05\x08!\n\x84\x01\n\x04\x04\x0b\x02\0\x12\x04\xe7\x05\x02\x13\x1av\
    \x20Whether\x20this\x20cluster\x20should\x20return\x20group\x20membershi\
    p\x20lookups\n\x20during\x20authentication\x20using\x20a\x20group\x20of\
    \x20security\x20groups.\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xe7\x05\
    \x02\x06\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xe7\x05\x07\x0e\n\r\n\x05\
    \x04\x0b\x02\0\x03\x12\x04\xe7\x05\x11\x12\nf\n\x04\x04\x0b\x02\x01\x12\
    \x04\xeb\x05\x02\x1c\x1aX\x20The\x20name\x20of\x20the\x20security\x20gro\
    up-of-groups\x20to\x20be\x20used.\x20Only\x20relevant\n\x20if\x20enabled\
    \x20=\x20true.\n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\xeb\x05\x02\x08\n\
    \r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xeb\x05\t\x17\n\r\n\x05\x04\x0b\x02\
    \x01\x03\x12\x04\xeb\x05\x1a\x1b\n@\n\x02\x04\x0c\x12\x06\xef\x05\0\xf2\
    \x05\x01\x1a2\x20Configuration\x20options\x20for\x20the\x20Cloud\x20Run\
    \x20feature.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xef\x05\x08\x16\nD\n\x04\
    \x04\x0c\x02\0\x12\x04\xf1\x05\x02\x14\x1a6\x20Whether\x20Cloud\x20Run\
    \x20addon\x20is\x20enabled\x20for\x20this\x20cluster.\n\n\r\n\x05\x04\
    \x0c\x02\0\x05\x12\x04\xf1\x05\x02\x06\n\r\n\x05\x04\x0c\x02\0\x01\x12\
    \x04\xf1\x05\x07\x0f\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xf1\x05\x12\x13\
    \n\xa6\x02\n\x02\x04\r\x12\x06\xf8\x05\0\x88\x06\x01\x1a\x97\x02\x20Conf\
    iguration\x20options\x20for\x20the\x20master\x20authorized\x20networks\
    \x20feature.\x20Enabled\n\x20master\x20authorized\x20networks\x20will\
    \x20disallow\x20all\x20external\x20traffic\x20to\x20access\n\x20Kubernet\
    es\x20master\x20through\x20HTTPS\x20except\x20traffic\x20from\x20the\x20\
    given\x20CIDR\x20blocks,\n\x20Google\x20Compute\x20Engine\x20Public\x20I\
    Ps\x20and\x20Google\x20Prod\x20IPs.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xf8\
    \x05\x08&\nI\n\x04\x04\r\x03\0\x12\x06\xfa\x05\x02\x80\x06\x03\x1a9\x20C\
    idrBlock\x20contains\x20an\x20optional\x20name\x20and\x20one\x20CIDR\x20\
    block.\n\n\r\n\x05\x04\r\x03\0\x01\x12\x04\xfa\x05\n\x13\nV\n\x06\x04\r\
    \x03\0\x02\0\x12\x04\xfc\x05\x04\x1c\x1aF\x20display_name\x20is\x20an\
    \x20optional\x20field\x20for\x20users\x20to\x20identify\x20CIDR\x20block\
    s.\n\n\x0f\n\x07\x04\r\x03\0\x02\0\x05\x12\x04\xfc\x05\x04\n\n\x0f\n\x07\
    \x04\r\x03\0\x02\0\x01\x12\x04\xfc\x05\x0b\x17\n\x0f\n\x07\x04\r\x03\0\
    \x02\0\x03\x12\x04\xfc\x05\x1a\x1b\n@\n\x06\x04\r\x03\0\x02\x01\x12\x04\
    \xff\x05\x04\x1a\x1a0\x20cidr_block\x20must\x20be\x20specified\x20in\x20\
    CIDR\x20notation.\n\n\x0f\n\x07\x04\r\x03\0\x02\x01\x05\x12\x04\xff\x05\
    \x04\n\n\x0f\n\x07\x04\r\x03\0\x02\x01\x01\x12\x04\xff\x05\x0b\x15\n\x0f\
    \n\x07\x04\r\x03\0\x02\x01\x03\x12\x04\xff\x05\x18\x19\nE\n\x04\x04\r\
    \x02\0\x12\x04\x83\x06\x02\x13\x1a7\x20Whether\x20or\x20not\x20master\
    \x20authorized\x20networks\x20is\x20enabled.\n\n\r\n\x05\x04\r\x02\0\x05\
    \x12\x04\x83\x06\x02\x06\n\r\n\x05\x04\r\x02\0\x01\x12\x04\x83\x06\x07\
    \x0e\n\r\n\x05\x04\r\x02\0\x03\x12\x04\x83\x06\x11\x12\nq\n\x04\x04\r\
    \x02\x01\x12\x04\x87\x06\x02%\x1ac\x20cidr_blocks\x20define\x20up\x20to\
    \x2050\x20external\x20networks\x20that\x20could\x20access\n\x20Kubernete\
    s\x20master\x20through\x20HTTPS.\n\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\
    \x87\x06\x02\n\n\r\n\x05\x04\r\x02\x01\x06\x12\x04\x87\x06\x0b\x14\n\r\n\
    \x05\x04\r\x02\x01\x01\x12\x04\x87\x06\x15\x20\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\x87\x06#$\n`\n\x02\x04\x0e\x12\x06\x8c\x06\0\x92\x06\x01\
    \x1aR\x20Configuration\x20for\x20the\x20legacy\x20Attribute\x20Based\x20\
    Access\x20Control\x20authorization\n\x20mode.\n\n\x0b\n\x03\x04\x0e\x01\
    \x12\x04\x8c\x06\x08\x12\n\x89\x02\n\x04\x04\x0e\x02\0\x12\x04\x91\x06\
    \x02\x13\x1a\xfa\x01\x20Whether\x20the\x20ABAC\x20authorizer\x20is\x20en\
    abled\x20for\x20this\x20cluster.\x20When\x20enabled,\n\x20identities\x20\
    in\x20the\x20system,\x20including\x20service\x20accounts,\x20nodes,\x20a\
    nd\n\x20controllers,\x20will\x20have\x20statically\x20granted\x20permiss\
    ions\x20beyond\x20those\n\x20provided\x20by\x20the\x20RBAC\x20configurat\
    ion\x20or\x20IAM.\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\x91\x06\x02\x06\
    \n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\x91\x06\x07\x0e\n\r\n\x05\x04\x0e\
    \x02\0\x03\x12\x04\x91\x06\x11\x12\n\x8f\x01\n\x02\x04\x0f\x12\x06\x96\
    \x06\0\xa5\x06\x01\x1a\x80\x01\x20Configuration\x20options\x20for\x20the\
    \x20NetworkPolicy\x20feature.\n\x20https://kubernetes.io/docs/concepts/s\
    ervices-networking/networkpolicies/\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\
    \x96\x06\x08\x15\n3\n\x04\x04\x0f\x04\0\x12\x06\x98\x06\x02\x9e\x06\x03\
    \x1a#\x20Allowed\x20Network\x20Policy\x20providers.\n\n\r\n\x05\x04\x0f\
    \x04\0\x01\x12\x04\x98\x06\x07\x0f\n\x19\n\x06\x04\x0f\x04\0\x02\0\x12\
    \x04\x9a\x06\x04\x1d\x1a\t\x20Not\x20set\n\n\x0f\n\x07\x04\x0f\x04\0\x02\
    \0\x01\x12\x04\x9a\x06\x04\x18\n\x0f\n\x07\x04\x0f\x04\0\x02\0\x02\x12\
    \x04\x9a\x06\x1b\x1c\n(\n\x06\x04\x0f\x04\0\x02\x01\x12\x04\x9d\x06\x04\
    \x0f\x1a\x18\x20Tigera\x20(Calico\x20Felix).\n\n\x0f\n\x07\x04\x0f\x04\0\
    \x02\x01\x01\x12\x04\x9d\x06\x04\n\n\x0f\n\x07\x04\x0f\x04\0\x02\x01\x02\
    \x12\x04\x9d\x06\r\x0e\n5\n\x04\x04\x0f\x02\0\x12\x04\xa1\x06\x02\x18\
    \x1a'\x20The\x20selected\x20network\x20policy\x20provider.\n\n\r\n\x05\
    \x04\x0f\x02\0\x06\x12\x04\xa1\x06\x02\n\n\r\n\x05\x04\x0f\x02\0\x01\x12\
    \x04\xa1\x06\x0b\x13\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xa1\x06\x16\x17\
    \nA\n\x04\x04\x0f\x02\x01\x12\x04\xa4\x06\x02\x13\x1a3\x20Whether\x20net\
    work\x20policy\x20is\x20enabled\x20on\x20the\x20cluster.\n\n\r\n\x05\x04\
    \x0f\x02\x01\x05\x12\x04\xa4\x06\x02\x06\n\r\n\x05\x04\x0f\x02\x01\x01\
    \x12\x04\xa4\x06\x07\x0e\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xa4\x06\
    \x11\x12\n7\n\x02\x04\x10\x12\x06\xa8\x06\0\xac\x06\x01\x1a)\x20Configur\
    ation\x20for\x20Binary\x20Authorization.\n\n\x0b\n\x03\x04\x10\x01\x12\
    \x04\xa8\x06\x08\x1b\n\x8a\x01\n\x04\x04\x10\x02\0\x12\x04\xab\x06\x02\
    \x13\x1a|\x20Enable\x20Binary\x20Authorization\x20for\x20this\x20cluster\
    .\x20If\x20enabled,\x20all\x20container\n\x20images\x20will\x20be\x20val\
    idated\x20by\x20Binary\x20Authorization.\n\n\r\n\x05\x04\x10\x02\0\x05\
    \x12\x04\xab\x06\x02\x06\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\xab\x06\x07\
    \x0e\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xab\x06\x11\x12\nS\n\x02\x04\
    \x11\x12\x06\xaf\x06\0\x9a\x07\x01\x1aE\x20Configuration\x20for\x20contr\
    olling\x20how\x20IPs\x20are\x20allocated\x20in\x20the\x20cluster.\n\n\
    \x0b\n\x03\x04\x11\x01\x12\x04\xaf\x06\x08\x1a\nJ\n\x04\x04\x11\x02\0\
    \x12\x04\xb1\x06\x02\x1a\x1a<\x20Whether\x20alias\x20IPs\x20will\x20be\
    \x20used\x20for\x20pod\x20IPs\x20in\x20the\x20cluster.\n\n\r\n\x05\x04\
    \x11\x02\0\x05\x12\x04\xb1\x06\x02\x06\n\r\n\x05\x04\x11\x02\0\x01\x12\
    \x04\xb1\x06\x07\x15\n\r\n\x05\x04\x11\x02\0\x03\x12\x04\xb1\x06\x18\x19\
    \n\x97\x01\n\x04\x04\x11\x02\x01\x12\x04\xb6\x06\x02\x1d\x1a\x88\x01\x20\
    Whether\x20a\x20new\x20subnetwork\x20will\x20be\x20created\x20automatica\
    lly\x20for\x20the\x20cluster.\n\n\x20This\x20field\x20is\x20only\x20appl\
    icable\x20when\x20`use_ip_aliases`\x20is\x20true.\n\n\r\n\x05\x04\x11\
    \x02\x01\x05\x12\x04\xb6\x06\x02\x06\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\xb6\x06\x07\x18\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xb6\x06\x1b\
    \x1c\n\xad\x01\n\x04\x04\x11\x02\x02\x12\x04\xbb\x06\x02\x1d\x1a\x9e\x01\
    \x20A\x20custom\x20subnetwork\x20name\x20to\x20be\x20used\x20if\x20`crea\
    te_subnetwork`\x20is\x20true.\x20\x20If\n\x20this\x20field\x20is\x20empt\
    y,\x20then\x20an\x20automatic\x20name\x20will\x20be\x20chosen\x20for\x20\
    the\x20new\n\x20subnetwork.\n\n\r\n\x05\x04\x11\x02\x02\x05\x12\x04\xbb\
    \x06\x02\x08\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xbb\x06\t\x18\n\r\n\
    \x05\x04\x11\x02\x02\x03\x12\x04\xbb\x06\x1b\x1c\nF\n\x04\x04\x11\x02\
    \x03\x12\x04\xbe\x06\x023\x1a8\x20This\x20field\x20is\x20deprecated,\x20\
    use\x20cluster_ipv4_cidr_block.\n\n\r\n\x05\x04\x11\x02\x03\x05\x12\x04\
    \xbe\x06\x02\x08\n\r\n\x05\x04\x11\x02\x03\x01\x12\x04\xbe\x06\t\x1a\n\r\
    \n\x05\x04\x11\x02\x03\x03\x12\x04\xbe\x06\x1d\x1e\n\r\n\x05\x04\x11\x02\
    \x03\x08\x12\x04\xbe\x06\x1f2\n\x0e\n\x06\x04\x11\x02\x03\x08\x03\x12\
    \x04\xbe\x06\x201\nC\n\x04\x04\x11\x02\x04\x12\x04\xc1\x06\x020\x1a5\x20\
    This\x20field\x20is\x20deprecated,\x20use\x20node_ipv4_cidr_block.\n\n\r\
    \n\x05\x04\x11\x02\x04\x05\x12\x04\xc1\x06\x02\x08\n\r\n\x05\x04\x11\x02\
    \x04\x01\x12\x04\xc1\x06\t\x17\n\r\n\x05\x04\x11\x02\x04\x03\x12\x04\xc1\
    \x06\x1a\x1b\n\r\n\x05\x04\x11\x02\x04\x08\x12\x04\xc1\x06\x1c/\n\x0e\n\
    \x06\x04\x11\x02\x04\x08\x03\x12\x04\xc1\x06\x1d.\nG\n\x04\x04\x11\x02\
    \x05\x12\x04\xc4\x06\x024\x1a9\x20This\x20field\x20is\x20deprecated,\x20\
    use\x20services_ipv4_cidr_block.\n\n\r\n\x05\x04\x11\x02\x05\x05\x12\x04\
    \xc4\x06\x02\x08\n\r\n\x05\x04\x11\x02\x05\x01\x12\x04\xc4\x06\t\x1b\n\r\
    \n\x05\x04\x11\x02\x05\x03\x12\x04\xc4\x06\x1e\x1f\n\r\n\x05\x04\x11\x02\
    \x05\x08\x12\x04\xc4\x06\x203\n\x0e\n\x06\x04\x11\x02\x05\x08\x03\x12\
    \x04\xc4\x06!2\n\xc0\x02\n\x04\x04\x11\x02\x06\x12\x04\xcd\x06\x02*\x1a\
    \xb1\x02\x20The\x20name\x20of\x20the\x20secondary\x20range\x20to\x20be\
    \x20used\x20for\x20the\x20cluster\x20CIDR\n\x20block.\x20\x20The\x20seco\
    ndary\x20range\x20will\x20be\x20used\x20for\x20pod\x20IP\n\x20addresses.\
    \x20This\x20must\x20be\x20an\x20existing\x20secondary\x20range\x20associ\
    ated\n\x20with\x20the\x20cluster\x20subnetwork.\n\n\x20This\x20field\x20\
    is\x20only\x20applicable\x20with\x20use_ip_aliases\x20is\x20true\x20and\
    \n\x20create_subnetwork\x20is\x20false.\n\n\r\n\x05\x04\x11\x02\x06\x05\
    \x12\x04\xcd\x06\x02\x08\n\r\n\x05\x04\x11\x02\x06\x01\x12\x04\xcd\x06\t\
    %\n\r\n\x05\x04\x11\x02\x06\x03\x12\x04\xcd\x06()\n\xc6\x02\n\x04\x04\
    \x11\x02\x07\x12\x04\xd6\x06\x02+\x1a\xb7\x02\x20The\x20name\x20of\x20th\
    e\x20secondary\x20range\x20to\x20be\x20used\x20as\x20for\x20the\x20servi\
    ces\n\x20CIDR\x20block.\x20\x20The\x20secondary\x20range\x20will\x20be\
    \x20used\x20for\x20service\n\x20ClusterIPs.\x20This\x20must\x20be\x20an\
    \x20existing\x20secondary\x20range\x20associated\n\x20with\x20the\x20clu\
    ster\x20subnetwork.\n\n\x20This\x20field\x20is\x20only\x20applicable\x20\
    with\x20use_ip_aliases\x20is\x20true\x20and\n\x20create_subnetwork\x20is\
    \x20false.\n\n\r\n\x05\x04\x11\x02\x07\x05\x12\x04\xd6\x06\x02\x08\n\r\n\
    \x05\x04\x11\x02\x07\x01\x12\x04\xd6\x06\t&\n\r\n\x05\x04\x11\x02\x07\
    \x03\x12\x04\xd6\x06)*\n\xc3\x04\n\x04\x04\x11\x02\x08\x12\x04\xe7\x06\
    \x02%\x1a\xb4\x04\x20The\x20IP\x20address\x20range\x20for\x20the\x20clus\
    ter\x20pod\x20IPs.\x20If\x20this\x20field\x20is\x20set,\x20then\n\x20`cl\
    uster.cluster_ipv4_cidr`\x20must\x20be\x20left\x20blank.\n\n\x20This\x20\
    field\x20is\x20only\x20applicable\x20when\x20`use_ip_aliases`\x20is\x20t\
    rue.\n\n\x20Set\x20to\x20blank\x20to\x20have\x20a\x20range\x20chosen\x20\
    with\x20the\x20default\x20size.\n\n\x20Set\x20to\x20/netmask\x20(e.g.\
    \x20`/14`)\x20to\x20have\x20a\x20range\x20chosen\x20with\x20a\x20specifi\
    c\n\x20netmask.\n\n\x20Set\x20to\x20a\n\x20[CIDR](http://en.wikipedia.or\
    g/wiki/Classless_Inter-Domain_Routing)\n\x20notation\x20(e.g.\x20`10.96.\
    0.0/14`)\x20from\x20the\x20RFC-1918\x20private\x20networks\x20(e.g.\n\
    \x20`10.0.0.0/8`,\x20`172.16.0.0/12`,\x20`192.168.0.0/16`)\x20to\x20pick\
    \x20a\x20specific\x20range\n\x20to\x20use.\n\n\r\n\x05\x04\x11\x02\x08\
    \x05\x12\x04\xe7\x06\x02\x08\n\r\n\x05\x04\x11\x02\x08\x01\x12\x04\xe7\
    \x06\t\x20\n\r\n\x05\x04\x11\x02\x08\x03\x12\x04\xe7\x06#$\n\xfe\x03\n\
    \x04\x04\x11\x02\t\x12\x04\xf7\x06\x02#\x1a\xef\x03\x20The\x20IP\x20addr\
    ess\x20range\x20of\x20the\x20instance\x20IPs\x20in\x20this\x20cluster.\n\
    \n\x20This\x20is\x20applicable\x20only\x20if\x20`create_subnetwork`\x20i\
    s\x20true.\n\n\x20Set\x20to\x20blank\x20to\x20have\x20a\x20range\x20chos\
    en\x20with\x20the\x20default\x20size.\n\n\x20Set\x20to\x20/netmask\x20(e\
    .g.\x20`/14`)\x20to\x20have\x20a\x20range\x20chosen\x20with\x20a\x20spec\
    ific\n\x20netmask.\n\n\x20Set\x20to\x20a\n\x20[CIDR](http://en.wikipedia\
    .org/wiki/Classless_Inter-Domain_Routing)\n\x20notation\x20(e.g.\x20`10.\
    96.0.0/14`)\x20from\x20the\x20RFC-1918\x20private\x20networks\x20(e.g.\n\
    \x20`10.0.0.0/8`,\x20`172.16.0.0/12`,\x20`192.168.0.0/16`)\x20to\x20pick\
    \x20a\x20specific\x20range\n\x20to\x20use.\n\n\r\n\x05\x04\x11\x02\t\x05\
    \x12\x04\xf7\x06\x02\x08\n\r\n\x05\x04\x11\x02\t\x01\x12\x04\xf7\x06\t\
    \x1d\n\r\n\x05\x04\x11\x02\t\x03\x12\x04\xf7\x06\x20\"\n\xca\x04\n\x04\
    \x04\x11\x02\n\x12\x04\x88\x07\x02'\x1a\xbb\x04\x20The\x20IP\x20address\
    \x20range\x20of\x20the\x20services\x20IPs\x20in\x20this\x20cluster.\x20I\
    f\x20blank,\x20a\x20range\n\x20will\x20be\x20automatically\x20chosen\x20\
    with\x20the\x20default\x20size.\n\n\x20This\x20field\x20is\x20only\x20ap\
    plicable\x20when\x20`use_ip_aliases`\x20is\x20true.\n\n\x20Set\x20to\x20\
    blank\x20to\x20have\x20a\x20range\x20chosen\x20with\x20the\x20default\
    \x20size.\n\n\x20Set\x20to\x20/netmask\x20(e.g.\x20`/14`)\x20to\x20have\
    \x20a\x20range\x20chosen\x20with\x20a\x20specific\n\x20netmask.\n\n\x20S\
    et\x20to\x20a\n\x20[CIDR](http://en.wikipedia.org/wiki/Classless_Inter-D\
    omain_Routing)\n\x20notation\x20(e.g.\x20`10.96.0.0/14`)\x20from\x20the\
    \x20RFC-1918\x20private\x20networks\x20(e.g.\n\x20`10.0.0.0/8`,\x20`172.\
    16.0.0/12`,\x20`192.168.0.0/16`)\x20to\x20pick\x20a\x20specific\x20range\
    \n\x20to\x20use.\n\n\r\n\x05\x04\x11\x02\n\x05\x12\x04\x88\x07\x02\x08\n\
    \r\n\x05\x04\x11\x02\n\x01\x12\x04\x88\x07\t!\n\r\n\x05\x04\x11\x02\n\
    \x03\x12\x04\x88\x07$&\n\xc8\x04\n\x04\x04\x11\x02\x0b\x12\x04\x99\x07\
    \x02\"\x1a\xb9\x04\x20The\x20IP\x20address\x20range\x20of\x20the\x20Clou\
    d\x20TPUs\x20in\x20this\x20cluster.\x20If\x20unspecified,\x20a\n\x20rang\
    e\x20will\x20be\x20automatically\x20chosen\x20with\x20the\x20default\x20\
    size.\n\n\x20This\x20field\x20is\x20only\x20applicable\x20when\x20`use_i\
    p_aliases`\x20is\x20true.\n\n\x20If\x20unspecified,\x20the\x20range\x20w\
    ill\x20use\x20the\x20default\x20size.\n\n\x20Set\x20to\x20/netmask\x20(e\
    .g.\x20`/14`)\x20to\x20have\x20a\x20range\x20chosen\x20with\x20a\x20spec\
    ific\n\x20netmask.\n\n\x20Set\x20to\x20a\n\x20[CIDR](http://en.wikipedia\
    .org/wiki/Classless_Inter-Domain_Routing)\n\x20notation\x20(e.g.\x20`10.\
    96.0.0/14`)\x20from\x20the\x20RFC-1918\x20private\x20networks\x20(e.g.\n\
    \x20`10.0.0.0/8`,\x20`172.16.0.0/12`,\x20`192.168.0.0/16`)\x20to\x20pick\
    \x20a\x20specific\x20range\n\x20to\x20use.\n\n\r\n\x05\x04\x11\x02\x0b\
    \x05\x12\x04\x99\x07\x02\x08\n\r\n\x05\x04\x11\x02\x0b\x01\x12\x04\x99\
    \x07\t\x1c\n\r\n\x05\x04\x11\x02\x0b\x03\x12\x04\x99\x07\x1f!\n3\n\x02\
    \x04\x12\x12\x06\x9d\x07\0\xb0\t\x01\x1a%\x20A\x20Google\x20Kubernetes\
    \x20Engine\x20cluster.\n\n\x0b\n\x03\x04\x12\x01\x12\x04\x9d\x07\x08\x0f\
    \n4\n\x04\x04\x12\x04\0\x12\x06\x9f\x07\x02\xb9\x07\x03\x1a$\x20The\x20c\
    urrent\x20status\x20of\x20the\x20cluster.\n\n\r\n\x05\x04\x12\x04\0\x01\
    \x12\x04\x9f\x07\x07\r\n\x1a\n\x06\x04\x12\x04\0\x02\0\x12\x04\xa1\x07\
    \x04\x1b\x1a\n\x20Not\x20set.\n\n\x0f\n\x07\x04\x12\x04\0\x02\0\x01\x12\
    \x04\xa1\x07\x04\x16\n\x0f\n\x07\x04\x12\x04\0\x02\0\x02\x12\x04\xa1\x07\
    \x19\x1a\nP\n\x06\x04\x12\x04\0\x02\x01\x12\x04\xa4\x07\x04\x15\x1a@\x20\
    The\x20PROVISIONING\x20state\x20indicates\x20the\x20cluster\x20is\x20bei\
    ng\x20created.\n\n\x0f\n\x07\x04\x12\x04\0\x02\x01\x01\x12\x04\xa4\x07\
    \x04\x10\n\x0f\n\x07\x04\x12\x04\0\x02\x01\x02\x12\x04\xa4\x07\x13\x14\n\
    `\n\x06\x04\x12\x04\0\x02\x02\x12\x04\xa8\x07\x04\x10\x1aP\x20The\x20RUN\
    NING\x20state\x20indicates\x20the\x20cluster\x20has\x20been\x20created\
    \x20and\x20is\x20fully\n\x20usable.\n\n\x0f\n\x07\x04\x12\x04\0\x02\x02\
    \x01\x12\x04\xa8\x07\x04\x0b\n\x0f\n\x07\x04\x12\x04\0\x02\x02\x02\x12\
    \x04\xa8\x07\x0e\x0f\n\xcc\x01\n\x06\x04\x12\x04\0\x02\x03\x12\x04\xad\
    \x07\x04\x14\x1a\xbb\x01\x20The\x20RECONCILING\x20state\x20indicates\x20\
    that\x20some\x20work\x20is\x20actively\x20being\x20done\x20on\n\x20the\
    \x20cluster,\x20such\x20as\x20upgrading\x20the\x20master\x20or\x20node\
    \x20software.\x20Details\x20can\n\x20be\x20found\x20in\x20the\x20`status\
    Message`\x20field.\n\n\x0f\n\x07\x04\x12\x04\0\x02\x03\x01\x12\x04\xad\
    \x07\x04\x0f\n\x0f\n\x07\x04\x12\x04\0\x02\x03\x02\x12\x04\xad\x07\x12\
    \x13\nL\n\x06\x04\x12\x04\0\x02\x04\x12\x04\xb0\x07\x04\x11\x1a<\x20The\
    \x20STOPPING\x20state\x20indicates\x20the\x20cluster\x20is\x20being\x20d\
    eleted.\n\n\x0f\n\x07\x04\x12\x04\0\x02\x04\x01\x12\x04\xb0\x07\x04\x0c\
    \n\x0f\n\x07\x04\x12\x04\0\x02\x04\x02\x12\x04\xb0\x07\x0f\x10\n|\n\x06\
    \x04\x12\x04\0\x02\x05\x12\x04\xb4\x07\x04\x0e\x1al\x20The\x20ERROR\x20s\
    tate\x20indicates\x20the\x20cluster\x20may\x20be\x20unusable.\x20Details\
    \n\x20can\x20be\x20found\x20in\x20the\x20`statusMessage`\x20field.\n\n\
    \x0f\n\x07\x04\x12\x04\0\x02\x05\x01\x12\x04\xb4\x07\x04\t\n\x0f\n\x07\
    \x04\x12\x04\0\x02\x05\x02\x12\x04\xb4\x07\x0c\r\n\xa3\x01\n\x06\x04\x12\
    \x04\0\x02\x06\x12\x04\xb8\x07\x04\x11\x1a\x92\x01\x20The\x20DEGRADED\
    \x20state\x20indicates\x20the\x20cluster\x20requires\x20user\x20action\
    \x20to\x20restore\n\x20full\x20functionality.\x20Details\x20can\x20be\
    \x20found\x20in\x20the\x20`statusMessage`\x20field.\n\n\x0f\n\x07\x04\
    \x12\x04\0\x02\x06\x01\x12\x04\xb8\x07\x04\x0c\n\x0f\n\x07\x04\x12\x04\0\
    \x02\x06\x02\x12\x04\xb8\x07\x0f\x10\n\xb2\x02\n\x04\x04\x12\x02\0\x12\
    \x04\xc2\x07\x02\x12\x1a\xa3\x02\x20The\x20name\x20of\x20this\x20cluster\
    .\x20The\x20name\x20must\x20be\x20unique\x20within\x20this\x20project\n\
    \x20and\x20location\x20(e.g.\x20zone\x20or\x20region),\x20and\x20can\x20\
    be\x20up\x20to\x2040\x20characters\x20with\n\x20the\x20following\x20rest\
    rictions:\n\n\x20*\x20Lowercase\x20letters,\x20numbers,\x20and\x20hyphen\
    s\x20only.\n\x20*\x20Must\x20start\x20with\x20a\x20letter.\n\x20*\x20Mus\
    t\x20end\x20with\x20a\x20number\x20or\x20a\x20letter.\n\n\r\n\x05\x04\
    \x12\x02\0\x05\x12\x04\xc2\x07\x02\x08\n\r\n\x05\x04\x12\x02\0\x01\x12\
    \x04\xc2\x07\t\r\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xc2\x07\x10\x11\n8\
    \n\x04\x04\x12\x02\x01\x12\x04\xc5\x07\x02\x19\x1a*\x20An\x20optional\
    \x20description\x20of\x20this\x20cluster.\n\n\r\n\x05\x04\x12\x02\x01\
    \x05\x12\x04\xc5\x07\x02\x08\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xc5\
    \x07\t\x14\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xc5\x07\x17\x18\n\xd4\
    \x04\n\x04\x04\x12\x02\x02\x12\x04\xd1\x07\x023\x1a\xc5\x04\x20The\x20nu\
    mber\x20of\x20nodes\x20to\x20create\x20in\x20this\x20cluster.\x20You\x20\
    must\x20ensure\x20that\x20your\n\x20Compute\x20Engine\x20<a\x20href=\"/c\
    ompute/docs/resource-quotas\">resource\x20quota</a>\n\x20is\x20sufficien\
    t\x20for\x20this\x20number\x20of\x20instances.\x20You\x20must\x20also\
    \x20have\x20available\n\x20firewall\x20and\x20routes\x20quota.\n\x20For\
    \x20requests,\x20this\x20field\x20should\x20only\x20be\x20used\x20in\x20\
    lieu\x20of\x20a\n\x20\"node_pool\"\x20object,\x20since\x20this\x20config\
    uration\x20(along\x20with\x20the\n\x20\"node_config\")\x20will\x20be\x20\
    used\x20to\x20create\x20a\x20\"NodePool\"\x20object\x20with\x20an\n\x20a\
    uto-generated\x20name.\x20Do\x20not\x20use\x20this\x20and\x20a\x20node_p\
    ool\x20at\x20the\x20same\x20time.\n\n\x20This\x20field\x20is\x20deprecat\
    ed,\x20use\x20node_pool.initial_node_count\x20instead.\n\n\r\n\x05\x04\
    \x12\x02\x02\x05\x12\x04\xd1\x07\x02\x07\n\r\n\x05\x04\x12\x02\x02\x01\
    \x12\x04\xd1\x07\x08\x1a\n\r\n\x05\x04\x12\x02\x02\x03\x12\x04\xd1\x07\
    \x1d\x1e\n\r\n\x05\x04\x12\x02\x02\x08\x12\x04\xd1\x07\x1f2\n\x0e\n\x06\
    \x04\x12\x02\x02\x08\x03\x12\x04\xd1\x07\x201\n\xcf\x04\n\x04\x04\x12\
    \x02\x03\x12\x04\xde\x07\x021\x1a\xc0\x04\x20Parameters\x20used\x20in\
    \x20creating\x20the\x20cluster's\x20nodes.\n\x20For\x20requests,\x20this\
    \x20field\x20should\x20only\x20be\x20used\x20in\x20lieu\x20of\x20a\n\x20\
    \"node_pool\"\x20object,\x20since\x20this\x20configuration\x20(along\x20\
    with\x20the\n\x20\"initial_node_count\")\x20will\x20be\x20used\x20to\x20\
    create\x20a\x20\"NodePool\"\x20object\x20with\x20an\n\x20auto-generated\
    \x20name.\x20Do\x20not\x20use\x20this\x20and\x20a\x20node_pool\x20at\x20\
    the\x20same\x20time.\n\x20For\x20responses,\x20this\x20field\x20will\x20\
    be\x20populated\x20with\x20the\x20node\x20configuration\x20of\n\x20the\
    \x20first\x20node\x20pool.\x20(For\x20configuration\x20of\x20each\x20nod\
    e\x20pool,\x20see\n\x20`node_pool.config`)\n\n\x20If\x20unspecified,\x20\
    the\x20defaults\x20are\x20used.\n\x20This\x20field\x20is\x20deprecated,\
    \x20use\x20node_pool.config\x20instead.\n\n\r\n\x05\x04\x12\x02\x03\x06\
    \x12\x04\xde\x07\x02\x0c\n\r\n\x05\x04\x12\x02\x03\x01\x12\x04\xde\x07\r\
    \x18\n\r\n\x05\x04\x12\x02\x03\x03\x12\x04\xde\x07\x1b\x1c\n\r\n\x05\x04\
    \x12\x02\x03\x08\x12\x04\xde\x07\x1d0\n\x0e\n\x06\x04\x12\x02\x03\x08\
    \x03\x12\x04\xde\x07\x1e/\n\xa8\x02\n\x04\x04\x12\x02\x04\x12\x04\xe5\
    \x07\x02\x1d\x1a\x99\x02\x20The\x20authentication\x20information\x20for\
    \x20accessing\x20the\x20master\x20endpoint.\n\x20If\x20unspecified,\x20t\
    he\x20defaults\x20are\x20used:\n\x20For\x20clusters\x20before\x20v1.12,\
    \x20if\x20master_auth\x20is\x20unspecified,\x20`username`\x20will\n\x20b\
    e\x20set\x20to\x20\"admin\",\x20a\x20random\x20password\x20will\x20be\
    \x20generated,\x20and\x20a\x20client\n\x20certificate\x20will\x20be\x20i\
    ssued.\n\n\r\n\x05\x04\x12\x02\x04\x06\x12\x04\xe5\x07\x02\x0c\n\r\n\x05\
    \x04\x12\x02\x04\x01\x12\x04\xe5\x07\r\x18\n\r\n\x05\x04\x12\x02\x04\x03\
    \x12\x04\xe5\x07\x1b\x1c\n\x96\x03\n\x04\x04\x12\x02\x05\x12\x04\xef\x07\
    \x02\x1d\x1a\x87\x03\x20The\x20logging\x20service\x20the\x20cluster\x20s\
    hould\x20use\x20to\x20write\x20logs.\n\x20Currently\x20available\x20opti\
    ons:\n\n\x20*\x20\"logging.googleapis.com/kubernetes\"\x20-\x20the\x20Go\
    ogle\x20Cloud\x20Logging\n\x20service\x20with\x20Kubernetes-native\x20re\
    source\x20model\n\x20*\x20`logging.googleapis.com`\x20-\x20the\x20Google\
    \x20Cloud\x20Logging\x20service.\n\x20*\x20`none`\x20-\x20no\x20logs\x20\
    will\x20be\x20exported\x20from\x20the\x20cluster.\n\x20*\x20if\x20left\
    \x20as\x20an\x20empty\x20string,`logging.googleapis.com`\x20will\x20be\
    \x20used.\n\n\r\n\x05\x04\x12\x02\x05\x05\x12\x04\xef\x07\x02\x08\n\r\n\
    \x05\x04\x12\x02\x05\x01\x12\x04\xef\x07\t\x18\n\r\n\x05\x04\x12\x02\x05\
    \x03\x12\x04\xef\x07\x1b\x1c\n\xb8\x02\n\x04\x04\x12\x02\x06\x12\x04\xf7\
    \x07\x02\x20\x1a\xa9\x02\x20The\x20monitoring\x20service\x20the\x20clust\
    er\x20should\x20use\x20to\x20write\x20metrics.\n\x20Currently\x20availab\
    le\x20options:\n\n\x20*\x20`monitoring.googleapis.com`\x20-\x20the\x20Go\
    ogle\x20Cloud\x20Monitoring\x20service.\n\x20*\x20`none`\x20-\x20no\x20m\
    etrics\x20will\x20be\x20exported\x20from\x20the\x20cluster.\n\x20*\x20if\
    \x20left\x20as\x20an\x20empty\x20string,\x20`monitoring.googleapis.com`\
    \x20will\x20be\x20used.\n\n\r\n\x05\x04\x12\x02\x06\x05\x12\x04\xf7\x07\
    \x02\x08\n\r\n\x05\x04\x12\x02\x06\x01\x12\x04\xf7\x07\t\x1b\n\r\n\x05\
    \x04\x12\x02\x06\x03\x12\x04\xf7\x07\x1e\x1f\n\xce\x01\n\x04\x04\x12\x02\
    \x07\x12\x04\xfd\x07\x02\x15\x1a\xbf\x01\x20The\x20name\x20of\x20the\x20\
    Google\x20Compute\x20Engine\n\x20[network](/compute/docs/networks-and-fi\
    rewalls#networks)\x20to\x20which\x20the\n\x20cluster\x20is\x20connected.\
    \x20If\x20left\x20unspecified,\x20the\x20`default`\x20network\n\x20will\
    \x20be\x20used.\n\n\r\n\x05\x04\x12\x02\x07\x05\x12\x04\xfd\x07\x02\x08\
    \n\r\n\x05\x04\x12\x02\x07\x01\x12\x04\xfd\x07\t\x10\n\r\n\x05\x04\x12\
    \x02\x07\x03\x12\x04\xfd\x07\x13\x14\n\x8d\x02\n\x04\x04\x12\x02\x08\x12\
    \x04\x83\x08\x02\x1f\x1a\xfe\x01\x20The\x20IP\x20address\x20range\x20of\
    \x20the\x20container\x20pods\x20in\x20this\x20cluster,\x20in\n\x20[CIDR]\
    (http://en.wikipedia.org/wiki/Classless_Inter-Domain_Routing)\n\x20notat\
    ion\x20(e.g.\x20`10.96.0.0/14`).\x20Leave\x20blank\x20to\x20have\n\x20on\
    e\x20automatically\x20chosen\x20or\x20specify\x20a\x20`/14`\x20block\x20\
    in\x20`10.0.0.0/8`.\n\n\r\n\x05\x04\x12\x02\x08\x05\x12\x04\x83\x08\x02\
    \x08\n\r\n\x05\x04\x12\x02\x08\x01\x12\x04\x83\x08\t\x1a\n\r\n\x05\x04\
    \x12\x02\x08\x03\x12\x04\x83\x08\x1d\x1e\nV\n\x04\x04\x12\x02\t\x12\x04\
    \x86\x08\x02\"\x1aH\x20Configurations\x20for\x20the\x20various\x20addons\
    \x20available\x20to\x20run\x20in\x20the\x20cluster.\n\n\r\n\x05\x04\x12\
    \x02\t\x06\x12\x04\x86\x08\x02\x0e\n\r\n\x05\x04\x12\x02\t\x01\x12\x04\
    \x86\x08\x0f\x1c\n\r\n\x05\x04\x12\x02\t\x03\x12\x04\x86\x08\x1f!\n\x82\
    \x01\n\x04\x04\x12\x02\n\x12\x04\x8b\x08\x02\x19\x1at\x20The\x20name\x20\
    of\x20the\x20Google\x20Compute\x20Engine\n\x20[subnetwork](/compute/docs\
    /subnetworks)\x20to\x20which\x20the\n\x20cluster\x20is\x20connected.\n\n\
    \r\n\x05\x04\x12\x02\n\x05\x12\x04\x8b\x08\x02\x08\n\r\n\x05\x04\x12\x02\
    \n\x01\x12\x04\x8b\x08\t\x13\n\r\n\x05\x04\x12\x02\n\x03\x12\x04\x8b\x08\
    \x16\x18\n\x94\x01\n\x04\x04\x12\x02\x0b\x12\x04\x90\x08\x02$\x1a\x85\
    \x01\x20The\x20node\x20pools\x20associated\x20with\x20this\x20cluster.\n\
    \x20This\x20field\x20should\x20not\x20be\x20set\x20if\x20\"node_config\"\
    \x20or\x20\"initial_node_count\"\x20are\n\x20specified.\n\n\r\n\x05\x04\
    \x12\x02\x0b\x04\x12\x04\x90\x08\x02\n\n\r\n\x05\x04\x12\x02\x0b\x06\x12\
    \x04\x90\x08\x0b\x13\n\r\n\x05\x04\x12\x02\x0b\x01\x12\x04\x90\x08\x14\
    \x1e\n\r\n\x05\x04\x12\x02\x0b\x03\x12\x04\x90\x08!#\n\x8a\x01\n\x04\x04\
    \x12\x02\x0c\x12\x04\x95\x08\x02!\x1a|\x20The\x20list\x20of\x20Google\
    \x20Compute\x20Engine\n\x20[zones](/compute/docs/zones#available)\x20in\
    \x20which\x20the\x20cluster's\x20nodes\n\x20should\x20be\x20located.\n\n\
    \r\n\x05\x04\x12\x02\x0c\x04\x12\x04\x95\x08\x02\n\n\r\n\x05\x04\x12\x02\
    \x0c\x05\x12\x04\x95\x08\x0b\x11\n\r\n\x05\x04\x12\x02\x0c\x01\x12\x04\
    \x95\x08\x12\x1b\n\r\n\x05\x04\x12\x02\x0c\x03\x12\x04\x95\x08\x1e\x20\n\
    \xf2\x02\n\x04\x04\x12\x02\r\x12\x04\x9d\x08\x02$\x1a\xe3\x02\x20Kuberne\
    tes\x20alpha\x20features\x20are\x20enabled\x20on\x20this\x20cluster.\x20\
    This\x20includes\x20alpha\n\x20API\x20groups\x20(e.g.\x20v1alpha1)\x20an\
    d\x20features\x20that\x20may\x20not\x20be\x20production\x20ready\x20in\n\
    \x20the\x20kubernetes\x20version\x20of\x20the\x20master\x20and\x20nodes.\
    \n\x20The\x20cluster\x20has\x20no\x20SLA\x20for\x20uptime\x20and\x20mast\
    er/node\x20upgrades\x20are\x20disabled.\n\x20Alpha\x20enabled\x20cluster\
    s\x20are\x20automatically\x20deleted\x20thirty\x20days\x20after\n\x20cre\
    ation.\n\n\r\n\x05\x04\x12\x02\r\x05\x12\x04\x9d\x08\x02\x06\n\r\n\x05\
    \x04\x12\x02\r\x01\x12\x04\x9d\x08\x07\x1e\n\r\n\x05\x04\x12\x02\r\x03\
    \x12\x04\x9d\x08!#\nt\n\x04\x04\x12\x02\x0e\x12\x04\xa1\x08\x02+\x1af\
    \x20The\x20resource\x20labels\x20for\x20the\x20cluster\x20to\x20use\x20t\
    o\x20annotate\x20any\x20related\n\x20Google\x20Compute\x20Engine\x20reso\
    urces.\n\n\r\n\x05\x04\x12\x02\x0e\x06\x12\x04\xa1\x08\x02\x15\n\r\n\x05\
    \x04\x12\x02\x0e\x01\x12\x04\xa1\x08\x16%\n\r\n\x05\x04\x12\x02\x0e\x03\
    \x12\x04\xa1\x08(*\nF\n\x04\x04\x12\x02\x0f\x12\x04\xa4\x08\x02\x20\x1a8\
    \x20The\x20fingerprint\x20of\x20the\x20set\x20of\x20labels\x20for\x20thi\
    s\x20cluster.\n\n\r\n\x05\x04\x12\x02\x0f\x05\x12\x04\xa4\x08\x02\x08\n\
    \r\n\x05\x04\x12\x02\x0f\x01\x12\x04\xa4\x08\t\x1a\n\r\n\x05\x04\x12\x02\
    \x0f\x03\x12\x04\xa4\x08\x1d\x1f\nE\n\x04\x04\x12\x02\x10\x12\x04\xa7\
    \x08\x02\x1e\x1a7\x20Configuration\x20for\x20the\x20legacy\x20ABAC\x20au\
    thorization\x20mode.\n\n\r\n\x05\x04\x12\x02\x10\x06\x12\x04\xa7\x08\x02\
    \x0c\n\r\n\x05\x04\x12\x02\x10\x01\x12\x04\xa7\x08\r\x18\n\r\n\x05\x04\
    \x12\x02\x10\x03\x12\x04\xa7\x08\x1b\x1d\nD\n\x04\x04\x12\x02\x11\x12\
    \x04\xaa\x08\x02$\x1a6\x20Configuration\x20options\x20for\x20the\x20Netw\
    orkPolicy\x20feature.\n\n\r\n\x05\x04\x12\x02\x11\x06\x12\x04\xaa\x08\
    \x02\x0f\n\r\n\x05\x04\x12\x02\x11\x01\x12\x04\xaa\x08\x10\x1e\n\r\n\x05\
    \x04\x12\x02\x11\x03\x12\x04\xaa\x08!#\n8\n\x04\x04\x12\x02\x12\x12\x04\
    \xad\x08\x02/\x1a*\x20Configuration\x20for\x20cluster\x20IP\x20allocatio\
    n.\n\n\r\n\x05\x04\x12\x02\x12\x06\x12\x04\xad\x08\x02\x14\n\r\n\x05\x04\
    \x12\x02\x12\x01\x12\x04\xad\x08\x15)\n\r\n\x05\x04\x12\x02\x12\x03\x12\
    \x04\xad\x08,.\nQ\n\x04\x04\x12\x02\x13\x12\x04\xb0\x08\x02H\x1aC\x20The\
    \x20configuration\x20options\x20for\x20master\x20authorized\x20networks\
    \x20feature.\n\n\r\n\x05\x04\x12\x02\x13\x06\x12\x04\xb0\x08\x02\x20\n\r\
    \n\x05\x04\x12\x02\x13\x01\x12\x04\xb0\x08!B\n\r\n\x05\x04\x12\x02\x13\
    \x03\x12\x04\xb0\x08EG\nB\n\x04\x04\x12\x02\x14\x12\x04\xb3\x08\x02,\x1a\
    4\x20Configure\x20the\x20maintenance\x20policy\x20for\x20this\x20cluster\
    .\n\n\r\n\x05\x04\x12\x02\x14\x06\x12\x04\xb3\x08\x02\x13\n\r\n\x05\x04\
    \x12\x02\x14\x01\x12\x04\xb3\x08\x14&\n\r\n\x05\x04\x12\x02\x14\x03\x12\
    \x04\xb3\x08)+\n7\n\x04\x04\x12\x02\x15\x12\x04\xb6\x08\x020\x1a)\x20Con\
    figuration\x20for\x20Binary\x20Authorization.\n\n\r\n\x05\x04\x12\x02\
    \x15\x06\x12\x04\xb6\x08\x02\x15\n\r\n\x05\x04\x12\x02\x15\x01\x12\x04\
    \xb6\x08\x16*\n\r\n\x05\x04\x12\x02\x15\x03\x12\x04\xb6\x08-/\n8\n\x04\
    \x04\x12\x02\x16\x12\x04\xb9\x08\x02&\x1a*\x20Cluster-level\x20autoscali\
    ng\x20configuration.\n\n\r\n\x05\x04\x12\x02\x16\x06\x12\x04\xb9\x08\x02\
    \x14\n\r\n\x05\x04\x12\x02\x16\x01\x12\x04\xb9\x08\x15\x20\n\r\n\x05\x04\
    \x12\x02\x16\x03\x12\x04\xb9\x08#%\n5\n\x04\x04\x12\x02\x17\x12\x04\xbc\
    \x08\x02$\x1a'\x20Configuration\x20for\x20cluster\x20networking.\n\n\r\n\
    \x05\x04\x12\x02\x17\x06\x12\x04\xbc\x08\x02\x0f\n\r\n\x05\x04\x12\x02\
    \x17\x01\x12\x04\xbc\x08\x10\x1e\n\r\n\x05\x04\x12\x02\x17\x03\x12\x04\
    \xbc\x08!#\n\xc9\x01\n\x04\x04\x12\x02\x18\x12\x04\xc1\x08\x025\x1a\xba\
    \x01\x20The\x20default\x20constraint\x20on\x20the\x20maximum\x20number\
    \x20of\x20pods\x20that\x20can\x20be\x20run\n\x20simultaneously\x20on\x20\
    a\x20node\x20in\x20the\x20node\x20pool\x20of\x20this\x20cluster.\x20Only\
    \x20honored\n\x20if\x20cluster\x20created\x20with\x20IP\x20Alias\x20supp\
    ort.\n\n\r\n\x05\x04\x12\x02\x18\x06\x12\x04\xc1\x08\x02\x13\n\r\n\x05\
    \x04\x12\x02\x18\x01\x12\x04\xc1\x08\x14/\n\r\n\x05\x04\x12\x02\x18\x03\
    \x12\x04\xc1\x0824\n\x80\x01\n\x04\x04\x12\x02\x19\x12\x04\xc5\x08\x02>\
    \x1ar\x20Configuration\x20for\x20exporting\x20resource\x20usages.\x20Res\
    ource\x20usage\x20export\x20is\n\x20disabled\x20when\x20this\x20config\
    \x20is\x20unspecified.\n\n\r\n\x05\x04\x12\x02\x19\x06\x12\x04\xc5\x08\
    \x02\x1b\n\r\n\x05\x04\x12\x02\x19\x01\x12\x04\xc5\x08\x1c8\n\r\n\x05\
    \x04\x12\x02\x19\x03\x12\x04\xc5\x08;=\nL\n\x04\x04\x12\x02\x1a\x12\x04\
    \xc8\x08\x02=\x1a>\x20Configuration\x20controlling\x20RBAC\x20group\x20m\
    embership\x20information.\n\n\r\n\x05\x04\x12\x02\x1a\x06\x12\x04\xc8\
    \x08\x02\x1b\n\r\n\x05\x04\x12\x02\x1a\x01\x12\x04\xc8\x08\x1c7\n\r\n\
    \x05\x04\x12\x02\x1a\x03\x12\x04\xc8\x08:<\n2\n\x04\x04\x12\x02\x1b\x12\
    \x04\xcb\x08\x023\x1a$\x20Configuration\x20for\x20private\x20cluster.\n\
    \n\r\n\x05\x04\x12\x02\x1b\x06\x12\x04\xcb\x08\x02\x16\n\r\n\x05\x04\x12\
    \x02\x1b\x01\x12\x04\xcb\x08\x17-\n\r\n\x05\x04\x12\x02\x1b\x03\x12\x04\
    \xcb\x0802\n1\n\x04\x04\x12\x02\x1c\x12\x04\xce\x08\x02.\x1a#\x20Configu\
    ration\x20of\x20etcd\x20encryption.\n\n\r\n\x05\x04\x12\x02\x1c\x06\x12\
    \x04\xce\x08\x02\x14\n\r\n\x05\x04\x12\x02\x1c\x01\x12\x04\xce\x08\x15(\
    \n\r\n\x05\x04\x12\x02\x1c\x03\x12\x04\xce\x08+-\nE\n\x04\x04\x12\x02\
    \x1d\x12\x04\xd1\x08\x027\x1a7\x20Cluster-level\x20Vertical\x20Pod\x20Au\
    toscaling\x20configuration.\n\n\r\n\x05\x04\x12\x02\x1d\x06\x12\x04\xd1\
    \x08\x02\x18\n\r\n\x05\x04\x12\x02\x1d\x01\x12\x04\xd1\x08\x191\n\r\n\
    \x05\x04\x12\x02\x1d\x03\x12\x04\xd1\x0846\nB\n\x04\x04\x12\x02\x1e\x12\
    \x04\xd4\x08\x02\x19\x1a4\x20[Output\x20only]\x20Server-defined\x20URL\
    \x20for\x20the\x20resource.\n\n\r\n\x05\x04\x12\x02\x1e\x05\x12\x04\xd4\
    \x08\x02\x08\n\r\n\x05\x04\x12\x02\x1e\x01\x12\x04\xd4\x08\t\x12\n\r\n\
    \x05\x04\x12\x02\x1e\x03\x12\x04\xd4\x08\x15\x18\n\xbb\x01\n\x04\x04\x12\
    \x02\x1f\x12\x04\xda\x08\x02(\x1a\xac\x01\x20[Output\x20only]\x20The\x20\
    name\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/do\
    cs/zones#available)\x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20\
    This\x20field\x20is\x20deprecated,\x20use\x20location\x20instead.\n\n\r\
    \n\x05\x04\x12\x02\x1f\x05\x12\x04\xda\x08\x02\x08\n\r\n\x05\x04\x12\x02\
    \x1f\x01\x12\x04\xda\x08\t\r\n\r\n\x05\x04\x12\x02\x1f\x03\x12\x04\xda\
    \x08\x10\x13\n\r\n\x05\x04\x12\x02\x1f\x08\x12\x04\xda\x08\x14'\n\x0e\n\
    \x06\x04\x12\x02\x1f\x08\x03\x12\x04\xda\x08\x15&\n\x84\x02\n\x04\x04\
    \x12\x02\x20\x12\x04\xe2\x08\x02\x18\x1a\xf5\x01\x20[Output\x20only]\x20\
    The\x20IP\x20address\x20of\x20this\x20cluster's\x20master\x20endpoint.\n\
    \x20The\x20endpoint\x20can\x20be\x20accessed\x20from\x20the\x20internet\
    \x20at\n\x20`https://username:password@endpoint/`.\n\n\x20See\x20the\x20\
    `masterAuth`\x20property\x20of\x20this\x20resource\x20for\x20username\
    \x20and\n\x20password\x20information.\n\n\r\n\x05\x04\x12\x02\x20\x05\
    \x12\x04\xe2\x08\x02\x08\n\r\n\x05\x04\x12\x02\x20\x01\x12\x04\xe2\x08\t\
    \x11\n\r\n\x05\x04\x12\x02\x20\x03\x12\x04\xe2\x08\x14\x17\n\xba\x05\n\
    \x04\x04\x12\x02!\x12\x04\xf1\x08\x02'\x1a\xab\x05\x20The\x20initial\x20\
    Kubernetes\x20version\x20for\x20this\x20cluster.\x20\x20Valid\x20version\
    s\x20are\x20those\n\x20found\x20in\x20validMasterVersions\x20returned\
    \x20by\x20getServerConfig.\x20\x20The\x20version\x20can\n\x20be\x20upgra\
    ded\x20over\x20time;\x20such\x20upgrades\x20are\x20reflected\x20in\n\x20\
    currentMasterVersion\x20and\x20currentNodeVersion.\n\n\x20Users\x20may\
    \x20specify\x20either\x20explicit\x20versions\x20offered\x20by\n\x20Kube\
    rnetes\x20Engine\x20or\x20version\x20aliases,\x20which\x20have\x20the\
    \x20following\x20behavior:\n\n\x20-\x20\"latest\":\x20picks\x20the\x20hi\
    ghest\x20valid\x20Kubernetes\x20version\n\x20-\x20\"1.X\":\x20picks\x20t\
    he\x20highest\x20valid\x20patch+gke.N\x20patch\x20in\x20the\x201.X\x20ve\
    rsion\n\x20-\x20\"1.X.Y\":\x20picks\x20the\x20highest\x20valid\x20gke.N\
    \x20patch\x20in\x20the\x201.X.Y\x20version\n\x20-\x20\"1.X.Y-gke.N\":\
    \x20picks\x20an\x20explicit\x20Kubernetes\x20version\n\x20-\x20\"\",\"-\
    \":\x20picks\x20the\x20default\x20Kubernetes\x20version\n\n\r\n\x05\x04\
    \x12\x02!\x05\x12\x04\xf1\x08\x02\x08\n\r\n\x05\x04\x12\x02!\x01\x12\x04\
    \xf1\x08\t\x20\n\r\n\x05\x04\x12\x02!\x03\x12\x04\xf1\x08#&\nR\n\x04\x04\
    \x12\x02\"\x12\x04\xf4\x08\x02&\x1aD\x20[Output\x20only]\x20The\x20curre\
    nt\x20software\x20version\x20of\x20the\x20master\x20endpoint.\n\n\r\n\
    \x05\x04\x12\x02\"\x05\x12\x04\xf4\x08\x02\x08\n\r\n\x05\x04\x12\x02\"\
    \x01\x12\x04\xf4\x08\t\x1f\n\r\n\x05\x04\x12\x02\"\x03\x12\x04\xf4\x08\"\
    %\n\xde\x02\n\x04\x04\x12\x02#\x12\x04\xfb\x08\x028\x1a\xcf\x02\x20[Outp\
    ut\x20only]\x20Deprecated,\x20use\n\x20[NodePools.version](/kubernetes-e\
    ngine/docs/reference/rest/v1/projects.zones.clusters.nodePools)\n\x20ins\
    tead.\x20The\x20current\x20version\x20of\x20the\x20node\x20software\x20c\
    omponents.\x20If\x20they\x20are\n\x20currently\x20at\x20multiple\x20vers\
    ions\x20because\x20they're\x20in\x20the\x20process\x20of\x20being\n\x20u\
    pgraded,\x20this\x20reflects\x20the\x20minimum\x20version\x20of\x20all\
    \x20nodes.\n\n\r\n\x05\x04\x12\x02#\x05\x12\x04\xfb\x08\x02\x08\n\r\n\
    \x05\x04\x12\x02#\x01\x12\x04\xfb\x08\t\x1d\n\r\n\x05\x04\x12\x02#\x03\
    \x12\x04\xfb\x08\x20#\n\r\n\x05\x04\x12\x02#\x08\x12\x04\xfb\x08$7\n\x0e\
    \n\x06\x04\x12\x02#\x08\x03\x12\x04\xfb\x08%6\n\x80\x01\n\x04\x04\x12\
    \x02$\x12\x04\xff\x08\x02\x1b\x1ar\x20[Output\x20only]\x20The\x20time\
    \x20the\x20cluster\x20was\x20created,\x20in\n\x20[RFC3339](https://www.i\
    etf.org/rfc/rfc3339.txt)\x20text\x20format.\n\n\r\n\x05\x04\x12\x02$\x05\
    \x12\x04\xff\x08\x02\x08\n\r\n\x05\x04\x12\x02$\x01\x12\x04\xff\x08\t\
    \x14\n\r\n\x05\x04\x12\x02$\x03\x12\x04\xff\x08\x17\x1a\nA\n\x04\x04\x12\
    \x02%\x12\x04\x82\t\x02\x16\x1a3\x20[Output\x20only]\x20The\x20current\
    \x20status\x20of\x20this\x20cluster.\n\n\r\n\x05\x04\x12\x02%\x06\x12\
    \x04\x82\t\x02\x08\n\r\n\x05\x04\x12\x02%\x01\x12\x04\x82\t\t\x0f\n\r\n\
    \x05\x04\x12\x02%\x03\x12\x04\x82\t\x12\x15\nm\n\x04\x04\x12\x02&\x12\
    \x04\x86\t\x02\x1e\x1a_\x20[Output\x20only]\x20Additional\x20information\
    \x20about\x20the\x20current\x20status\x20of\x20this\n\x20cluster,\x20if\
    \x20available.\n\n\r\n\x05\x04\x12\x02&\x05\x12\x04\x86\t\x02\x08\n\r\n\
    \x05\x04\x12\x02&\x01\x12\x04\x86\t\t\x17\n\r\n\x05\x04\x12\x02&\x03\x12\
    \x04\x86\t\x1a\x1d\n\xee\x01\n\x04\x04\x12\x02'\x12\x04\x8c\t\x02\"\x1a\
    \xdf\x01\x20[Output\x20only]\x20The\x20size\x20of\x20the\x20address\x20s\
    pace\x20on\x20each\x20node\x20for\x20hosting\n\x20containers.\x20This\
    \x20is\x20provisioned\x20from\x20within\x20the\x20`container_ipv4_cidr`\
    \n\x20range.\x20This\x20field\x20will\x20only\x20be\x20set\x20when\x20cl\
    uster\x20is\x20in\x20route-based\x20network\n\x20mode.\n\n\r\n\x05\x04\
    \x12\x02'\x05\x12\x04\x8c\t\x02\x07\n\r\n\x05\x04\x12\x02'\x01\x12\x04\
    \x8c\t\x08\x1b\n\r\n\x05\x04\x12\x02'\x03\x12\x04\x8c\t\x1e!\n\x97\x02\n\
    \x04\x04\x12\x02(\x12\x04\x93\t\x02\"\x1a\x88\x02\x20[Output\x20only]\
    \x20The\x20IP\x20address\x20range\x20of\x20the\x20Kubernetes\x20services\
    \x20in\n\x20this\x20cluster,\x20in\n\x20[CIDR](http://en.wikipedia.org/w\
    iki/Classless_Inter-Domain_Routing)\n\x20notation\x20(e.g.\x20`1.2.3.4/2\
    9`).\x20Service\x20addresses\x20are\n\x20typically\x20put\x20in\x20the\
    \x20last\x20`/16`\x20from\x20the\x20container\x20CIDR.\n\n\r\n\x05\x04\
    \x12\x02(\x05\x12\x04\x93\t\x02\x08\n\r\n\x05\x04\x12\x02(\x01\x12\x04\
    \x93\t\t\x1b\n\r\n\x05\x04\x12\x02(\x03\x12\x04\x93\t\x1e!\n?\n\x04\x04\
    \x12\x02)\x12\x04\x96\t\x02@\x1a1\x20Deprecated.\x20Use\x20node_pools.in\
    stance_group_urls.\n\n\r\n\x05\x04\x12\x02)\x04\x12\x04\x96\t\x02\n\n\r\
    \n\x05\x04\x12\x02)\x05\x12\x04\x96\t\x0b\x11\n\r\n\x05\x04\x12\x02)\x01\
    \x12\x04\x96\t\x12%\n\r\n\x05\x04\x12\x02)\x03\x12\x04\x96\t(+\n\r\n\x05\
    \x04\x12\x02)\x08\x12\x04\x96\t,?\n\x0e\n\x06\x04\x12\x02)\x08\x03\x12\
    \x04\x96\t->\n\x95\x01\n\x04\x04\x12\x02*\x12\x04\x9a\t\x025\x1a\x86\x01\
    \x20[Output\x20only]\x20\x20The\x20number\x20of\x20nodes\x20currently\
    \x20in\x20the\x20cluster.\x20Deprecated.\n\x20Call\x20Kubernetes\x20API\
    \x20directly\x20to\x20retrieve\x20node\x20information.\n\n\r\n\x05\x04\
    \x12\x02*\x05\x12\x04\x9a\t\x02\x07\n\r\n\x05\x04\x12\x02*\x01\x12\x04\
    \x9a\t\x08\x1a\n\r\n\x05\x04\x12\x02*\x03\x12\x04\x9a\t\x1d\x20\n\r\n\
    \x05\x04\x12\x02*\x08\x12\x04\x9a\t!4\n\x0e\n\x06\x04\x12\x02*\x08\x03\
    \x12\x04\x9a\t\"3\n\x92\x01\n\x04\x04\x12\x02+\x12\x04\x9e\t\x02\x1b\x1a\
    \x83\x01\x20[Output\x20only]\x20The\x20time\x20the\x20cluster\x20will\
    \x20be\x20automatically\n\x20deleted\x20in\x20[RFC3339](https://www.ietf\
    .org/rfc/rfc3339.txt)\x20text\x20format.\n\n\r\n\x05\x04\x12\x02+\x05\
    \x12\x04\x9e\t\x02\x08\n\r\n\x05\x04\x12\x02+\x01\x12\x04\x9e\t\t\x14\n\
    \r\n\x05\x04\x12\x02+\x03\x12\x04\x9e\t\x17\x1a\n\xe2\x01\n\x04\x04\x12\
    \x02,\x12\x04\xa4\t\x02\x18\x1a\xd3\x01\x20[Output\x20only]\x20The\x20na\
    me\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/docs\
    /regions-zones/regions-zones#available)\x20or\n\x20[region](/compute/doc\
    s/regions-zones/regions-zones#available)\x20in\x20which\n\x20the\x20clus\
    ter\x20resides.\n\n\r\n\x05\x04\x12\x02,\x05\x12\x04\xa4\t\x02\x08\n\r\n\
    \x05\x04\x12\x02,\x01\x12\x04\xa4\t\t\x11\n\r\n\x05\x04\x12\x02,\x03\x12\
    \x04\xa4\t\x14\x17\nE\n\x04\x04\x12\x02-\x12\x04\xa7\t\x02\x18\x1a7\x20E\
    nable\x20the\x20ability\x20to\x20use\x20Cloud\x20TPUs\x20in\x20this\x20c\
    luster.\n\n\r\n\x05\x04\x12\x02-\x05\x12\x04\xa7\t\x02\x06\n\r\n\x05\x04\
    \x12\x02-\x01\x12\x04\xa7\t\x07\x11\n\r\n\x05\x04\x12\x02-\x03\x12\x04\
    \xa7\t\x14\x17\n\xbd\x01\n\x04\x04\x12\x02.\x12\x04\xac\t\x02#\x1a\xae\
    \x01\x20[Output\x20only]\x20The\x20IP\x20address\x20range\x20of\x20the\
    \x20Cloud\x20TPUs\x20in\x20this\x20cluster,\x20in\n\x20[CIDR](http://en.\
    wikipedia.org/wiki/Classless_Inter-Domain_Routing)\n\x20notation\x20(e.g\
    .\x20`1.2.3.4/29`).\n\n\r\n\x05\x04\x12\x02.\x05\x12\x04\xac\t\x02\x08\n\
    \r\n\x05\x04\x12\x02.\x01\x12\x04\xac\t\t\x1c\n\r\n\x05\x04\x12\x02.\x03\
    \x12\x04\xac\t\x1f\"\nB\n\x04\x04\x12\x02/\x12\x04\xaf\t\x02,\x1a4\x20Wh\
    ich\x20conditions\x20caused\x20the\x20current\x20cluster\x20state.\n\n\r\
    \n\x05\x04\x12\x02/\x04\x12\x04\xaf\t\x02\n\n\r\n\x05\x04\x12\x02/\x06\
    \x12\x04\xaf\t\x0b\x1a\n\r\n\x05\x04\x12\x02/\x01\x12\x04\xaf\t\x1b%\n\r\
    \n\x05\x04\x12\x02/\x03\x12\x04\xaf\t(+\n\xac\x01\n\x02\x04\x13\x12\x06\
    \xb5\t\0\x91\n\x01\x1a\x9d\x01\x20ClusterUpdate\x20describes\x20an\x20up\
    date\x20to\x20the\x20cluster.\x20Exactly\x20one\x20update\x20can\n\x20be\
    \x20applied\x20to\x20a\x20cluster\x20with\x20each\x20request,\x20so\x20a\
    t\x20most\x20one\x20field\x20can\x20be\n\x20provided.\n\n\x0b\n\x03\x04\
    \x13\x01\x12\x04\xb5\t\x08\x15\n\x81\x04\n\x04\x04\x13\x02\0\x12\x04\xc1\
    \t\x02\"\x1a\xf2\x03\x20The\x20Kubernetes\x20version\x20to\x20change\x20\
    the\x20nodes\x20to\x20(typically\x20an\n\x20upgrade).\n\n\x20Users\x20ma\
    y\x20specify\x20either\x20explicit\x20versions\x20offered\x20by\n\x20Kub\
    ernetes\x20Engine\x20or\x20version\x20aliases,\x20which\x20have\x20the\
    \x20following\x20behavior:\n\n\x20-\x20\"latest\":\x20picks\x20the\x20hi\
    ghest\x20valid\x20Kubernetes\x20version\n\x20-\x20\"1.X\":\x20picks\x20t\
    he\x20highest\x20valid\x20patch+gke.N\x20patch\x20in\x20the\x201.X\x20ve\
    rsion\n\x20-\x20\"1.X.Y\":\x20picks\x20the\x20highest\x20valid\x20gke.N\
    \x20patch\x20in\x20the\x201.X.Y\x20version\n\x20-\x20\"1.X.Y-gke.N\":\
    \x20picks\x20an\x20explicit\x20Kubernetes\x20version\n\x20-\x20\"-\":\
    \x20picks\x20the\x20Kubernetes\x20master\x20version\n\n\r\n\x05\x04\x13\
    \x02\0\x05\x12\x04\xc1\t\x02\x08\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xc1\
    \t\t\x1d\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xc1\t\x20!\n\xe4\x02\n\x04\
    \x04\x13\x02\x01\x12\x04\xca\t\x02(\x1a\xd5\x02\x20The\x20monitoring\x20\
    service\x20the\x20cluster\x20should\x20use\x20to\x20write\x20metrics.\n\
    \x20Currently\x20available\x20options:\n\n\x20*\x20\"monitoring.googleap\
    is.com/kubernetes\"\x20-\x20the\x20Google\x20Cloud\x20Monitoring\n\x20se\
    rvice\x20with\x20Kubernetes-native\x20resource\x20model\n\x20*\x20\"moni\
    toring.googleapis.com\"\x20-\x20the\x20Google\x20Cloud\x20Monitoring\x20\
    service\n\x20*\x20\"none\"\x20-\x20no\x20metrics\x20will\x20be\x20export\
    ed\x20from\x20the\x20cluster\n\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xca\
    \t\x02\x08\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xca\t\t#\n\r\n\x05\x04\
    \x13\x02\x01\x03\x12\x04\xca\t&'\nV\n\x04\x04\x13\x02\x02\x12\x04\xcd\t\
    \x02)\x1aH\x20Configurations\x20for\x20the\x20various\x20addons\x20avail\
    able\x20to\x20run\x20in\x20the\x20cluster.\n\n\r\n\x05\x04\x13\x02\x02\
    \x06\x12\x04\xcd\t\x02\x0e\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xcd\t\
    \x0f$\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xcd\t'(\n\xe0\x01\n\x04\x04\
    \x13\x02\x03\x12\x04\xd3\t\x02\"\x1a\xd1\x01\x20The\x20node\x20pool\x20t\
    o\x20be\x20upgraded.\x20This\x20field\x20is\x20mandatory\x20if\n\x20\"de\
    sired_node_version\",\x20\"desired_image_family\"\x20or\n\x20\"desired_n\
    ode_pool_autoscaling\"\x20is\x20specified\x20and\x20there\x20is\x20more\
    \x20than\x20one\n\x20node\x20pool\x20on\x20the\x20cluster.\n\n\r\n\x05\
    \x04\x13\x02\x03\x05\x12\x04\xd3\t\x02\x08\n\r\n\x05\x04\x13\x02\x03\x01\
    \x12\x04\xd3\t\t\x1d\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xd3\t\x20!\nk\
    \n\x04\x04\x13\x02\x04\x12\x04\xd7\t\x02\x20\x1a]\x20The\x20desired\x20i\
    mage\x20type\x20for\x20the\x20node\x20pool.\n\x20NOTE:\x20Set\x20the\x20\
    \"desired_node_pool\"\x20field\x20as\x20well.\n\n\r\n\x05\x04\x13\x02\
    \x04\x05\x12\x04\xd7\t\x02\x08\n\r\n\x05\x04\x13\x02\x04\x01\x12\x04\xd7\
    \t\t\x1b\n\r\n\x05\x04\x13\x02\x04\x03\x12\x04\xd7\t\x1e\x1f\n1\n\x04\
    \x04\x13\x02\x05\x12\x04\xda\t\x026\x1a#\x20Configuration\x20of\x20etcd\
    \x20encryption.\n\n\r\n\x05\x04\x13\x02\x05\x06\x12\x04\xda\t\x02\x14\n\
    \r\n\x05\x04\x13\x02\x05\x01\x12\x04\xda\t\x150\n\r\n\x05\x04\x13\x02\
    \x05\x03\x12\x04\xda\t35\n\xe5\x01\n\x04\x04\x13\x02\x06\x12\x04\xe0\t\
    \x028\x1a\xd6\x01\x20Autoscaler\x20configuration\x20for\x20the\x20node\
    \x20pool\x20specified\x20in\n\x20desired_node_pool_id.\x20If\x20there\
    \x20is\x20only\x20one\x20pool\x20in\x20the\n\x20cluster\x20and\x20desire\
    d_node_pool_id\x20is\x20not\x20provided\x20then\n\x20the\x20change\x20ap\
    plies\x20to\x20that\x20single\x20node\x20pool.\n\n\r\n\x05\x04\x13\x02\
    \x06\x06\x12\x04\xe0\t\x02\x15\n\r\n\x05\x04\x13\x02\x06\x01\x12\x04\xe0\
    \t\x163\n\r\n\x05\x04\x13\x02\x06\x03\x12\x04\xe0\t67\n\xfa\x02\n\x04\
    \x04\x13\x02\x07\x12\x04\xe9\t\x02)\x1a\xeb\x02\x20The\x20desired\x20lis\
    t\x20of\x20Google\x20Compute\x20Engine\n\x20[zones](/compute/docs/zones#\
    available)\x20in\x20which\x20the\x20cluster's\x20nodes\n\x20should\x20be\
    \x20located.\x20Changing\x20the\x20locations\x20a\x20cluster\x20is\x20in\
    \x20will\x20result\n\x20in\x20nodes\x20being\x20either\x20created\x20or\
    \x20removed\x20from\x20the\x20cluster,\x20depending\x20on\n\x20whether\
    \x20locations\x20are\x20being\x20added\x20or\x20removed.\n\n\x20This\x20\
    list\x20must\x20always\x20include\x20the\x20cluster's\x20primary\x20zone\
    .\n\n\r\n\x05\x04\x13\x02\x07\x04\x12\x04\xe9\t\x02\n\n\r\n\x05\x04\x13\
    \x02\x07\x05\x12\x04\xe9\t\x0b\x11\n\r\n\x05\x04\x13\x02\x07\x01\x12\x04\
    \xe9\t\x12#\n\r\n\x05\x04\x13\x02\x07\x03\x12\x04\xe9\t&(\nY\n\x04\x04\
    \x13\x02\x08\x12\x04\xec\t\x02P\x1aK\x20The\x20desired\x20configuration\
    \x20options\x20for\x20master\x20authorized\x20networks\x20feature.\n\n\r\
    \n\x05\x04\x13\x02\x08\x06\x12\x04\xec\t\x02\x20\n\r\n\x05\x04\x13\x02\
    \x08\x01\x12\x04\xec\t!J\n\r\n\x05\x04\x13\x02\x08\x03\x12\x04\xec\tMO\n\
    8\n\x04\x04\x13\x02\t\x12\x04\xef\t\x026\x1a*\x20Cluster-level\x20autosc\
    aling\x20configuration.\n\n\r\n\x05\x04\x13\x02\t\x06\x12\x04\xef\t\x02\
    \x14\n\r\n\x05\x04\x13\x02\t\x01\x12\x04\xef\t\x150\n\r\n\x05\x04\x13\
    \x02\t\x03\x12\x04\xef\t35\nW\n\x04\x04\x13\x02\n\x12\x04\xf2\t\x028\x1a\
    I\x20The\x20desired\x20configuration\x20options\x20for\x20the\x20Binary\
    \x20Authorization\x20feature.\n\n\r\n\x05\x04\x13\x02\n\x06\x12\x04\xf2\
    \t\x02\x15\n\r\n\x05\x04\x13\x02\n\x01\x12\x04\xf2\t\x162\n\r\n\x05\x04\
    \x13\x02\n\x03\x12\x04\xf2\t57\n\xcf\x02\n\x04\x04\x13\x02\x0b\x12\x04\
    \xfb\t\x02&\x1a\xc0\x02\x20The\x20logging\x20service\x20the\x20cluster\
    \x20should\x20use\x20to\x20write\x20logs.\n\x20Currently\x20available\
    \x20options:\n\n\x20*\x20\"logging.googleapis.com/kubernetes\"\x20-\x20t\
    he\x20Google\x20Cloud\x20Logging\n\x20service\x20with\x20Kubernetes-nati\
    ve\x20resource\x20model\n\x20*\x20\"logging.googleapis.com\"\x20-\x20the\
    \x20Google\x20Cloud\x20Logging\x20service\n\x20*\x20\"none\"\x20-\x20no\
    \x20logs\x20will\x20be\x20exported\x20from\x20the\x20cluster\n\n\r\n\x05\
    \x04\x13\x02\x0b\x05\x12\x04\xfb\t\x02\x08\n\r\n\x05\x04\x13\x02\x0b\x01\
    \x12\x04\xfb\t\t\x20\n\r\n\x05\x04\x13\x02\x0b\x03\x12\x04\xfb\t#%\nG\n\
    \x04\x04\x13\x02\x0c\x12\x04\xfe\t\x02F\x1a9\x20The\x20desired\x20config\
    uration\x20for\x20exporting\x20resource\x20usage.\n\n\r\n\x05\x04\x13\
    \x02\x0c\x06\x12\x04\xfe\t\x02\x1b\n\r\n\x05\x04\x13\x02\x0c\x01\x12\x04\
    \xfe\t\x1c@\n\r\n\x05\x04\x13\x02\x0c\x03\x12\x04\xfe\tCE\nE\n\x04\x04\
    \x13\x02\r\x12\x04\x81\n\x02?\x1a7\x20Cluster-level\x20Vertical\x20Pod\
    \x20Autoscaling\x20configuration.\n\n\r\n\x05\x04\x13\x02\r\x06\x12\x04\
    \x81\n\x02\x18\n\r\n\x05\x04\x13\x02\r\x01\x12\x04\x81\n\x199\n\r\n\x05\
    \x04\x13\x02\r\x03\x12\x04\x81\n<>\n<\n\x04\x04\x13\x02\x0e\x12\x04\x84\
    \n\x02F\x1a.\x20The\x20desired\x20config\x20of\x20Intra-node\x20visibili\
    ty.\n\n\r\n\x05\x04\x13\x02\x0e\x06\x12\x04\x84\n\x02\x1b\n\r\n\x05\x04\
    \x13\x02\x0e\x01\x12\x04\x84\n\x1c@\n\r\n\x05\x04\x13\x02\x0e\x03\x12\
    \x04\x84\nCE\n\xeb\x03\n\x04\x04\x13\x02\x0f\x12\x04\x90\n\x02&\x1a\xdc\
    \x03\x20The\x20Kubernetes\x20version\x20to\x20change\x20the\x20master\
    \x20to.\n\n\x20Users\x20may\x20specify\x20either\x20explicit\x20versions\
    \x20offered\x20by\n\x20Kubernetes\x20Engine\x20or\x20version\x20aliases,\
    \x20which\x20have\x20the\x20following\x20behavior:\n\n\x20-\x20\"latest\
    \":\x20picks\x20the\x20highest\x20valid\x20Kubernetes\x20version\n\x20-\
    \x20\"1.X\":\x20picks\x20the\x20highest\x20valid\x20patch+gke.N\x20patch\
    \x20in\x20the\x201.X\x20version\n\x20-\x20\"1.X.Y\":\x20picks\x20the\x20\
    highest\x20valid\x20gke.N\x20patch\x20in\x20the\x201.X.Y\x20version\n\
    \x20-\x20\"1.X.Y-gke.N\":\x20picks\x20an\x20explicit\x20Kubernetes\x20ve\
    rsion\n\x20-\x20\"-\":\x20picks\x20the\x20default\x20Kubernetes\x20versi\
    on\n\n\r\n\x05\x04\x13\x02\x0f\x05\x12\x04\x90\n\x02\x08\n\r\n\x05\x04\
    \x13\x02\x0f\x01\x12\x04\x90\n\t\x1f\n\r\n\x05\x04\x13\x02\x0f\x03\x12\
    \x04\x90\n\"%\n\x93\x01\n\x02\x04\x14\x12\x06\x95\n\0\x8c\x0b\x01\x1a\
    \x84\x01\x20This\x20operation\x20resource\x20represents\x20operations\
    \x20that\x20may\x20have\x20happened\x20or\x20are\n\x20happening\x20on\
    \x20the\x20cluster.\x20All\x20fields\x20are\x20output\x20only.\n\n\x0b\n\
    \x03\x04\x14\x01\x12\x04\x95\n\x08\x11\n2\n\x04\x04\x14\x04\0\x12\x06\
    \x97\n\x02\xa6\n\x03\x1a\"\x20Current\x20status\x20of\x20the\x20operatio\
    n.\n\n\r\n\x05\x04\x14\x04\0\x01\x12\x04\x97\n\x07\r\n\x1a\n\x06\x04\x14\
    \x04\0\x02\0\x12\x04\x99\n\x04\x1b\x1a\n\x20Not\x20set.\n\n\x0f\n\x07\
    \x04\x14\x04\0\x02\0\x01\x12\x04\x99\n\x04\x16\n\x0f\n\x07\x04\x14\x04\0\
    \x02\0\x02\x12\x04\x99\n\x19\x1a\n1\n\x06\x04\x14\x04\0\x02\x01\x12\x04\
    \x9c\n\x04\x10\x1a!\x20The\x20operation\x20has\x20been\x20created.\n\n\
    \x0f\n\x07\x04\x14\x04\0\x02\x01\x01\x12\x04\x9c\n\x04\x0b\n\x0f\n\x07\
    \x04\x14\x04\0\x02\x01\x02\x12\x04\x9c\n\x0e\x0f\n5\n\x06\x04\x14\x04\0\
    \x02\x02\x12\x04\x9f\n\x04\x10\x1a%\x20The\x20operation\x20is\x20current\
    ly\x20running.\n\n\x0f\n\x07\x04\x14\x04\0\x02\x02\x01\x12\x04\x9f\n\x04\
    \x0b\n\x0f\n\x07\x04\x14\x04\0\x02\x02\x02\x12\x04\x9f\n\x0e\x0f\nG\n\
    \x06\x04\x14\x04\0\x02\x03\x12\x04\xa2\n\x04\r\x1a7\x20The\x20operation\
    \x20is\x20done,\x20either\x20cancelled\x20or\x20completed.\n\n\x0f\n\x07\
    \x04\x14\x04\0\x02\x03\x01\x12\x04\xa2\n\x04\x08\n\x0f\n\x07\x04\x14\x04\
    \0\x02\x03\x02\x12\x04\xa2\n\x0b\x0c\n,\n\x06\x04\x14\x04\0\x02\x04\x12\
    \x04\xa5\n\x04\x11\x1a\x1c\x20The\x20operation\x20is\x20aborting.\n\n\
    \x0f\n\x07\x04\x14\x04\0\x02\x04\x01\x12\x04\xa5\n\x04\x0c\n\x0f\n\x07\
    \x04\x14\x04\0\x02\x04\x02\x12\x04\xa5\n\x0f\x10\n!\n\x04\x04\x14\x04\
    \x01\x12\x06\xa9\n\x02\xdc\n\x03\x1a\x11\x20Operation\x20type.\n\n\r\n\
    \x05\x04\x14\x04\x01\x01\x12\x04\xa9\n\x07\x0b\n\x1a\n\x06\x04\x14\x04\
    \x01\x02\0\x12\x04\xab\n\x04\x19\x1a\n\x20Not\x20set.\n\n\x0f\n\x07\x04\
    \x14\x04\x01\x02\0\x01\x12\x04\xab\n\x04\x14\n\x0f\n\x07\x04\x14\x04\x01\
    \x02\0\x02\x12\x04\xab\n\x17\x18\n!\n\x06\x04\x14\x04\x01\x02\x01\x12\
    \x04\xae\n\x04\x17\x1a\x11\x20Cluster\x20create.\n\n\x0f\n\x07\x04\x14\
    \x04\x01\x02\x01\x01\x12\x04\xae\n\x04\x12\n\x0f\n\x07\x04\x14\x04\x01\
    \x02\x01\x02\x12\x04\xae\n\x15\x16\n!\n\x06\x04\x14\x04\x01\x02\x02\x12\
    \x04\xb1\n\x04\x17\x1a\x11\x20Cluster\x20delete.\n\n\x0f\n\x07\x04\x14\
    \x04\x01\x02\x02\x01\x12\x04\xb1\n\x04\x12\n\x0f\n\x07\x04\x14\x04\x01\
    \x02\x02\x02\x12\x04\xb1\n\x15\x16\n#\n\x06\x04\x14\x04\x01\x02\x03\x12\
    \x04\xb4\n\x04\x17\x1a\x13\x20A\x20master\x20upgrade.\n\n\x0f\n\x07\x04\
    \x14\x04\x01\x02\x03\x01\x12\x04\xb4\n\x04\x12\n\x0f\n\x07\x04\x14\x04\
    \x01\x02\x03\x02\x12\x04\xb4\n\x15\x16\n!\n\x06\x04\x14\x04\x01\x02\x04\
    \x12\x04\xb7\n\x04\x16\x1a\x11\x20A\x20node\x20upgrade.\n\n\x0f\n\x07\
    \x04\x14\x04\x01\x02\x04\x01\x12\x04\xb7\n\x04\x11\n\x0f\n\x07\x04\x14\
    \x04\x01\x02\x04\x02\x12\x04\xb7\n\x14\x15\n!\n\x06\x04\x14\x04\x01\x02\
    \x05\x12\x04\xba\n\x04\x17\x1a\x11\x20Cluster\x20repair.\n\n\x0f\n\x07\
    \x04\x14\x04\x01\x02\x05\x01\x12\x04\xba\n\x04\x12\n\x0f\n\x07\x04\x14\
    \x04\x01\x02\x05\x02\x12\x04\xba\n\x15\x16\n!\n\x06\x04\x14\x04\x01\x02\
    \x06\x12\x04\xbd\n\x04\x17\x1a\x11\x20Cluster\x20update.\n\n\x0f\n\x07\
    \x04\x14\x04\x01\x02\x06\x01\x12\x04\xbd\n\x04\x12\n\x0f\n\x07\x04\x14\
    \x04\x01\x02\x06\x02\x12\x04\xbd\n\x15\x16\n#\n\x06\x04\x14\x04\x01\x02\
    \x07\x12\x04\xc0\n\x04\x19\x1a\x13\x20Node\x20pool\x20create.\n\n\x0f\n\
    \x07\x04\x14\x04\x01\x02\x07\x01\x12\x04\xc0\n\x04\x14\n\x0f\n\x07\x04\
    \x14\x04\x01\x02\x07\x02\x12\x04\xc0\n\x17\x18\n#\n\x06\x04\x14\x04\x01\
    \x02\x08\x12\x04\xc3\n\x04\x19\x1a\x13\x20Node\x20pool\x20delete.\n\n\
    \x0f\n\x07\x04\x14\x04\x01\x02\x08\x01\x12\x04\xc3\n\x04\x14\n\x0f\n\x07\
    \x04\x14\x04\x01\x02\x08\x02\x12\x04\xc3\n\x17\x18\n+\n\x06\x04\x14\x04\
    \x01\x02\t\x12\x04\xc6\n\x04!\x1a\x1b\x20Set\x20node\x20pool\x20manageme\
    nt.\n\n\x0f\n\x07\x04\x14\x04\x01\x02\t\x01\x12\x04\xc6\n\x04\x1c\n\x0f\
    \n\x07\x04\x14\x04\x01\x02\t\x02\x12\x04\xc6\n\x1f\x20\n-\n\x06\x04\x14\
    \x04\x01\x02\n\x12\x04\xc9\n\x04\x1b\x1a\x1d\x20Automatic\x20node\x20poo\
    l\x20repair.\n\n\x0f\n\x07\x04\x14\x04\x01\x02\n\x01\x12\x04\xc9\n\x04\
    \x15\n\x0f\n\x07\x04\x14\x04\x01\x02\n\x02\x12\x04\xc9\n\x18\x1a\n)\n\
    \x06\x04\x14\x04\x01\x02\x0b\x12\x04\xcc\n\x04\x1c\x1a\x19\x20Automatic\
    \x20node\x20upgrade.\n\n\x0f\n\x07\x04\x14\x04\x01\x02\x0b\x01\x12\x04\
    \xcc\n\x04\x16\n\x0f\n\x07\x04\x14\x04\x01\x02\x0b\x02\x12\x04\xcc\n\x19\
    \x1b\n\x1d\n\x06\x04\x14\x04\x01\x02\x0c\x12\x04\xcf\n\x04\x14\x1a\r\x20\
    Set\x20labels.\n\n\x0f\n\x07\x04\x14\x04\x01\x02\x0c\x01\x12\x04\xcf\n\
    \x04\x0e\n\x0f\n\x07\x04\x14\x04\x01\x02\x0c\x02\x12\x04\xcf\n\x11\x13\n\
    4\n\x06\x04\x14\x04\x01\x02\r\x12\x04\xd2\n\x04\x19\x1a$\x20Set/generate\
    \x20master\x20auth\x20materials\n\n\x0f\n\x07\x04\x14\x04\x01\x02\r\x01\
    \x12\x04\xd2\n\x04\x13\n\x0f\n\x07\x04\x14\x04\x01\x02\r\x02\x12\x04\xd2\
    \n\x16\x18\n%\n\x06\x04\x14\x04\x01\x02\x0e\x12\x04\xd5\n\x04\x1c\x1a\
    \x15\x20Set\x20node\x20pool\x20size.\n\n\x0f\n\x07\x04\x14\x04\x01\x02\
    \x0e\x01\x12\x04\xd5\n\x04\x16\n\x0f\n\x07\x04\x14\x04\x01\x02\x0e\x02\
    \x12\x04\xd5\n\x19\x1b\n7\n\x06\x04\x14\x04\x01\x02\x0f\x12\x04\xd8\n\
    \x04\x1c\x1a'\x20Updates\x20network\x20policy\x20for\x20a\x20cluster.\n\
    \n\x0f\n\x07\x04\x14\x04\x01\x02\x0f\x01\x12\x04\xd8\n\x04\x16\n\x0f\n\
    \x07\x04\x14\x04\x01\x02\x0f\x02\x12\x04\xd8\n\x19\x1b\n-\n\x06\x04\x14\
    \x04\x01\x02\x10\x12\x04\xdb\n\x04\x20\x1a\x1d\x20Set\x20the\x20maintena\
    nce\x20policy.\n\n\x0f\n\x07\x04\x14\x04\x01\x02\x10\x01\x12\x04\xdb\n\
    \x04\x1a\n\x0f\n\x07\x04\x14\x04\x01\x02\x10\x02\x12\x04\xdb\n\x1d\x1f\n\
    9\n\x04\x04\x14\x02\0\x12\x04\xdf\n\x02\x12\x1a+\x20The\x20server-assign\
    ed\x20ID\x20for\x20the\x20operation.\n\n\r\n\x05\x04\x14\x02\0\x05\x12\
    \x04\xdf\n\x02\x08\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xdf\n\t\r\n\r\n\
    \x05\x04\x14\x02\0\x03\x12\x04\xdf\n\x10\x11\n\xb7\x01\n\x04\x04\x14\x02\
    \x01\x12\x04\xe5\n\x02&\x1a\xa8\x01\x20The\x20name\x20of\x20the\x20Googl\
    e\x20Compute\x20Engine\n\x20[zone](/compute/docs/zones#available)\x20in\
    \x20which\x20the\x20operation\n\x20is\x20taking\x20place.\n\x20This\x20f\
    ield\x20is\x20deprecated,\x20use\x20location\x20instead.\n\n\r\n\x05\x04\
    \x14\x02\x01\x05\x12\x04\xe5\n\x02\x08\n\r\n\x05\x04\x14\x02\x01\x01\x12\
    \x04\xe5\n\t\r\n\r\n\x05\x04\x14\x02\x01\x03\x12\x04\xe5\n\x10\x11\n\r\n\
    \x05\x04\x14\x02\x01\x08\x12\x04\xe5\n\x12%\n\x0e\n\x06\x04\x14\x02\x01\
    \x08\x03\x12\x04\xe5\n\x13$\n#\n\x04\x04\x14\x02\x02\x12\x04\xe8\n\x02\
    \x1a\x1a\x15\x20The\x20operation\x20type.\n\n\r\n\x05\x04\x14\x02\x02\
    \x06\x12\x04\xe8\n\x02\x06\n\r\n\x05\x04\x14\x02\x02\x01\x12\x04\xe8\n\
    \x07\x15\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xe8\n\x18\x19\n4\n\x04\
    \x04\x14\x02\x03\x12\x04\xeb\n\x02\x14\x1a&\x20The\x20current\x20status\
    \x20of\x20the\x20operation.\n\n\r\n\x05\x04\x14\x02\x03\x06\x12\x04\xeb\
    \n\x02\x08\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xeb\n\t\x0f\n\r\n\x05\
    \x04\x14\x02\x03\x03\x12\x04\xeb\n\x12\x13\n:\n\x04\x04\x14\x02\x04\x12\
    \x04\xee\n\x02\x14\x1a,\x20Detailed\x20operation\x20progress,\x20if\x20a\
    vailable.\n\n\r\n\x05\x04\x14\x02\x04\x05\x12\x04\xee\n\x02\x08\n\r\n\
    \x05\x04\x14\x02\x04\x01\x12\x04\xee\n\t\x0f\n\r\n\x05\x04\x14\x02\x04\
    \x03\x12\x04\xee\n\x12\x13\nM\n\x04\x04\x14\x02\x05\x12\x04\xf1\n\x02\
    \x1c\x1a?\x20If\x20an\x20error\x20has\x20occurred,\x20a\x20textual\x20de\
    scription\x20of\x20the\x20error.\n\n\r\n\x05\x04\x14\x02\x05\x05\x12\x04\
    \xf1\n\x02\x08\n\r\n\x05\x04\x14\x02\x05\x01\x12\x04\xf1\n\t\x17\n\r\n\
    \x05\x04\x14\x02\x05\x03\x12\x04\xf1\n\x1a\x1b\n4\n\x04\x04\x14\x02\x06\
    \x12\x04\xf4\n\x02\x17\x1a&\x20Server-defined\x20URL\x20for\x20the\x20re\
    source.\n\n\r\n\x05\x04\x14\x02\x06\x05\x12\x04\xf4\n\x02\x08\n\r\n\x05\
    \x04\x14\x02\x06\x01\x12\x04\xf4\n\t\x12\n\r\n\x05\x04\x14\x02\x06\x03\
    \x12\x04\xf4\n\x15\x16\nC\n\x04\x04\x14\x02\x07\x12\x04\xf7\n\x02\x19\
    \x1a5\x20Server-defined\x20URL\x20for\x20the\x20target\x20of\x20the\x20o\
    peration.\n\n\r\n\x05\x04\x14\x02\x07\x05\x12\x04\xf7\n\x02\x08\n\r\n\
    \x05\x04\x14\x02\x07\x01\x12\x04\xf7\n\t\x14\n\r\n\x05\x04\x14\x02\x07\
    \x03\x12\x04\xf7\n\x17\x18\n\xe2\x01\n\x04\x04\x14\x02\x08\x12\x04\xfd\n\
    \x02\x16\x1a\xd3\x01\x20[Output\x20only]\x20The\x20name\x20of\x20the\x20\
    Google\x20Compute\x20Engine\n\x20[zone](/compute/docs/regions-zones/regi\
    ons-zones#available)\x20or\n\x20[region](/compute/docs/regions-zones/reg\
    ions-zones#available)\x20in\x20which\n\x20the\x20cluster\x20resides.\n\n\
    \r\n\x05\x04\x14\x02\x08\x05\x12\x04\xfd\n\x02\x08\n\r\n\x05\x04\x14\x02\
    \x08\x01\x12\x04\xfd\n\t\x11\n\r\n\x05\x04\x14\x02\x08\x03\x12\x04\xfd\n\
    \x14\x15\n~\n\x04\x04\x14\x02\t\x12\x04\x81\x0b\x02\x19\x1ap\x20[Output\
    \x20only]\x20The\x20time\x20the\x20operation\x20started,\x20in\n\x20[RFC\
    3339](https://www.ietf.org/rfc/rfc3339.txt)\x20text\x20format.\n\n\r\n\
    \x05\x04\x14\x02\t\x05\x12\x04\x81\x0b\x02\x08\n\r\n\x05\x04\x14\x02\t\
    \x01\x12\x04\x81\x0b\t\x13\n\r\n\x05\x04\x14\x02\t\x03\x12\x04\x81\x0b\
    \x16\x18\n\x80\x01\n\x04\x04\x14\x02\n\x12\x04\x85\x0b\x02\x17\x1ar\x20[\
    Output\x20only]\x20The\x20time\x20the\x20operation\x20completed,\x20in\n\
    \x20[RFC3339](https://www.ietf.org/rfc/rfc3339.txt)\x20text\x20format.\n\
    \n\r\n\x05\x04\x14\x02\n\x05\x12\x04\x85\x0b\x02\x08\n\r\n\x05\x04\x14\
    \x02\n\x01\x12\x04\x85\x0b\t\x11\n\r\n\x05\x04\x14\x02\n\x03\x12\x04\x85\
    \x0b\x14\x16\nB\n\x04\x04\x14\x02\x0b\x12\x04\x88\x0b\x023\x1a4\x20Which\
    \x20conditions\x20caused\x20the\x20current\x20cluster\x20state.\n\n\r\n\
    \x05\x04\x14\x02\x0b\x04\x12\x04\x88\x0b\x02\n\n\r\n\x05\x04\x14\x02\x0b\
    \x06\x12\x04\x88\x0b\x0b\x1a\n\r\n\x05\x04\x14\x02\x0b\x01\x12\x04\x88\
    \x0b\x1b-\n\r\n\x05\x04\x14\x02\x0b\x03\x12\x04\x88\x0b02\nD\n\x04\x04\
    \x14\x02\x0c\x12\x04\x8b\x0b\x024\x1a6\x20Which\x20conditions\x20caused\
    \x20the\x20current\x20node\x20pool\x20state.\n\n\r\n\x05\x04\x14\x02\x0c\
    \x04\x12\x04\x8b\x0b\x02\n\n\r\n\x05\x04\x14\x02\x0c\x06\x12\x04\x8b\x0b\
    \x0b\x1a\n\r\n\x05\x04\x14\x02\x0c\x01\x12\x04\x8b\x0b\x1b.\n\r\n\x05\
    \x04\x14\x02\x0c\x03\x12\x04\x8b\x0b13\n7\n\x02\x04\x15\x12\x06\x8f\x0b\
    \0\xa8\x0b\x01\x1a)\x20CreateClusterRequest\x20creates\x20a\x20cluster.\
    \n\n\x0b\n\x03\x04\x15\x01\x12\x04\x8f\x0b\x08\x1c\n\xda\x01\n\x04\x04\
    \x15\x02\0\x12\x06\x93\x0b\x02\x96\x0b\x04\x1a\xc9\x01\x20Required.\x20D\
    eprecated.\x20The\x20Google\x20Developers\x20Console\x20[project\x20ID\
    \x20or\x20project\n\x20number](https://support.google.com/cloud/answer/6\
    158840).\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20repla\
    ced\x20by\x20the\x20parent\x20field.\n\n\r\n\x05\x04\x15\x02\0\x05\x12\
    \x04\x93\x0b\x02\x08\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\x93\x0b\t\x13\n\
    \r\n\x05\x04\x15\x02\0\x03\x12\x04\x93\x0b\x16\x17\n\x0f\n\x05\x04\x15\
    \x02\0\x08\x12\x06\x93\x0b\x18\x96\x0b\x03\n\x0e\n\x06\x04\x15\x02\0\x08\
    \x03\x12\x04\x94\x0b\x04\x15\n\x10\n\x08\x04\x15\x02\0\x08\x9c\x08\0\x12\
    \x04\x95\x0b\x04*\n\xd6\x01\n\x04\x04\x15\x02\x01\x12\x06\x9c\x0b\x02\
    \x9f\x0b\x04\x1a\xc5\x01\x20Required.\x20Deprecated.\x20The\x20name\x20o\
    f\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/docs/zones#\
    available)\x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20This\x20f\
    ield\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20par\
    ent\x20field.\n\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\x9c\x0b\x02\x08\n\
    \r\n\x05\x04\x15\x02\x01\x01\x12\x04\x9c\x0b\t\r\n\r\n\x05\x04\x15\x02\
    \x01\x03\x12\x04\x9c\x0b\x10\x11\n\x0f\n\x05\x04\x15\x02\x01\x08\x12\x06\
    \x9c\x0b\x12\x9f\x0b\x03\n\x0e\n\x06\x04\x15\x02\x01\x08\x03\x12\x04\x9d\
    \x0b\x04\x15\n\x10\n\x08\x04\x15\x02\x01\x08\x9c\x08\0\x12\x04\x9e\x0b\
    \x04*\nl\n\x04\x04\x15\x02\x02\x12\x04\xa3\x0b\x02?\x1a^\x20Required.\
    \x20A\x20[cluster\n\x20resource](/container-engine/reference/rest/v1/pro\
    jects.zones.clusters)\n\n\r\n\x05\x04\x15\x02\x02\x06\x12\x04\xa3\x0b\
    \x02\t\n\r\n\x05\x04\x15\x02\x02\x01\x12\x04\xa3\x0b\n\x11\n\r\n\x05\x04\
    \x15\x02\x02\x03\x12\x04\xa3\x0b\x14\x15\n\r\n\x05\x04\x15\x02\x02\x08\
    \x12\x04\xa3\x0b\x16>\n\x10\n\x08\x04\x15\x02\x02\x08\x9c\x08\0\x12\x04\
    \xa3\x0b\x17=\n\x87\x01\n\x04\x04\x15\x02\x03\x12\x04\xa7\x0b\x02\x14\
    \x1ay\x20The\x20parent\x20(project\x20and\x20location)\x20where\x20the\
    \x20cluster\x20will\x20be\x20created.\n\x20Specified\x20in\x20the\x20for\
    mat\x20'projects/*/locations/*'.\n\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\
    \xa7\x0b\x02\x08\n\r\n\x05\x04\x15\x02\x03\x01\x12\x04\xa7\x0b\t\x0f\n\r\
    \n\x05\x04\x15\x02\x03\x03\x12\x04\xa7\x0b\x12\x13\nA\n\x02\x04\x16\x12\
    \x06\xab\x0b\0\xc7\x0b\x01\x1a3\x20GetClusterRequest\x20gets\x20the\x20s\
    ettings\x20of\x20a\x20cluster.\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xab\x0b\
    \x08\x19\n\xd8\x01\n\x04\x04\x16\x02\0\x12\x06\xaf\x0b\x02\xb2\x0b\x04\
    \x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20Google\x20Developers\
    \x20Console\x20[project\x20ID\x20or\x20project\n\x20number](https://supp\
    ort.google.com/cloud/answer/6158840).\n\x20This\x20field\x20has\x20been\
    \x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\
    \x05\x04\x16\x02\0\x05\x12\x04\xaf\x0b\x02\x08\n\r\n\x05\x04\x16\x02\0\
    \x01\x12\x04\xaf\x0b\t\x13\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xaf\x0b\
    \x16\x17\n\x0f\n\x05\x04\x16\x02\0\x08\x12\x06\xaf\x0b\x18\xb2\x0b\x03\n\
    \x0e\n\x06\x04\x16\x02\0\x08\x03\x12\x04\xb0\x0b\x04\x15\n\x10\n\x08\x04\
    \x16\x02\0\x08\x9c\x08\0\x12\x04\xb1\x0b\x04*\n\xd4\x01\n\x04\x04\x16\
    \x02\x01\x12\x06\xb8\x0b\x02\xbb\x0b\x04\x1a\xc3\x01\x20Required.\x20Dep\
    recated.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Engine\n\
    \x20[zone](/compute/docs/zones#available)\x20in\x20which\x20the\x20clust\
    er\n\x20resides.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\
    \x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x16\x02\x01\
    \x05\x12\x04\xb8\x0b\x02\x08\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xb8\
    \x0b\t\r\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\xb8\x0b\x10\x11\n\x0f\n\
    \x05\x04\x16\x02\x01\x08\x12\x06\xb8\x0b\x12\xbb\x0b\x03\n\x0e\n\x06\x04\
    \x16\x02\x01\x08\x03\x12\x04\xb9\x0b\x04\x15\n\x10\n\x08\x04\x16\x02\x01\
    \x08\x9c\x08\0\x12\x04\xba\x0b\x04*\n\x8c\x01\n\x04\x04\x16\x02\x02\x12\
    \x06\xbf\x0b\x02\xc2\x0b\x04\x1a|\x20Required.\x20Deprecated.\x20The\x20\
    name\x20of\x20the\x20cluster\x20to\x20retrieve.\n\x20This\x20field\x20ha\
    s\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field\
    .\n\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xbf\x0b\x02\x08\n\r\n\x05\x04\
    \x16\x02\x02\x01\x12\x04\xbf\x0b\t\x13\n\r\n\x05\x04\x16\x02\x02\x03\x12\
    \x04\xbf\x0b\x16\x17\n\x0f\n\x05\x04\x16\x02\x02\x08\x12\x06\xbf\x0b\x18\
    \xc2\x0b\x03\n\x0e\n\x06\x04\x16\x02\x02\x08\x03\x12\x04\xc0\x0b\x04\x15\
    \n\x10\n\x08\x04\x16\x02\x02\x08\x9c\x08\0\x12\x04\xc1\x0b\x04*\n\x90\
    \x01\n\x04\x04\x16\x02\x03\x12\x04\xc6\x0b\x02\x12\x1a\x81\x01\x20The\
    \x20name\x20(project,\x20location,\x20cluster)\x20of\x20the\x20cluster\
    \x20to\x20retrieve.\n\x20Specified\x20in\x20the\x20format\x20'projects/*\
    /locations/*/clusters/*'.\n\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\xc6\
    \x0b\x02\x08\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\xc6\x0b\t\r\n\r\n\x05\
    \x04\x16\x02\x03\x03\x12\x04\xc6\x0b\x10\x11\nG\n\x02\x04\x17\x12\x06\
    \xca\x0b\0\xe9\x0b\x01\x1a9\x20UpdateClusterRequest\x20updates\x20the\
    \x20settings\x20of\x20a\x20cluster.\n\n\x0b\n\x03\x04\x17\x01\x12\x04\
    \xca\x0b\x08\x1c\n\xd8\x01\n\x04\x04\x17\x02\0\x12\x06\xce\x0b\x02\xd1\
    \x0b\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20Google\x20Dev\
    elopers\x20Console\x20[project\x20ID\x20or\x20project\n\x20number](https\
    ://support.google.com/cloud/answer/6158840).\n\x20This\x20field\x20has\
    \x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\
    \n\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\xce\x0b\x02\x08\n\r\n\x05\x04\x17\
    \x02\0\x01\x12\x04\xce\x0b\t\x13\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xce\
    \x0b\x16\x17\n\x0f\n\x05\x04\x17\x02\0\x08\x12\x06\xce\x0b\x18\xd1\x0b\
    \x03\n\x0e\n\x06\x04\x17\x02\0\x08\x03\x12\x04\xcf\x0b\x04\x15\n\x10\n\
    \x08\x04\x17\x02\0\x08\x9c\x08\0\x12\x04\xd0\x0b\x04*\n\xd4\x01\n\x04\
    \x04\x17\x02\x01\x12\x06\xd7\x0b\x02\xda\x0b\x04\x1a\xc3\x01\x20Required\
    .\x20Deprecated.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Eng\
    ine\n\x20[zone](/compute/docs/zones#available)\x20in\x20which\x20the\x20\
    cluster\n\x20resides.\n\x20This\x20field\x20has\x20been\x20deprecated\
    \x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x17\
    \x02\x01\x05\x12\x04\xd7\x0b\x02\x08\n\r\n\x05\x04\x17\x02\x01\x01\x12\
    \x04\xd7\x0b\t\r\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\xd7\x0b\x10\x11\n\
    \x0f\n\x05\x04\x17\x02\x01\x08\x12\x06\xd7\x0b\x12\xda\x0b\x03\n\x0e\n\
    \x06\x04\x17\x02\x01\x08\x03\x12\x04\xd8\x0b\x04\x15\n\x10\n\x08\x04\x17\
    \x02\x01\x08\x9c\x08\0\x12\x04\xd9\x0b\x04*\n\x8b\x01\n\x04\x04\x17\x02\
    \x02\x12\x06\xde\x0b\x02\xe1\x0b\x04\x1a{\x20Required.\x20Deprecated.\
    \x20The\x20name\x20of\x20the\x20cluster\x20to\x20upgrade.\n\x20This\x20f\
    ield\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20nam\
    e\x20field.\n\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xde\x0b\x02\x08\n\r\
    \n\x05\x04\x17\x02\x02\x01\x12\x04\xde\x0b\t\x13\n\r\n\x05\x04\x17\x02\
    \x02\x03\x12\x04\xde\x0b\x16\x17\n\x0f\n\x05\x04\x17\x02\x02\x08\x12\x06\
    \xde\x0b\x18\xe1\x0b\x03\n\x0e\n\x06\x04\x17\x02\x02\x08\x03\x12\x04\xdf\
    \x0b\x04\x15\n\x10\n\x08\x04\x17\x02\x02\x08\x9c\x08\0\x12\x04\xe0\x0b\
    \x04*\n6\n\x04\x04\x17\x02\x03\x12\x04\xe4\x0b\x02D\x1a(\x20Required.\
    \x20A\x20description\x20of\x20the\x20update.\n\n\r\n\x05\x04\x17\x02\x03\
    \x06\x12\x04\xe4\x0b\x02\x0f\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xe4\
    \x0b\x10\x16\n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\xe4\x0b\x19\x1a\n\r\n\
    \x05\x04\x17\x02\x03\x08\x12\x04\xe4\x0b\x1bC\n\x10\n\x08\x04\x17\x02\
    \x03\x08\x9c\x08\0\x12\x04\xe4\x0b\x1cB\n\x8d\x01\n\x04\x04\x17\x02\x04\
    \x12\x04\xe8\x0b\x02\x12\x1a\x7f\x20The\x20name\x20(project,\x20location\
    ,\x20cluster)\x20of\x20the\x20cluster\x20to\x20update.\n\x20Specified\
    \x20in\x20the\x20format\x20'projects/*/locations/*/clusters/*'.\n\n\r\n\
    \x05\x04\x17\x02\x04\x05\x12\x04\xe8\x0b\x02\x08\n\r\n\x05\x04\x17\x02\
    \x04\x01\x12\x04\xe8\x0b\t\r\n\r\n\x05\x04\x17\x02\x04\x03\x12\x04\xe8\
    \x0b\x10\x11\nQ\n\x02\x04\x18\x12\x06\xec\x0b\0\xa0\x0c\x01\x1aC\x20Upda\
    teNodePoolRequests\x20update\x20a\x20node\x20pool's\x20image\x20and/or\
    \x20version.\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xec\x0b\x08\x1d\n\xd8\x01\
    \n\x04\x04\x18\x02\0\x12\x06\xf0\x0b\x02\xf3\x0b\x04\x1a\xc7\x01\x20Requ\
    ired.\x20Deprecated.\x20The\x20Google\x20Developers\x20Console\x20[proje\
    ct\x20ID\x20or\x20project\n\x20number](https://support.google.com/cloud/\
    answer/6158840).\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\
    \x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x18\x02\0\
    \x05\x12\x04\xf0\x0b\x02\x08\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xf0\x0b\
    \t\x13\n\r\n\x05\x04\x18\x02\0\x03\x12\x04\xf0\x0b\x16\x17\n\x0f\n\x05\
    \x04\x18\x02\0\x08\x12\x06\xf0\x0b\x18\xf3\x0b\x03\n\x0e\n\x06\x04\x18\
    \x02\0\x08\x03\x12\x04\xf1\x0b\x04\x15\n\x10\n\x08\x04\x18\x02\0\x08\x9c\
    \x08\0\x12\x04\xf2\x0b\x04*\n\xd4\x01\n\x04\x04\x18\x02\x01\x12\x06\xf9\
    \x0b\x02\xfc\x0b\x04\x1a\xc3\x01\x20Required.\x20Deprecated.\x20The\x20n\
    ame\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/doc\
    s/zones#available)\x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20T\
    his\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20th\
    e\x20name\x20field.\n\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\xf9\x0b\x02\
    \x08\n\r\n\x05\x04\x18\x02\x01\x01\x12\x04\xf9\x0b\t\r\n\r\n\x05\x04\x18\
    \x02\x01\x03\x12\x04\xf9\x0b\x10\x11\n\x0f\n\x05\x04\x18\x02\x01\x08\x12\
    \x06\xf9\x0b\x12\xfc\x0b\x03\n\x0e\n\x06\x04\x18\x02\x01\x08\x03\x12\x04\
    \xfa\x0b\x04\x15\n\x10\n\x08\x04\x18\x02\x01\x08\x9c\x08\0\x12\x04\xfb\
    \x0b\x04*\n\x8b\x01\n\x04\x04\x18\x02\x02\x12\x06\x80\x0c\x02\x83\x0c\
    \x04\x1a{\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20clu\
    ster\x20to\x20upgrade.\n\x20This\x20field\x20has\x20been\x20deprecated\
    \x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x18\
    \x02\x02\x05\x12\x04\x80\x0c\x02\x08\n\r\n\x05\x04\x18\x02\x02\x01\x12\
    \x04\x80\x0c\t\x13\n\r\n\x05\x04\x18\x02\x02\x03\x12\x04\x80\x0c\x16\x17\
    \n\x0f\n\x05\x04\x18\x02\x02\x08\x12\x06\x80\x0c\x18\x83\x0c\x03\n\x0e\n\
    \x06\x04\x18\x02\x02\x08\x03\x12\x04\x81\x0c\x04\x15\n\x10\n\x08\x04\x18\
    \x02\x02\x08\x9c\x08\0\x12\x04\x82\x0c\x04*\n\x8d\x01\n\x04\x04\x18\x02\
    \x03\x12\x06\x87\x0c\x02\x8a\x0c\x04\x1a}\x20Required.\x20Deprecated.\
    \x20The\x20name\x20of\x20the\x20node\x20pool\x20to\x20upgrade.\n\x20This\
    \x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\
    \x20name\x20field.\n\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\x87\x0c\x02\
    \x08\n\r\n\x05\x04\x18\x02\x03\x01\x12\x04\x87\x0c\t\x15\n\r\n\x05\x04\
    \x18\x02\x03\x03\x12\x04\x87\x0c\x18\x19\n\x0f\n\x05\x04\x18\x02\x03\x08\
    \x12\x06\x87\x0c\x1a\x8a\x0c\x03\n\x0e\n\x06\x04\x18\x02\x03\x08\x03\x12\
    \x04\x88\x0c\x04\x15\n\x10\n\x08\x04\x18\x02\x03\x08\x9c\x08\0\x12\x04\
    \x89\x0c\x04*\n\x8b\x04\n\x04\x04\x18\x02\x04\x12\x04\x97\x0c\x02C\x1a\
    \xfc\x03\x20Required.\x20The\x20Kubernetes\x20version\x20to\x20change\
    \x20the\x20nodes\x20to\x20(typically\x20an\n\x20upgrade).\n\n\x20Users\
    \x20may\x20specify\x20either\x20explicit\x20versions\x20offered\x20by\
    \x20Kubernetes\x20Engine\x20or\n\x20version\x20aliases,\x20which\x20have\
    \x20the\x20following\x20behavior:\n\n\x20-\x20\"latest\":\x20picks\x20th\
    e\x20highest\x20valid\x20Kubernetes\x20version\n\x20-\x20\"1.X\":\x20pic\
    ks\x20the\x20highest\x20valid\x20patch+gke.N\x20patch\x20in\x20the\x201.\
    X\x20version\n\x20-\x20\"1.X.Y\":\x20picks\x20the\x20highest\x20valid\
    \x20gke.N\x20patch\x20in\x20the\x201.X.Y\x20version\n\x20-\x20\"1.X.Y-gk\
    e.N\":\x20picks\x20an\x20explicit\x20Kubernetes\x20version\n\x20-\x20\"-\
    \":\x20picks\x20the\x20Kubernetes\x20master\x20version\n\n\r\n\x05\x04\
    \x18\x02\x04\x05\x12\x04\x97\x0c\x02\x08\n\r\n\x05\x04\x18\x02\x04\x01\
    \x12\x04\x97\x0c\t\x15\n\r\n\x05\x04\x18\x02\x04\x03\x12\x04\x97\x0c\x18\
    \x19\n\r\n\x05\x04\x18\x02\x04\x08\x12\x04\x97\x0c\x1aB\n\x10\n\x08\x04\
    \x18\x02\x04\x08\x9c\x08\0\x12\x04\x97\x0c\x1bA\nC\n\x04\x04\x18\x02\x05\
    \x12\x04\x9a\x0c\x02A\x1a5\x20Required.\x20The\x20desired\x20image\x20ty\
    pe\x20for\x20the\x20node\x20pool.\n\n\r\n\x05\x04\x18\x02\x05\x05\x12\
    \x04\x9a\x0c\x02\x08\n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\x9a\x0c\t\x13\
    \n\r\n\x05\x04\x18\x02\x05\x03\x12\x04\x9a\x0c\x16\x17\n\r\n\x05\x04\x18\
    \x02\x05\x08\x12\x04\x9a\x0c\x18@\n\x10\n\x08\x04\x18\x02\x05\x08\x9c\
    \x08\0\x12\x04\x9a\x0c\x19?\n\xa8\x01\n\x04\x04\x18\x02\x06\x12\x04\x9f\
    \x0c\x02\x12\x1a\x99\x01\x20The\x20name\x20(project,\x20location,\x20clu\
    ster,\x20node\x20pool)\x20of\x20the\x20node\x20pool\x20to\n\x20update.\
    \x20Specified\x20in\x20the\x20format\n\x20'projects/*/locations/*/cluste\
    rs/*/nodePools/*'.\n\n\r\n\x05\x04\x18\x02\x06\x05\x12\x04\x9f\x0c\x02\
    \x08\n\r\n\x05\x04\x18\x02\x06\x01\x12\x04\x9f\x0c\t\r\n\r\n\x05\x04\x18\
    \x02\x06\x03\x12\x04\x9f\x0c\x10\x11\nZ\n\x02\x04\x19\x12\x06\xa3\x0c\0\
    \xca\x0c\x01\x1aL\x20SetNodePoolAutoscalingRequest\x20sets\x20the\x20aut\
    oscaler\x20settings\x20of\x20a\x20node\x20pool.\n\n\x0b\n\x03\x04\x19\
    \x01\x12\x04\xa3\x0c\x08%\n\xd8\x01\n\x04\x04\x19\x02\0\x12\x06\xa7\x0c\
    \x02\xaa\x0c\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20Googl\
    e\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\n\x20numbe\
    r](https://support.google.com/cloud/answer/6158840).\n\x20This\x20field\
    \x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\
    \x20field.\n\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\xa7\x0c\x02\x08\n\r\n\
    \x05\x04\x19\x02\0\x01\x12\x04\xa7\x0c\t\x13\n\r\n\x05\x04\x19\x02\0\x03\
    \x12\x04\xa7\x0c\x16\x17\n\x0f\n\x05\x04\x19\x02\0\x08\x12\x06\xa7\x0c\
    \x18\xaa\x0c\x03\n\x0e\n\x06\x04\x19\x02\0\x08\x03\x12\x04\xa8\x0c\x04\
    \x15\n\x10\n\x08\x04\x19\x02\0\x08\x9c\x08\0\x12\x04\xa9\x0c\x04*\n\xd4\
    \x01\n\x04\x04\x19\x02\x01\x12\x06\xb0\x0c\x02\xb3\x0c\x04\x1a\xc3\x01\
    \x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20Google\x20Co\
    mpute\x20Engine\n\x20[zone](/compute/docs/zones#available)\x20in\x20whic\
    h\x20the\x20cluster\n\x20resides.\n\x20This\x20field\x20has\x20been\x20d\
    eprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\
    \x04\x19\x02\x01\x05\x12\x04\xb0\x0c\x02\x08\n\r\n\x05\x04\x19\x02\x01\
    \x01\x12\x04\xb0\x0c\t\r\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xb0\x0c\
    \x10\x11\n\x0f\n\x05\x04\x19\x02\x01\x08\x12\x06\xb0\x0c\x12\xb3\x0c\x03\
    \n\x0e\n\x06\x04\x19\x02\x01\x08\x03\x12\x04\xb1\x0c\x04\x15\n\x10\n\x08\
    \x04\x19\x02\x01\x08\x9c\x08\0\x12\x04\xb2\x0c\x04*\n\x8b\x01\n\x04\x04\
    \x19\x02\x02\x12\x06\xb7\x0c\x02\xba\x0c\x04\x1a{\x20Required.\x20Deprec\
    ated.\x20The\x20name\x20of\x20the\x20cluster\x20to\x20upgrade.\n\x20This\
    \x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\
    \x20name\x20field.\n\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xb7\x0c\x02\
    \x08\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xb7\x0c\t\x13\n\r\n\x05\x04\
    \x19\x02\x02\x03\x12\x04\xb7\x0c\x16\x17\n\x0f\n\x05\x04\x19\x02\x02\x08\
    \x12\x06\xb7\x0c\x18\xba\x0c\x03\n\x0e\n\x06\x04\x19\x02\x02\x08\x03\x12\
    \x04\xb8\x0c\x04\x15\n\x10\n\x08\x04\x19\x02\x02\x08\x9c\x08\0\x12\x04\
    \xb9\x0c\x04*\n\x8d\x01\n\x04\x04\x19\x02\x03\x12\x06\xbe\x0c\x02\xc1\
    \x0c\x04\x1a}\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\
    \x20node\x20pool\x20to\x20upgrade.\n\x20This\x20field\x20has\x20been\x20\
    deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\
    \x04\x19\x02\x03\x05\x12\x04\xbe\x0c\x02\x08\n\r\n\x05\x04\x19\x02\x03\
    \x01\x12\x04\xbe\x0c\t\x15\n\r\n\x05\x04\x19\x02\x03\x03\x12\x04\xbe\x0c\
    \x18\x19\n\x0f\n\x05\x04\x19\x02\x03\x08\x12\x06\xbe\x0c\x1a\xc1\x0c\x03\
    \n\x0e\n\x06\x04\x19\x02\x03\x08\x03\x12\x04\xbf\x0c\x04\x15\n\x10\n\x08\
    \x04\x19\x02\x03\x08\x9c\x08\0\x12\x04\xc0\x0c\x04*\nF\n\x04\x04\x19\x02\
    \x04\x12\x04\xc4\x0c\x02O\x1a8\x20Required.\x20Autoscaling\x20configurat\
    ion\x20for\x20the\x20node\x20pool.\n\n\r\n\x05\x04\x19\x02\x04\x06\x12\
    \x04\xc4\x0c\x02\x15\n\r\n\x05\x04\x19\x02\x04\x01\x12\x04\xc4\x0c\x16!\
    \n\r\n\x05\x04\x19\x02\x04\x03\x12\x04\xc4\x0c$%\n\r\n\x05\x04\x19\x02\
    \x04\x08\x12\x04\xc4\x0c&N\n\x10\n\x08\x04\x19\x02\x04\x08\x9c\x08\0\x12\
    \x04\xc4\x0c'M\n\xb9\x01\n\x04\x04\x19\x02\x05\x12\x04\xc9\x0c\x02\x12\
    \x1a\xaa\x01\x20The\x20name\x20(project,\x20location,\x20cluster,\x20nod\
    e\x20pool)\x20of\x20the\x20node\x20pool\x20to\x20set\n\x20autoscaler\x20\
    settings.\x20Specified\x20in\x20the\x20format\n\x20'projects/*/locations\
    /*/clusters/*/nodePools/*'.\n\n\r\n\x05\x04\x19\x02\x05\x05\x12\x04\xc9\
    \x0c\x02\x08\n\r\n\x05\x04\x19\x02\x05\x01\x12\x04\xc9\x0c\t\r\n\r\n\x05\
    \x04\x19\x02\x05\x03\x12\x04\xc9\x0c\x10\x11\nO\n\x02\x04\x1a\x12\x06\
    \xcd\x0c\0\xed\x0c\x01\x1aA\x20SetLoggingServiceRequest\x20sets\x20the\
    \x20logging\x20service\x20of\x20a\x20cluster.\n\n\x0b\n\x03\x04\x1a\x01\
    \x12\x04\xcd\x0c\x08\x20\n\xd8\x01\n\x04\x04\x1a\x02\0\x12\x06\xd1\x0c\
    \x02\xd4\x0c\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20Googl\
    e\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\n\x20numbe\
    r](https://support.google.com/cloud/answer/6158840).\n\x20This\x20field\
    \x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\
    \x20field.\n\n\r\n\x05\x04\x1a\x02\0\x05\x12\x04\xd1\x0c\x02\x08\n\r\n\
    \x05\x04\x1a\x02\0\x01\x12\x04\xd1\x0c\t\x13\n\r\n\x05\x04\x1a\x02\0\x03\
    \x12\x04\xd1\x0c\x16\x17\n\x0f\n\x05\x04\x1a\x02\0\x08\x12\x06\xd1\x0c\
    \x18\xd4\x0c\x03\n\x0e\n\x06\x04\x1a\x02\0\x08\x03\x12\x04\xd2\x0c\x04\
    \x15\n\x10\n\x08\x04\x1a\x02\0\x08\x9c\x08\0\x12\x04\xd3\x0c\x04*\n\xd2\
    \x01\n\x04\x04\x1a\x02\x01\x12\x04\xda\x0c\x02;\x1a\xc3\x01\x20Required.\
    \x20Deprecated.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Engi\
    ne\n\x20[zone](/compute/docs/zones#available)\x20in\x20which\x20the\x20c\
    luster\n\x20resides.\n\x20This\x20field\x20has\x20been\x20deprecated\x20\
    and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x1a\x02\
    \x01\x05\x12\x04\xda\x0c\x02\x08\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\
    \xda\x0c\t\r\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xda\x0c\x10\x11\n\r\n\
    \x05\x04\x1a\x02\x01\x08\x12\x04\xda\x0c\x12:\n\x10\n\x08\x04\x1a\x02\
    \x01\x08\x9c\x08\0\x12\x04\xda\x0c\x139\n\x8b\x01\n\x04\x04\x1a\x02\x02\
    \x12\x06\xde\x0c\x02\xe1\x0c\x04\x1a{\x20Required.\x20Deprecated.\x20The\
    \x20name\x20of\x20the\x20cluster\x20to\x20upgrade.\n\x20This\x20field\
    \x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\
    \x20field.\n\n\r\n\x05\x04\x1a\x02\x02\x05\x12\x04\xde\x0c\x02\x08\n\r\n\
    \x05\x04\x1a\x02\x02\x01\x12\x04\xde\x0c\t\x13\n\r\n\x05\x04\x1a\x02\x02\
    \x03\x12\x04\xde\x0c\x16\x17\n\x0f\n\x05\x04\x1a\x02\x02\x08\x12\x06\xde\
    \x0c\x18\xe1\x0c\x03\n\x0e\n\x06\x04\x1a\x02\x02\x08\x03\x12\x04\xdf\x0c\
    \x04\x15\n\x10\n\x08\x04\x1a\x02\x02\x08\x9c\x08\0\x12\x04\xe0\x0c\x04*\
    \n\xee\x01\n\x04\x04\x1a\x02\x03\x12\x04\xe8\x0c\x02F\x1a\xdf\x01\x20Req\
    uired.\x20The\x20logging\x20service\x20the\x20cluster\x20should\x20use\
    \x20to\x20write\x20metrics.\n\x20Currently\x20available\x20options:\n\n\
    \x20*\x20\"logging.googleapis.com\"\x20-\x20the\x20Google\x20Cloud\x20Lo\
    gging\x20service\n\x20*\x20\"none\"\x20-\x20no\x20metrics\x20will\x20be\
    \x20exported\x20from\x20the\x20cluster\n\n\r\n\x05\x04\x1a\x02\x03\x05\
    \x12\x04\xe8\x0c\x02\x08\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\xe8\x0c\t\
    \x18\n\r\n\x05\x04\x1a\x02\x03\x03\x12\x04\xe8\x0c\x1b\x1c\n\r\n\x05\x04\
    \x1a\x02\x03\x08\x12\x04\xe8\x0c\x1dE\n\x10\n\x08\x04\x1a\x02\x03\x08\
    \x9c\x08\0\x12\x04\xe8\x0c\x1eD\n\x93\x01\n\x04\x04\x1a\x02\x04\x12\x04\
    \xec\x0c\x02\x12\x1a\x84\x01\x20The\x20name\x20(project,\x20location,\
    \x20cluster)\x20of\x20the\x20cluster\x20to\x20set\x20logging.\n\x20Speci\
    fied\x20in\x20the\x20format\x20'projects/*/locations/*/clusters/*'.\n\n\
    \r\n\x05\x04\x1a\x02\x04\x05\x12\x04\xec\x0c\x02\x08\n\r\n\x05\x04\x1a\
    \x02\x04\x01\x12\x04\xec\x0c\t\r\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\
    \xec\x0c\x10\x11\nU\n\x02\x04\x1b\x12\x06\xf0\x0c\0\x95\r\x01\x1aG\x20Se\
    tMonitoringServiceRequest\x20sets\x20the\x20monitoring\x20service\x20of\
    \x20a\x20cluster.\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xf0\x0c\x08#\n\xd8\
    \x01\n\x04\x04\x1b\x02\0\x12\x06\xf4\x0c\x02\xf7\x0c\x04\x1a\xc7\x01\x20\
    Required.\x20Deprecated.\x20The\x20Google\x20Developers\x20Console\x20[p\
    roject\x20ID\x20or\x20project\n\x20number](https://support.google.com/cl\
    oud/answer/6158840).\n\x20This\x20field\x20has\x20been\x20deprecated\x20\
    and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x1b\x02\0\
    \x05\x12\x04\xf4\x0c\x02\x08\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xf4\x0c\
    \t\x13\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xf4\x0c\x16\x17\n\x0f\n\x05\
    \x04\x1b\x02\0\x08\x12\x06\xf4\x0c\x18\xf7\x0c\x03\n\x0e\n\x06\x04\x1b\
    \x02\0\x08\x03\x12\x04\xf5\x0c\x04\x15\n\x10\n\x08\x04\x1b\x02\0\x08\x9c\
    \x08\0\x12\x04\xf6\x0c\x04*\n\xd4\x01\n\x04\x04\x1b\x02\x01\x12\x06\xfd\
    \x0c\x02\x80\r\x04\x1a\xc3\x01\x20Required.\x20Deprecated.\x20The\x20nam\
    e\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/docs/\
    zones#available)\x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20Thi\
    s\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\
    \x20name\x20field.\n\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\xfd\x0c\x02\
    \x08\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xfd\x0c\t\r\n\r\n\x05\x04\x1b\
    \x02\x01\x03\x12\x04\xfd\x0c\x10\x11\n\x0f\n\x05\x04\x1b\x02\x01\x08\x12\
    \x06\xfd\x0c\x12\x80\r\x03\n\x0e\n\x06\x04\x1b\x02\x01\x08\x03\x12\x04\
    \xfe\x0c\x04\x15\n\x10\n\x08\x04\x1b\x02\x01\x08\x9c\x08\0\x12\x04\xff\
    \x0c\x04*\n\x8b\x01\n\x04\x04\x1b\x02\x02\x12\x06\x84\r\x02\x87\r\x04\
    \x1a{\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20cluster\
    \x20to\x20upgrade.\n\x20This\x20field\x20has\x20been\x20deprecated\x20an\
    d\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x1b\x02\x02\
    \x05\x12\x04\x84\r\x02\x08\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\x84\r\t\
    \x13\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\x84\r\x16\x17\n\x0f\n\x05\x04\
    \x1b\x02\x02\x08\x12\x06\x84\r\x18\x87\r\x03\n\x0e\n\x06\x04\x1b\x02\x02\
    \x08\x03\x12\x04\x85\r\x04\x15\n\x10\n\x08\x04\x1b\x02\x02\x08\x9c\x08\0\
    \x12\x04\x86\r\x04*\n\xee\x02\n\x04\x04\x1b\x02\x03\x12\x04\x90\r\x02I\
    \x1a\xdf\x02\x20Required.\x20The\x20monitoring\x20service\x20the\x20clus\
    ter\x20should\x20use\x20to\x20write\x20metrics.\n\x20Currently\x20availa\
    ble\x20options:\n\n\x20*\x20\"monitoring.googleapis.com/kubernetes\"\x20\
    -\x20the\x20Google\x20Cloud\x20Monitoring\n\x20service\x20with\x20Kubern\
    etes-native\x20resource\x20model\n\x20*\x20\"monitoring.googleapis.com\"\
    \x20-\x20the\x20Google\x20Cloud\x20Monitoring\x20service\n\x20*\x20\"non\
    e\"\x20-\x20no\x20metrics\x20will\x20be\x20exported\x20from\x20the\x20cl\
    uster\n\n\r\n\x05\x04\x1b\x02\x03\x05\x12\x04\x90\r\x02\x08\n\r\n\x05\
    \x04\x1b\x02\x03\x01\x12\x04\x90\r\t\x1b\n\r\n\x05\x04\x1b\x02\x03\x03\
    \x12\x04\x90\r\x1e\x1f\n\r\n\x05\x04\x1b\x02\x03\x08\x12\x04\x90\r\x20H\
    \n\x10\n\x08\x04\x1b\x02\x03\x08\x9c\x08\0\x12\x04\x90\r!G\n\x96\x01\n\
    \x04\x04\x1b\x02\x04\x12\x04\x94\r\x02\x12\x1a\x87\x01\x20The\x20name\
    \x20(project,\x20location,\x20cluster)\x20of\x20the\x20cluster\x20to\x20\
    set\x20monitoring.\n\x20Specified\x20in\x20the\x20format\x20'projects/*/\
    locations/*/clusters/*'.\n\n\r\n\x05\x04\x1b\x02\x04\x05\x12\x04\x94\r\
    \x02\x08\n\r\n\x05\x04\x1b\x02\x04\x01\x12\x04\x94\r\t\r\n\r\n\x05\x04\
    \x1b\x02\x04\x03\x12\x04\x94\r\x10\x11\nS\n\x02\x04\x1c\x12\x06\x98\r\0\
    \xb8\r\x01\x1aE\x20SetAddonsConfigRequest\x20sets\x20the\x20addons\x20as\
    sociated\x20with\x20the\x20cluster.\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\
    \x98\r\x08\x1e\n\xd8\x01\n\x04\x04\x1c\x02\0\x12\x06\x9c\r\x02\x9f\r\x04\
    \x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20Google\x20Developers\
    \x20Console\x20[project\x20ID\x20or\x20project\n\x20number](https://supp\
    ort.google.com/cloud/answer/6158840).\n\x20This\x20field\x20has\x20been\
    \x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\
    \x05\x04\x1c\x02\0\x05\x12\x04\x9c\r\x02\x08\n\r\n\x05\x04\x1c\x02\0\x01\
    \x12\x04\x9c\r\t\x13\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\x9c\r\x16\x17\n\
    \x0f\n\x05\x04\x1c\x02\0\x08\x12\x06\x9c\r\x18\x9f\r\x03\n\x0e\n\x06\x04\
    \x1c\x02\0\x08\x03\x12\x04\x9d\r\x04\x15\n\x10\n\x08\x04\x1c\x02\0\x08\
    \x9c\x08\0\x12\x04\x9e\r\x04*\n\xd4\x01\n\x04\x04\x1c\x02\x01\x12\x06\
    \xa5\r\x02\xa8\r\x04\x1a\xc3\x01\x20Required.\x20Deprecated.\x20The\x20n\
    ame\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/doc\
    s/zones#available)\x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20T\
    his\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20th\
    e\x20name\x20field.\n\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xa5\r\x02\
    \x08\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xa5\r\t\r\n\r\n\x05\x04\x1c\
    \x02\x01\x03\x12\x04\xa5\r\x10\x11\n\x0f\n\x05\x04\x1c\x02\x01\x08\x12\
    \x06\xa5\r\x12\xa8\r\x03\n\x0e\n\x06\x04\x1c\x02\x01\x08\x03\x12\x04\xa6\
    \r\x04\x15\n\x10\n\x08\x04\x1c\x02\x01\x08\x9c\x08\0\x12\x04\xa7\r\x04*\
    \n\x8b\x01\n\x04\x04\x1c\x02\x02\x12\x06\xac\r\x02\xaf\r\x04\x1a{\x20Req\
    uired.\x20Deprecated.\x20The\x20name\x20of\x20the\x20cluster\x20to\x20up\
    grade.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20replace\
    d\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x1c\x02\x02\x05\x12\x04\
    \xac\r\x02\x08\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xac\r\t\x13\n\r\n\
    \x05\x04\x1c\x02\x02\x03\x12\x04\xac\r\x16\x17\n\x0f\n\x05\x04\x1c\x02\
    \x02\x08\x12\x06\xac\r\x18\xaf\r\x03\n\x0e\n\x06\x04\x1c\x02\x02\x08\x03\
    \x12\x04\xad\r\x04\x15\n\x10\n\x08\x04\x1c\x02\x02\x08\x9c\x08\0\x12\x04\
    \xae\r\x04*\nm\n\x04\x04\x1c\x02\x03\x12\x04\xb3\r\x02J\x1a_\x20Required\
    .\x20The\x20desired\x20configurations\x20for\x20the\x20various\x20addons\
    \x20available\x20to\x20run\x20in\x20the\n\x20cluster.\n\n\r\n\x05\x04\
    \x1c\x02\x03\x06\x12\x04\xb3\r\x02\x0e\n\r\n\x05\x04\x1c\x02\x03\x01\x12\
    \x04\xb3\r\x0f\x1c\n\r\n\x05\x04\x1c\x02\x03\x03\x12\x04\xb3\r\x1f\x20\n\
    \r\n\x05\x04\x1c\x02\x03\x08\x12\x04\xb3\r!I\n\x10\n\x08\x04\x1c\x02\x03\
    \x08\x9c\x08\0\x12\x04\xb3\r\"H\n\x92\x01\n\x04\x04\x1c\x02\x04\x12\x04\
    \xb7\r\x02\x12\x1a\x83\x01\x20The\x20name\x20(project,\x20location,\x20c\
    luster)\x20of\x20the\x20cluster\x20to\x20set\x20addons.\n\x20Specified\
    \x20in\x20the\x20format\x20'projects/*/locations/*/clusters/*'.\n\n\r\n\
    \x05\x04\x1c\x02\x04\x05\x12\x04\xb7\r\x02\x08\n\r\n\x05\x04\x1c\x02\x04\
    \x01\x12\x04\xb7\r\t\r\n\r\n\x05\x04\x1c\x02\x04\x03\x12\x04\xb7\r\x10\
    \x11\nF\n\x02\x04\x1d\x12\x06\xbb\r\0\xe0\r\x01\x1a8\x20SetLocationsRequ\
    est\x20sets\x20the\x20locations\x20of\x20the\x20cluster.\n\n\x0b\n\x03\
    \x04\x1d\x01\x12\x04\xbb\r\x08\x1b\n\xd8\x01\n\x04\x04\x1d\x02\0\x12\x06\
    \xbf\r\x02\xc2\r\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20G\
    oogle\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\n\x20n\
    umber](https://support.google.com/cloud/answer/6158840).\n\x20This\x20fi\
    eld\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\
    \x20field.\n\n\r\n\x05\x04\x1d\x02\0\x05\x12\x04\xbf\r\x02\x08\n\r\n\x05\
    \x04\x1d\x02\0\x01\x12\x04\xbf\r\t\x13\n\r\n\x05\x04\x1d\x02\0\x03\x12\
    \x04\xbf\r\x16\x17\n\x0f\n\x05\x04\x1d\x02\0\x08\x12\x06\xbf\r\x18\xc2\r\
    \x03\n\x0e\n\x06\x04\x1d\x02\0\x08\x03\x12\x04\xc0\r\x04\x15\n\x10\n\x08\
    \x04\x1d\x02\0\x08\x9c\x08\0\x12\x04\xc1\r\x04*\n\xd4\x01\n\x04\x04\x1d\
    \x02\x01\x12\x06\xc8\r\x02\xcb\r\x04\x1a\xc3\x01\x20Required.\x20Depreca\
    ted.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zo\
    ne](/compute/docs/zones#available)\x20in\x20which\x20the\x20cluster\n\
    \x20resides.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20r\
    eplaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x1d\x02\x01\x05\
    \x12\x04\xc8\r\x02\x08\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xc8\r\t\r\n\
    \r\n\x05\x04\x1d\x02\x01\x03\x12\x04\xc8\r\x10\x11\n\x0f\n\x05\x04\x1d\
    \x02\x01\x08\x12\x06\xc8\r\x12\xcb\r\x03\n\x0e\n\x06\x04\x1d\x02\x01\x08\
    \x03\x12\x04\xc9\r\x04\x15\n\x10\n\x08\x04\x1d\x02\x01\x08\x9c\x08\0\x12\
    \x04\xca\r\x04*\n\x8b\x01\n\x04\x04\x1d\x02\x02\x12\x06\xcf\r\x02\xd2\r\
    \x04\x1a{\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20clu\
    ster\x20to\x20upgrade.\n\x20This\x20field\x20has\x20been\x20deprecated\
    \x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x1d\
    \x02\x02\x05\x12\x04\xcf\r\x02\x08\n\r\n\x05\x04\x1d\x02\x02\x01\x12\x04\
    \xcf\r\t\x13\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xcf\r\x16\x17\n\x0f\n\
    \x05\x04\x1d\x02\x02\x08\x12\x06\xcf\r\x18\xd2\r\x03\n\x0e\n\x06\x04\x1d\
    \x02\x02\x08\x03\x12\x04\xd0\r\x04\x15\n\x10\n\x08\x04\x1d\x02\x02\x08\
    \x9c\x08\0\x12\x04\xd1\r\x04*\n\x84\x03\n\x04\x04\x1d\x02\x03\x12\x04\
    \xdb\r\x02I\x1a\xf5\x02\x20Required.\x20The\x20desired\x20list\x20of\x20\
    Google\x20Compute\x20Engine\n\x20[zones](/compute/docs/zones#available)\
    \x20in\x20which\x20the\x20cluster's\x20nodes\n\x20should\x20be\x20locate\
    d.\x20Changing\x20the\x20locations\x20a\x20cluster\x20is\x20in\x20will\
    \x20result\n\x20in\x20nodes\x20being\x20either\x20created\x20or\x20remov\
    ed\x20from\x20the\x20cluster,\x20depending\x20on\n\x20whether\x20locatio\
    ns\x20are\x20being\x20added\x20or\x20removed.\n\n\x20This\x20list\x20mus\
    t\x20always\x20include\x20the\x20cluster's\x20primary\x20zone.\n\n\r\n\
    \x05\x04\x1d\x02\x03\x04\x12\x04\xdb\r\x02\n\n\r\n\x05\x04\x1d\x02\x03\
    \x05\x12\x04\xdb\r\x0b\x11\n\r\n\x05\x04\x1d\x02\x03\x01\x12\x04\xdb\r\
    \x12\x1b\n\r\n\x05\x04\x1d\x02\x03\x03\x12\x04\xdb\r\x1e\x1f\n\r\n\x05\
    \x04\x1d\x02\x03\x08\x12\x04\xdb\r\x20H\n\x10\n\x08\x04\x1d\x02\x03\x08\
    \x9c\x08\0\x12\x04\xdb\r!G\n\x95\x01\n\x04\x04\x1d\x02\x04\x12\x04\xdf\r\
    \x02\x12\x1a\x86\x01\x20The\x20name\x20(project,\x20location,\x20cluster\
    )\x20of\x20the\x20cluster\x20to\x20set\x20locations.\n\x20Specified\x20i\
    n\x20the\x20format\x20'projects/*/locations/*/clusters/*'.\n\n\r\n\x05\
    \x04\x1d\x02\x04\x05\x12\x04\xdf\r\x02\x08\n\r\n\x05\x04\x1d\x02\x04\x01\
    \x12\x04\xdf\r\t\r\n\r\n\x05\x04\x1d\x02\x04\x03\x12\x04\xdf\r\x10\x11\n\
    F\n\x02\x04\x1e\x12\x06\xe3\r\0\x8b\x0e\x01\x1a8\x20UpdateMasterRequest\
    \x20updates\x20the\x20master\x20of\x20the\x20cluster.\n\n\x0b\n\x03\x04\
    \x1e\x01\x12\x04\xe3\r\x08\x1b\n\xd8\x01\n\x04\x04\x1e\x02\0\x12\x06\xe7\
    \r\x02\xea\r\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20Googl\
    e\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\n\x20numbe\
    r](https://support.google.com/cloud/answer/6158840).\n\x20This\x20field\
    \x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\
    \x20field.\n\n\r\n\x05\x04\x1e\x02\0\x05\x12\x04\xe7\r\x02\x08\n\r\n\x05\
    \x04\x1e\x02\0\x01\x12\x04\xe7\r\t\x13\n\r\n\x05\x04\x1e\x02\0\x03\x12\
    \x04\xe7\r\x16\x17\n\x0f\n\x05\x04\x1e\x02\0\x08\x12\x06\xe7\r\x18\xea\r\
    \x03\n\x0e\n\x06\x04\x1e\x02\0\x08\x03\x12\x04\xe8\r\x04\x15\n\x10\n\x08\
    \x04\x1e\x02\0\x08\x9c\x08\0\x12\x04\xe9\r\x04*\n\xd4\x01\n\x04\x04\x1e\
    \x02\x01\x12\x06\xf0\r\x02\xf3\r\x04\x1a\xc3\x01\x20Required.\x20Depreca\
    ted.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zo\
    ne](/compute/docs/zones#available)\x20in\x20which\x20the\x20cluster\n\
    \x20resides.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20r\
    eplaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x1e\x02\x01\x05\
    \x12\x04\xf0\r\x02\x08\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\xf0\r\t\r\n\
    \r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xf0\r\x10\x11\n\x0f\n\x05\x04\x1e\
    \x02\x01\x08\x12\x06\xf0\r\x12\xf3\r\x03\n\x0e\n\x06\x04\x1e\x02\x01\x08\
    \x03\x12\x04\xf1\r\x04\x15\n\x10\n\x08\x04\x1e\x02\x01\x08\x9c\x08\0\x12\
    \x04\xf2\r\x04*\n\x8b\x01\n\x04\x04\x1e\x02\x02\x12\x06\xf7\r\x02\xfa\r\
    \x04\x1a{\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20clu\
    ster\x20to\x20upgrade.\n\x20This\x20field\x20has\x20been\x20deprecated\
    \x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x1e\
    \x02\x02\x05\x12\x04\xf7\r\x02\x08\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\
    \xf7\r\t\x13\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xf7\r\x16\x17\n\x0f\n\
    \x05\x04\x1e\x02\x02\x08\x12\x06\xf7\r\x18\xfa\r\x03\n\x0e\n\x06\x04\x1e\
    \x02\x02\x08\x03\x12\x04\xf8\r\x04\x15\n\x10\n\x08\x04\x1e\x02\x02\x08\
    \x9c\x08\0\x12\x04\xf9\r\x04*\n\xf5\x03\n\x04\x04\x1e\x02\x03\x12\x04\
    \x86\x0e\x02E\x1a\xe6\x03\x20Required.\x20The\x20Kubernetes\x20version\
    \x20to\x20change\x20the\x20master\x20to.\n\n\x20Users\x20may\x20specify\
    \x20either\x20explicit\x20versions\x20offered\x20by\x20Kubernetes\x20Eng\
    ine\x20or\n\x20version\x20aliases,\x20which\x20have\x20the\x20following\
    \x20behavior:\n\n\x20-\x20\"latest\":\x20picks\x20the\x20highest\x20vali\
    d\x20Kubernetes\x20version\n\x20-\x20\"1.X\":\x20picks\x20the\x20highest\
    \x20valid\x20patch+gke.N\x20patch\x20in\x20the\x201.X\x20version\n\x20-\
    \x20\"1.X.Y\":\x20picks\x20the\x20highest\x20valid\x20gke.N\x20patch\x20\
    in\x20the\x201.X.Y\x20version\n\x20-\x20\"1.X.Y-gke.N\":\x20picks\x20an\
    \x20explicit\x20Kubernetes\x20version\n\x20-\x20\"-\":\x20picks\x20the\
    \x20default\x20Kubernetes\x20version\n\n\r\n\x05\x04\x1e\x02\x03\x05\x12\
    \x04\x86\x0e\x02\x08\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\x86\x0e\t\x17\
    \n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\x86\x0e\x1a\x1b\n\r\n\x05\x04\x1e\
    \x02\x03\x08\x12\x04\x86\x0e\x1cD\n\x10\n\x08\x04\x1e\x02\x03\x08\x9c\
    \x08\0\x12\x04\x86\x0e\x1dC\n\x8d\x01\n\x04\x04\x1e\x02\x04\x12\x04\x8a\
    \x0e\x02\x12\x1a\x7f\x20The\x20name\x20(project,\x20location,\x20cluster\
    )\x20of\x20the\x20cluster\x20to\x20update.\n\x20Specified\x20in\x20the\
    \x20format\x20'projects/*/locations/*/clusters/*'.\n\n\r\n\x05\x04\x1e\
    \x02\x04\x05\x12\x04\x8a\x0e\x02\x08\n\r\n\x05\x04\x1e\x02\x04\x01\x12\
    \x04\x8a\x0e\t\r\n\r\n\x05\x04\x1e\x02\x04\x03\x12\x04\x8a\x0e\x10\x11\n\
    M\n\x02\x04\x1f\x12\x06\x8e\x0e\0\xc2\x0e\x01\x1a?\x20SetMasterAuthReque\
    st\x20updates\x20the\x20admin\x20password\x20of\x20a\x20cluster.\n\n\x0b\
    \n\x03\x04\x1f\x01\x12\x04\x8e\x0e\x08\x1c\n>\n\x04\x04\x1f\x04\0\x12\
    \x06\x90\x0e\x02\x9f\x0e\x03\x1a.\x20Operation\x20type:\x20what\x20type\
    \x20update\x20to\x20perform.\n\n\r\n\x05\x04\x1f\x04\0\x01\x12\x04\x90\
    \x0e\x07\r\n:\n\x06\x04\x1f\x04\0\x02\0\x12\x04\x92\x0e\x04\x10\x1a*\x20\
    Operation\x20is\x20unknown\x20and\x20will\x20error\x20out.\n\n\x0f\n\x07\
    \x04\x1f\x04\0\x02\0\x01\x12\x04\x92\x0e\x04\x0b\n\x0f\n\x07\x04\x1f\x04\
    \0\x02\0\x02\x12\x04\x92\x0e\x0e\x0f\n=\n\x06\x04\x1f\x04\0\x02\x01\x12\
    \x04\x95\x0e\x04\x15\x1a-\x20Set\x20the\x20password\x20to\x20a\x20user\
    \x20generated\x20value.\n\n\x0f\n\x07\x04\x1f\x04\0\x02\x01\x01\x12\x04\
    \x95\x0e\x04\x10\n\x0f\n\x07\x04\x1f\x04\0\x02\x01\x02\x12\x04\x95\x0e\
    \x13\x14\n=\n\x06\x04\x1f\x04\0\x02\x02\x12\x04\x98\x0e\x04\x1a\x1a-\x20\
    Generate\x20a\x20new\x20password\x20and\x20set\x20it\x20to\x20that.\n\n\
    \x0f\n\x07\x04\x1f\x04\0\x02\x02\x01\x12\x04\x98\x0e\x04\x15\n\x0f\n\x07\
    \x04\x1f\x04\0\x02\x02\x02\x12\x04\x98\x0e\x18\x19\n\xf7\x01\n\x06\x04\
    \x1f\x04\0\x02\x03\x12\x04\x9e\x0e\x04\x15\x1a\xe6\x01\x20Set\x20the\x20\
    username.\x20\x20If\x20an\x20empty\x20username\x20is\x20provided,\x20bas\
    ic\x20authentication\n\x20is\x20disabled\x20for\x20the\x20cluster.\x20\
    \x20If\x20a\x20non-empty\x20username\x20is\x20provided,\x20basic\n\x20au\
    thentication\x20is\x20enabled,\x20with\x20either\x20a\x20provided\x20pas\
    sword\x20or\x20a\x20generated\n\x20one.\n\n\x0f\n\x07\x04\x1f\x04\0\x02\
    \x03\x01\x12\x04\x9e\x0e\x04\x10\n\x0f\n\x07\x04\x1f\x04\0\x02\x03\x02\
    \x12\x04\x9e\x0e\x13\x14\n\xd8\x01\n\x04\x04\x1f\x02\0\x12\x06\xa4\x0e\
    \x02\xa7\x0e\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20Googl\
    e\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\n\x20numbe\
    r](https://support.google.com/cloud/answer/6158840).\n\x20This\x20field\
    \x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\
    \x20field.\n\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xa4\x0e\x02\x08\n\r\n\
    \x05\x04\x1f\x02\0\x01\x12\x04\xa4\x0e\t\x13\n\r\n\x05\x04\x1f\x02\0\x03\
    \x12\x04\xa4\x0e\x16\x17\n\x0f\n\x05\x04\x1f\x02\0\x08\x12\x06\xa4\x0e\
    \x18\xa7\x0e\x03\n\x0e\n\x06\x04\x1f\x02\0\x08\x03\x12\x04\xa5\x0e\x04\
    \x15\n\x10\n\x08\x04\x1f\x02\0\x08\x9c\x08\0\x12\x04\xa6\x0e\x04*\n\xd4\
    \x01\n\x04\x04\x1f\x02\x01\x12\x06\xad\x0e\x02\xb0\x0e\x04\x1a\xc3\x01\
    \x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20Google\x20Co\
    mpute\x20Engine\n\x20[zone](/compute/docs/zones#available)\x20in\x20whic\
    h\x20the\x20cluster\n\x20resides.\n\x20This\x20field\x20has\x20been\x20d\
    eprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\
    \x04\x1f\x02\x01\x05\x12\x04\xad\x0e\x02\x08\n\r\n\x05\x04\x1f\x02\x01\
    \x01\x12\x04\xad\x0e\t\r\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xad\x0e\
    \x10\x11\n\x0f\n\x05\x04\x1f\x02\x01\x08\x12\x06\xad\x0e\x12\xb0\x0e\x03\
    \n\x0e\n\x06\x04\x1f\x02\x01\x08\x03\x12\x04\xae\x0e\x04\x15\n\x10\n\x08\
    \x04\x1f\x02\x01\x08\x9c\x08\0\x12\x04\xaf\x0e\x04*\n\x8b\x01\n\x04\x04\
    \x1f\x02\x02\x12\x06\xb4\x0e\x02\xb7\x0e\x04\x1a{\x20Required.\x20Deprec\
    ated.\x20The\x20name\x20of\x20the\x20cluster\x20to\x20upgrade.\n\x20This\
    \x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\
    \x20name\x20field.\n\n\r\n\x05\x04\x1f\x02\x02\x05\x12\x04\xb4\x0e\x02\
    \x08\n\r\n\x05\x04\x1f\x02\x02\x01\x12\x04\xb4\x0e\t\x13\n\r\n\x05\x04\
    \x1f\x02\x02\x03\x12\x04\xb4\x0e\x16\x17\n\x0f\n\x05\x04\x1f\x02\x02\x08\
    \x12\x06\xb4\x0e\x18\xb7\x0e\x03\n\x0e\n\x06\x04\x1f\x02\x02\x08\x03\x12\
    \x04\xb5\x0e\x04\x15\n\x10\n\x08\x04\x1f\x02\x02\x08\x9c\x08\0\x12\x04\
    \xb6\x0e\x04*\nR\n\x04\x04\x1f\x02\x03\x12\x04\xba\x0e\x02=\x1aD\x20Requ\
    ired.\x20The\x20exact\x20form\x20of\x20action\x20to\x20be\x20taken\x20on\
    \x20the\x20master\x20auth.\n\n\r\n\x05\x04\x1f\x02\x03\x06\x12\x04\xba\
    \x0e\x02\x08\n\r\n\x05\x04\x1f\x02\x03\x01\x12\x04\xba\x0e\t\x0f\n\r\n\
    \x05\x04\x1f\x02\x03\x03\x12\x04\xba\x0e\x12\x13\n\r\n\x05\x04\x1f\x02\
    \x03\x08\x12\x04\xba\x0e\x14<\n\x10\n\x08\x04\x1f\x02\x03\x08\x9c\x08\0\
    \x12\x04\xba\x0e\x15;\n6\n\x04\x04\x1f\x02\x04\x12\x04\xbd\x0e\x02A\x1a(\
    \x20Required.\x20A\x20description\x20of\x20the\x20update.\n\n\r\n\x05\
    \x04\x1f\x02\x04\x06\x12\x04\xbd\x0e\x02\x0c\n\r\n\x05\x04\x1f\x02\x04\
    \x01\x12\x04\xbd\x0e\r\x13\n\r\n\x05\x04\x1f\x02\x04\x03\x12\x04\xbd\x0e\
    \x16\x17\n\r\n\x05\x04\x1f\x02\x04\x08\x12\x04\xbd\x0e\x18@\n\x10\n\x08\
    \x04\x1f\x02\x04\x08\x9c\x08\0\x12\x04\xbd\x0e\x19?\n\x90\x01\n\x04\x04\
    \x1f\x02\x05\x12\x04\xc1\x0e\x02\x12\x1a\x81\x01\x20The\x20name\x20(proj\
    ect,\x20location,\x20cluster)\x20of\x20the\x20cluster\x20to\x20set\x20au\
    th.\n\x20Specified\x20in\x20the\x20format\x20'projects/*/locations/*/clu\
    sters/*'.\n\n\r\n\x05\x04\x1f\x02\x05\x05\x12\x04\xc1\x0e\x02\x08\n\r\n\
    \x05\x04\x1f\x02\x05\x01\x12\x04\xc1\x0e\t\r\n\r\n\x05\x04\x1f\x02\x05\
    \x03\x12\x04\xc1\x0e\x10\x11\n7\n\x02\x04\x20\x12\x06\xc5\x0e\0\xe1\x0e\
    \x01\x1a)\x20DeleteClusterRequest\x20deletes\x20a\x20cluster.\n\n\x0b\n\
    \x03\x04\x20\x01\x12\x04\xc5\x0e\x08\x1c\n\xd8\x01\n\x04\x04\x20\x02\0\
    \x12\x06\xc9\x0e\x02\xcc\x0e\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\
    \x20The\x20Google\x20Developers\x20Console\x20[project\x20ID\x20or\x20pr\
    oject\n\x20number](https://support.google.com/cloud/answer/6158840).\n\
    \x20This\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\
    \x20the\x20name\x20field.\n\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xc9\x0e\
    \x02\x08\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xc9\x0e\t\x13\n\r\n\x05\x04\
    \x20\x02\0\x03\x12\x04\xc9\x0e\x16\x17\n\x0f\n\x05\x04\x20\x02\0\x08\x12\
    \x06\xc9\x0e\x18\xcc\x0e\x03\n\x0e\n\x06\x04\x20\x02\0\x08\x03\x12\x04\
    \xca\x0e\x04\x15\n\x10\n\x08\x04\x20\x02\0\x08\x9c\x08\0\x12\x04\xcb\x0e\
    \x04*\n\xd4\x01\n\x04\x04\x20\x02\x01\x12\x06\xd2\x0e\x02\xd5\x0e\x04\
    \x1a\xc3\x01\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20\
    Google\x20Compute\x20Engine\n\x20[zone](/compute/docs/zones#available)\
    \x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20This\x20field\x20ha\
    s\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field\
    .\n\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xd2\x0e\x02\x08\n\r\n\x05\x04\
    \x20\x02\x01\x01\x12\x04\xd2\x0e\t\r\n\r\n\x05\x04\x20\x02\x01\x03\x12\
    \x04\xd2\x0e\x10\x11\n\x0f\n\x05\x04\x20\x02\x01\x08\x12\x06\xd2\x0e\x12\
    \xd5\x0e\x03\n\x0e\n\x06\x04\x20\x02\x01\x08\x03\x12\x04\xd3\x0e\x04\x15\
    \n\x10\n\x08\x04\x20\x02\x01\x08\x9c\x08\0\x12\x04\xd4\x0e\x04*\n\x8a\
    \x01\n\x04\x04\x20\x02\x02\x12\x06\xd9\x0e\x02\xdc\x0e\x04\x1az\x20Requi\
    red.\x20Deprecated.\x20The\x20name\x20of\x20the\x20cluster\x20to\x20dele\
    te.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\
    \x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04\x20\x02\x02\x05\x12\x04\
    \xd9\x0e\x02\x08\n\r\n\x05\x04\x20\x02\x02\x01\x12\x04\xd9\x0e\t\x13\n\r\
    \n\x05\x04\x20\x02\x02\x03\x12\x04\xd9\x0e\x16\x17\n\x0f\n\x05\x04\x20\
    \x02\x02\x08\x12\x06\xd9\x0e\x18\xdc\x0e\x03\n\x0e\n\x06\x04\x20\x02\x02\
    \x08\x03\x12\x04\xda\x0e\x04\x15\n\x10\n\x08\x04\x20\x02\x02\x08\x9c\x08\
    \0\x12\x04\xdb\x0e\x04*\n\x8d\x01\n\x04\x04\x20\x02\x03\x12\x04\xe0\x0e\
    \x02\x12\x1a\x7f\x20The\x20name\x20(project,\x20location,\x20cluster)\
    \x20of\x20the\x20cluster\x20to\x20delete.\n\x20Specified\x20in\x20the\
    \x20format\x20'projects/*/locations/*/clusters/*'.\n\n\r\n\x05\x04\x20\
    \x02\x03\x05\x12\x04\xe0\x0e\x02\x08\n\r\n\x05\x04\x20\x02\x03\x01\x12\
    \x04\xe0\x0e\t\r\n\r\n\x05\x04\x20\x02\x03\x03\x12\x04\xe0\x0e\x10\x11\n\
    3\n\x02\x04!\x12\x06\xe4\x0e\0\xfa\x0e\x01\x1a%\x20ListClustersRequest\
    \x20lists\x20clusters.\n\n\x0b\n\x03\x04!\x01\x12\x04\xe4\x0e\x08\x1b\n\
    \xda\x01\n\x04\x04!\x02\0\x12\x06\xe8\x0e\x02\xeb\x0e\x04\x1a\xc9\x01\
    \x20Required.\x20Deprecated.\x20The\x20Google\x20Developers\x20Console\
    \x20[project\x20ID\x20or\x20project\n\x20number](https://support.google.\
    com/cloud/answer/6158840).\n\x20This\x20field\x20has\x20been\x20deprecat\
    ed\x20and\x20replaced\x20by\x20the\x20parent\x20field.\n\n\r\n\x05\x04!\
    \x02\0\x05\x12\x04\xe8\x0e\x02\x08\n\r\n\x05\x04!\x02\0\x01\x12\x04\xe8\
    \x0e\t\x13\n\r\n\x05\x04!\x02\0\x03\x12\x04\xe8\x0e\x16\x17\n\x0f\n\x05\
    \x04!\x02\0\x08\x12\x06\xe8\x0e\x18\xeb\x0e\x03\n\x0e\n\x06\x04!\x02\0\
    \x08\x03\x12\x04\xe9\x0e\x04\x15\n\x10\n\x08\x04!\x02\0\x08\x9c\x08\0\
    \x12\x04\xea\x0e\x04*\n\xec\x01\n\x04\x04!\x02\x01\x12\x06\xf1\x0e\x02\
    \xf4\x0e\x04\x1a\xdb\x01\x20Required.\x20Deprecated.\x20The\x20name\x20o\
    f\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/docs/zones#\
    available)\x20in\x20which\x20the\x20cluster\n\x20resides,\x20or\x20\"-\"\
    \x20for\x20all\x20zones.\n\x20This\x20field\x20has\x20been\x20deprecated\
    \x20and\x20replaced\x20by\x20the\x20parent\x20field.\n\n\r\n\x05\x04!\
    \x02\x01\x05\x12\x04\xf1\x0e\x02\x08\n\r\n\x05\x04!\x02\x01\x01\x12\x04\
    \xf1\x0e\t\r\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xf1\x0e\x10\x11\n\x0f\n\
    \x05\x04!\x02\x01\x08\x12\x06\xf1\x0e\x12\xf4\x0e\x03\n\x0e\n\x06\x04!\
    \x02\x01\x08\x03\x12\x04\xf2\x0e\x04\x15\n\x10\n\x08\x04!\x02\x01\x08\
    \x9c\x08\0\x12\x04\xf3\x0e\x04*\n\xb9\x01\n\x04\x04!\x02\x02\x12\x04\xf9\
    \x0e\x02\x14\x1a\xaa\x01\x20The\x20parent\x20(project\x20and\x20location\
    )\x20where\x20the\x20clusters\x20will\x20be\x20listed.\n\x20Specified\
    \x20in\x20the\x20format\x20'projects/*/locations/*'.\n\x20Location\x20\"\
    -\"\x20matches\x20all\x20zones\x20and\x20all\x20regions.\n\n\r\n\x05\x04\
    !\x02\x02\x05\x12\x04\xf9\x0e\x02\x08\n\r\n\x05\x04!\x02\x02\x01\x12\x04\
    \xf9\x0e\t\x0f\n\r\n\x05\x04!\x02\x02\x03\x12\x04\xf9\x0e\x12\x13\nJ\n\
    \x02\x04\"\x12\x06\xfd\x0e\0\x85\x0f\x01\x1a<\x20ListClustersResponse\
    \x20is\x20the\x20result\x20of\x20ListClustersRequest.\n\n\x0b\n\x03\x04\
    \"\x01\x12\x04\xfd\x0e\x08\x1c\n]\n\x04\x04\"\x02\0\x12\x04\x80\x0f\x02\
    \x20\x1aO\x20A\x20list\x20of\x20clusters\x20in\x20the\x20project\x20in\
    \x20the\x20specified\x20zone,\x20or\n\x20across\x20all\x20ones.\n\n\r\n\
    \x05\x04\"\x02\0\x04\x12\x04\x80\x0f\x02\n\n\r\n\x05\x04\"\x02\0\x06\x12\
    \x04\x80\x0f\x0b\x12\n\r\n\x05\x04\"\x02\0\x01\x12\x04\x80\x0f\x13\x1b\n\
    \r\n\x05\x04\"\x02\0\x03\x12\x04\x80\x0f\x1e\x1f\nh\n\x04\x04\"\x02\x01\
    \x12\x04\x84\x0f\x02$\x1aZ\x20If\x20any\x20zones\x20are\x20listed\x20her\
    e,\x20the\x20list\x20of\x20clusters\x20returned\n\x20may\x20be\x20missin\
    g\x20those\x20zones.\n\n\r\n\x05\x04\"\x02\x01\x04\x12\x04\x84\x0f\x02\n\
    \n\r\n\x05\x04\"\x02\x01\x05\x12\x04\x84\x0f\x0b\x11\n\r\n\x05\x04\"\x02\
    \x01\x01\x12\x04\x84\x0f\x12\x1f\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\x84\
    \x0f\"#\n<\n\x02\x04#\x12\x06\x88\x0f\0\xa4\x0f\x01\x1a.\x20GetOperation\
    Request\x20gets\x20a\x20single\x20operation.\n\n\x0b\n\x03\x04#\x01\x12\
    \x04\x88\x0f\x08\x1b\n\xd8\x01\n\x04\x04#\x02\0\x12\x06\x8c\x0f\x02\x8f\
    \x0f\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20Google\x20Dev\
    elopers\x20Console\x20[project\x20ID\x20or\x20project\n\x20number](https\
    ://support.google.com/cloud/answer/6158840).\n\x20This\x20field\x20has\
    \x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\
    \n\n\r\n\x05\x04#\x02\0\x05\x12\x04\x8c\x0f\x02\x08\n\r\n\x05\x04#\x02\0\
    \x01\x12\x04\x8c\x0f\t\x13\n\r\n\x05\x04#\x02\0\x03\x12\x04\x8c\x0f\x16\
    \x17\n\x0f\n\x05\x04#\x02\0\x08\x12\x06\x8c\x0f\x18\x8f\x0f\x03\n\x0e\n\
    \x06\x04#\x02\0\x08\x03\x12\x04\x8d\x0f\x04\x15\n\x10\n\x08\x04#\x02\0\
    \x08\x9c\x08\0\x12\x04\x8e\x0f\x04*\n\xd4\x01\n\x04\x04#\x02\x01\x12\x06\
    \x95\x0f\x02\x98\x0f\x04\x1a\xc3\x01\x20Required.\x20Deprecated.\x20The\
    \x20name\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/comput\
    e/docs/zones#available)\x20in\x20which\x20the\x20cluster\n\x20resides.\n\
    \x20This\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\
    \x20the\x20name\x20field.\n\n\r\n\x05\x04#\x02\x01\x05\x12\x04\x95\x0f\
    \x02\x08\n\r\n\x05\x04#\x02\x01\x01\x12\x04\x95\x0f\t\r\n\r\n\x05\x04#\
    \x02\x01\x03\x12\x04\x95\x0f\x10\x11\n\x0f\n\x05\x04#\x02\x01\x08\x12\
    \x06\x95\x0f\x12\x98\x0f\x03\n\x0e\n\x06\x04#\x02\x01\x08\x03\x12\x04\
    \x96\x0f\x04\x15\n\x10\n\x08\x04#\x02\x01\x08\x9c\x08\0\x12\x04\x97\x0f\
    \x04*\n\x95\x01\n\x04\x04#\x02\x02\x12\x06\x9c\x0f\x02\x9f\x0f\x04\x1a\
    \x84\x01\x20Required.\x20Deprecated.\x20The\x20server-assigned\x20`name`\
    \x20of\x20the\x20operation.\n\x20This\x20field\x20has\x20been\x20depreca\
    ted\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04#\
    \x02\x02\x05\x12\x04\x9c\x0f\x02\x08\n\r\n\x05\x04#\x02\x02\x01\x12\x04\
    \x9c\x0f\t\x15\n\r\n\x05\x04#\x02\x02\x03\x12\x04\x9c\x0f\x18\x19\n\x0f\
    \n\x05\x04#\x02\x02\x08\x12\x06\x9c\x0f\x1a\x9f\x0f\x03\n\x0e\n\x06\x04#\
    \x02\x02\x08\x03\x12\x04\x9d\x0f\x04\x15\n\x10\n\x08\x04#\x02\x02\x08\
    \x9c\x08\0\x12\x04\x9e\x0f\x04*\n\x94\x01\n\x04\x04#\x02\x03\x12\x04\xa3\
    \x0f\x02\x12\x1a\x85\x01\x20The\x20name\x20(project,\x20location,\x20ope\
    ration\x20id)\x20of\x20the\x20operation\x20to\x20get.\n\x20Specified\x20\
    in\x20the\x20format\x20'projects/*/locations/*/operations/*'.\n\n\r\n\
    \x05\x04#\x02\x03\x05\x12\x04\xa3\x0f\x02\x08\n\r\n\x05\x04#\x02\x03\x01\
    \x12\x04\xa3\x0f\t\r\n\r\n\x05\x04#\x02\x03\x03\x12\x04\xa3\x0f\x10\x11\
    \n7\n\x02\x04$\x12\x06\xa7\x0f\0\xbc\x0f\x01\x1a)\x20ListOperationsReque\
    st\x20lists\x20operations.\n\n\x0b\n\x03\x04$\x01\x12\x04\xa7\x0f\x08\
    \x1d\n\xda\x01\n\x04\x04$\x02\0\x12\x06\xab\x0f\x02\xae\x0f\x04\x1a\xc9\
    \x01\x20Required.\x20Deprecated.\x20The\x20Google\x20Developers\x20Conso\
    le\x20[project\x20ID\x20or\x20project\n\x20number](https://support.googl\
    e.com/cloud/answer/6158840).\n\x20This\x20field\x20has\x20been\x20deprec\
    ated\x20and\x20replaced\x20by\x20the\x20parent\x20field.\n\n\r\n\x05\x04\
    $\x02\0\x05\x12\x04\xab\x0f\x02\x08\n\r\n\x05\x04$\x02\0\x01\x12\x04\xab\
    \x0f\t\x13\n\r\n\x05\x04$\x02\0\x03\x12\x04\xab\x0f\x16\x17\n\x0f\n\x05\
    \x04$\x02\0\x08\x12\x06\xab\x0f\x18\xae\x0f\x03\n\x0e\n\x06\x04$\x02\0\
    \x08\x03\x12\x04\xac\x0f\x04\x15\n\x10\n\x08\x04$\x02\0\x08\x9c\x08\0\
    \x12\x04\xad\x0f\x04*\n\xe7\x01\n\x04\x04$\x02\x01\x12\x06\xb3\x0f\x02\
    \xb6\x0f\x04\x1a\xd6\x01\x20Required.\x20Deprecated.\x20The\x20name\x20o\
    f\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/docs/zones#\
    available)\x20to\x20return\x20operations\x20for,\x20or\x20`-`\x20for\n\
    \x20all\x20zones.\x20This\x20field\x20has\x20been\x20deprecated\x20and\
    \x20replaced\x20by\x20the\x20parent\x20field.\n\n\r\n\x05\x04$\x02\x01\
    \x05\x12\x04\xb3\x0f\x02\x08\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xb3\x0f\
    \t\r\n\r\n\x05\x04$\x02\x01\x03\x12\x04\xb3\x0f\x10\x11\n\x0f\n\x05\x04$\
    \x02\x01\x08\x12\x06\xb3\x0f\x12\xb6\x0f\x03\n\x0e\n\x06\x04$\x02\x01\
    \x08\x03\x12\x04\xb4\x0f\x04\x15\n\x10\n\x08\x04$\x02\x01\x08\x9c\x08\0\
    \x12\x04\xb5\x0f\x04*\n\xbb\x01\n\x04\x04$\x02\x02\x12\x04\xbb\x0f\x02\
    \x14\x1a\xac\x01\x20The\x20parent\x20(project\x20and\x20location)\x20whe\
    re\x20the\x20operations\x20will\x20be\x20listed.\n\x20Specified\x20in\
    \x20the\x20format\x20'projects/*/locations/*'.\n\x20Location\x20\"-\"\
    \x20matches\x20all\x20zones\x20and\x20all\x20regions.\n\n\r\n\x05\x04$\
    \x02\x02\x05\x12\x04\xbb\x0f\x02\x08\n\r\n\x05\x04$\x02\x02\x01\x12\x04\
    \xbb\x0f\t\x0f\n\r\n\x05\x04$\x02\x02\x03\x12\x04\xbb\x0f\x12\x13\nB\n\
    \x02\x04%\x12\x06\xbf\x0f\0\xda\x0f\x01\x1a4\x20CancelOperationRequest\
    \x20cancels\x20a\x20single\x20operation.\n\n\x0b\n\x03\x04%\x01\x12\x04\
    \xbf\x0f\x08\x1e\n\xd8\x01\n\x04\x04%\x02\0\x12\x06\xc3\x0f\x02\xc6\x0f\
    \x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20Google\x20Develop\
    ers\x20Console\x20[project\x20ID\x20or\x20project\n\x20number](https://s\
    upport.google.com/cloud/answer/6158840).\n\x20This\x20field\x20has\x20be\
    en\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\
    \n\x05\x04%\x02\0\x05\x12\x04\xc3\x0f\x02\x08\n\r\n\x05\x04%\x02\0\x01\
    \x12\x04\xc3\x0f\t\x13\n\r\n\x05\x04%\x02\0\x03\x12\x04\xc3\x0f\x16\x17\
    \n\x0f\n\x05\x04%\x02\0\x08\x12\x06\xc3\x0f\x18\xc6\x0f\x03\n\x0e\n\x06\
    \x04%\x02\0\x08\x03\x12\x04\xc4\x0f\x04\x15\n\x10\n\x08\x04%\x02\0\x08\
    \x9c\x08\0\x12\x04\xc5\x0f\x04*\n\xd5\x01\n\x04\x04%\x02\x01\x12\x06\xcb\
    \x0f\x02\xce\x0f\x04\x1a\xc4\x01\x20Required.\x20Deprecated.\x20The\x20n\
    ame\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/doc\
    s/zones#available)\x20in\x20which\x20the\x20operation\x20resides.\n\x20T\
    his\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20th\
    e\x20name\x20field.\n\n\r\n\x05\x04%\x02\x01\x05\x12\x04\xcb\x0f\x02\x08\
    \n\r\n\x05\x04%\x02\x01\x01\x12\x04\xcb\x0f\t\r\n\r\n\x05\x04%\x02\x01\
    \x03\x12\x04\xcb\x0f\x10\x11\n\x0f\n\x05\x04%\x02\x01\x08\x12\x06\xcb\
    \x0f\x12\xce\x0f\x03\n\x0e\n\x06\x04%\x02\x01\x08\x03\x12\x04\xcc\x0f\
    \x04\x15\n\x10\n\x08\x04%\x02\x01\x08\x9c\x08\0\x12\x04\xcd\x0f\x04*\n\
    \x95\x01\n\x04\x04%\x02\x02\x12\x06\xd2\x0f\x02\xd5\x0f\x04\x1a\x84\x01\
    \x20Required.\x20Deprecated.\x20The\x20server-assigned\x20`name`\x20of\
    \x20the\x20operation.\n\x20This\x20field\x20has\x20been\x20deprecated\
    \x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04%\x02\
    \x02\x05\x12\x04\xd2\x0f\x02\x08\n\r\n\x05\x04%\x02\x02\x01\x12\x04\xd2\
    \x0f\t\x15\n\r\n\x05\x04%\x02\x02\x03\x12\x04\xd2\x0f\x18\x19\n\x0f\n\
    \x05\x04%\x02\x02\x08\x12\x06\xd2\x0f\x1a\xd5\x0f\x03\n\x0e\n\x06\x04%\
    \x02\x02\x08\x03\x12\x04\xd3\x0f\x04\x15\n\x10\n\x08\x04%\x02\x02\x08\
    \x9c\x08\0\x12\x04\xd4\x0f\x04*\n\x97\x01\n\x04\x04%\x02\x03\x12\x04\xd9\
    \x0f\x02\x12\x1a\x88\x01\x20The\x20name\x20(project,\x20location,\x20ope\
    ration\x20id)\x20of\x20the\x20operation\x20to\x20cancel.\n\x20Specified\
    \x20in\x20the\x20format\x20'projects/*/locations/*/operations/*'.\n\n\r\
    \n\x05\x04%\x02\x03\x05\x12\x04\xd9\x0f\x02\x08\n\r\n\x05\x04%\x02\x03\
    \x01\x12\x04\xd9\x0f\t\r\n\r\n\x05\x04%\x02\x03\x03\x12\x04\xd9\x0f\x10\
    \x11\nN\n\x02\x04&\x12\x06\xdd\x0f\0\xe4\x0f\x01\x1a@\x20ListOperationsR\
    esponse\x20is\x20the\x20result\x20of\x20ListOperationsRequest.\n\n\x0b\n\
    \x03\x04&\x01\x12\x04\xdd\x0f\x08\x1e\nJ\n\x04\x04&\x02\0\x12\x04\xdf\
    \x0f\x02$\x1a<\x20A\x20list\x20of\x20operations\x20in\x20the\x20project\
    \x20in\x20the\x20specified\x20zone.\n\n\r\n\x05\x04&\x02\0\x04\x12\x04\
    \xdf\x0f\x02\n\n\r\n\x05\x04&\x02\0\x06\x12\x04\xdf\x0f\x0b\x14\n\r\n\
    \x05\x04&\x02\0\x01\x12\x04\xdf\x0f\x15\x1f\n\r\n\x05\x04&\x02\0\x03\x12\
    \x04\xdf\x0f\"#\n~\n\x04\x04&\x02\x01\x12\x04\xe3\x0f\x02$\x1ap\x20If\
    \x20any\x20zones\x20are\x20listed\x20here,\x20the\x20list\x20of\x20opera\
    tions\x20returned\n\x20may\x20be\x20missing\x20the\x20operations\x20from\
    \x20those\x20zones.\n\n\r\n\x05\x04&\x02\x01\x04\x12\x04\xe3\x0f\x02\n\n\
    \r\n\x05\x04&\x02\x01\x05\x12\x04\xe3\x0f\x0b\x11\n\r\n\x05\x04&\x02\x01\
    \x01\x12\x04\xe3\x0f\x12\x1f\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xe3\x0f\
    \"#\nI\n\x02\x04'\x12\x06\xe7\x0f\0\xfb\x0f\x01\x1a;\x20Gets\x20the\x20c\
    urrent\x20Kubernetes\x20Engine\x20service\x20configuration.\n\n\x0b\n\
    \x03\x04'\x01\x12\x04\xe7\x0f\x08\x1e\n\xd8\x01\n\x04\x04'\x02\0\x12\x06\
    \xeb\x0f\x02\xee\x0f\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\
    \x20Google\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\n\
    \x20number](https://support.google.com/cloud/answer/6158840).\n\x20This\
    \x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\
    \x20name\x20field.\n\n\r\n\x05\x04'\x02\0\x05\x12\x04\xeb\x0f\x02\x08\n\
    \r\n\x05\x04'\x02\0\x01\x12\x04\xeb\x0f\t\x13\n\r\n\x05\x04'\x02\0\x03\
    \x12\x04\xeb\x0f\x16\x17\n\x0f\n\x05\x04'\x02\0\x08\x12\x06\xeb\x0f\x18\
    \xee\x0f\x03\n\x0e\n\x06\x04'\x02\0\x08\x03\x12\x04\xec\x0f\x04\x15\n\
    \x10\n\x08\x04'\x02\0\x08\x9c\x08\0\x12\x04\xed\x0f\x04*\n\xcf\x01\n\x04\
    \x04'\x02\x01\x12\x06\xf3\x0f\x02\xf6\x0f\x04\x1a\xbe\x01\x20Required.\
    \x20Deprecated.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Engi\
    ne\n\x20[zone](/compute/docs/zones#available)\x20to\x20return\x20operati\
    ons\x20for.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20re\
    placed\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04'\x02\x01\x05\x12\
    \x04\xf3\x0f\x02\x08\n\r\n\x05\x04'\x02\x01\x01\x12\x04\xf3\x0f\t\r\n\r\
    \n\x05\x04'\x02\x01\x03\x12\x04\xf3\x0f\x10\x11\n\x0f\n\x05\x04'\x02\x01\
    \x08\x12\x06\xf3\x0f\x12\xf6\x0f\x03\n\x0e\n\x06\x04'\x02\x01\x08\x03\
    \x12\x04\xf4\x0f\x04\x15\n\x10\n\x08\x04'\x02\x01\x08\x9c\x08\0\x12\x04\
    \xf5\x0f\x04*\n\x7f\n\x04\x04'\x02\x02\x12\x04\xfa\x0f\x02\x12\x1aq\x20T\
    he\x20name\x20(project\x20and\x20location)\x20of\x20the\x20server\x20con\
    fig\x20to\x20get,\n\x20specified\x20in\x20the\x20format\x20'projects/*/l\
    ocations/*'.\n\n\r\n\x05\x04'\x02\x02\x05\x12\x04\xfa\x0f\x02\x08\n\r\n\
    \x05\x04'\x02\x02\x01\x12\x04\xfa\x0f\t\r\n\r\n\x05\x04'\x02\x02\x03\x12\
    \x04\xfa\x0f\x10\x11\n8\n\x02\x04(\x12\x06\xfe\x0f\0\x8d\x10\x01\x1a*\
    \x20Kubernetes\x20Engine\x20service\x20configuration.\n\n\x0b\n\x03\x04(\
    \x01\x12\x04\xfe\x0f\x08\x14\nE\n\x04\x04(\x02\0\x12\x04\x80\x10\x02%\
    \x1a7\x20Version\x20of\x20Kubernetes\x20the\x20service\x20deploys\x20by\
    \x20default.\n\n\r\n\x05\x04(\x02\0\x05\x12\x04\x80\x10\x02\x08\n\r\n\
    \x05\x04(\x02\0\x01\x12\x04\x80\x10\t\x20\n\r\n\x05\x04(\x02\0\x03\x12\
    \x04\x80\x10#$\n;\n\x04\x04(\x02\x01\x12\x04\x83\x10\x02*\x1a-\x20List\
    \x20of\x20valid\x20node\x20upgrade\x20target\x20versions.\n\n\r\n\x05\
    \x04(\x02\x01\x04\x12\x04\x83\x10\x02\n\n\r\n\x05\x04(\x02\x01\x05\x12\
    \x04\x83\x10\x0b\x11\n\r\n\x05\x04(\x02\x01\x01\x12\x04\x83\x10\x12%\n\r\
    \n\x05\x04(\x02\x01\x03\x12\x04\x83\x10()\n#\n\x04\x04(\x02\x02\x12\x04\
    \x86\x10\x02\x20\x1a\x15\x20Default\x20image\x20type.\n\n\r\n\x05\x04(\
    \x02\x02\x05\x12\x04\x86\x10\x02\x08\n\r\n\x05\x04(\x02\x02\x01\x12\x04\
    \x86\x10\t\x1b\n\r\n\x05\x04(\x02\x02\x03\x12\x04\x86\x10\x1e\x1f\n*\n\
    \x04\x04(\x02\x03\x12\x04\x89\x10\x02(\x1a\x1c\x20List\x20of\x20valid\
    \x20image\x20types.\n\n\r\n\x05\x04(\x02\x03\x04\x12\x04\x89\x10\x02\n\n\
    \r\n\x05\x04(\x02\x03\x05\x12\x04\x89\x10\x0b\x11\n\r\n\x05\x04(\x02\x03\
    \x01\x12\x04\x89\x10\x12#\n\r\n\x05\x04(\x02\x03\x03\x12\x04\x89\x10&'\n\
    .\n\x04\x04(\x02\x04\x12\x04\x8c\x10\x02,\x1a\x20\x20List\x20of\x20valid\
    \x20master\x20versions.\n\n\r\n\x05\x04(\x02\x04\x04\x12\x04\x8c\x10\x02\
    \n\n\r\n\x05\x04(\x02\x04\x05\x12\x04\x8c\x10\x0b\x11\n\r\n\x05\x04(\x02\
    \x04\x01\x12\x04\x8c\x10\x12'\n\r\n\x05\x04(\x02\x04\x03\x12\x04\x8c\x10\
    *+\nH\n\x02\x04)\x12\x06\x90\x10\0\xb0\x10\x01\x1a:\x20CreateNodePoolReq\
    uest\x20creates\x20a\x20node\x20pool\x20for\x20a\x20cluster.\n\n\x0b\n\
    \x03\x04)\x01\x12\x04\x90\x10\x08\x1d\n\xe8\x01\n\x04\x04)\x02\0\x12\x06\
    \x94\x10\x02\x97\x10\x04\x1a\xd7\x01\x20Required.\x20Deprecated.\x20The\
    \x20Google\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\n\
    \x20number](https://developers.google.com/console/help/new/#projectnumbe\
    r).\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\
    \x20by\x20the\x20parent\x20field.\n\n\r\n\x05\x04)\x02\0\x05\x12\x04\x94\
    \x10\x02\x08\n\r\n\x05\x04)\x02\0\x01\x12\x04\x94\x10\t\x13\n\r\n\x05\
    \x04)\x02\0\x03\x12\x04\x94\x10\x16\x17\n\x0f\n\x05\x04)\x02\0\x08\x12\
    \x06\x94\x10\x18\x97\x10\x03\n\x0e\n\x06\x04)\x02\0\x08\x03\x12\x04\x95\
    \x10\x04\x15\n\x10\n\x08\x04)\x02\0\x08\x9c\x08\0\x12\x04\x96\x10\x04*\n\
    \xd6\x01\n\x04\x04)\x02\x01\x12\x06\x9d\x10\x02\xa0\x10\x04\x1a\xc5\x01\
    \x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20Google\x20Co\
    mpute\x20Engine\n\x20[zone](/compute/docs/zones#available)\x20in\x20whic\
    h\x20the\x20cluster\n\x20resides.\n\x20This\x20field\x20has\x20been\x20d\
    eprecated\x20and\x20replaced\x20by\x20the\x20parent\x20field.\n\n\r\n\
    \x05\x04)\x02\x01\x05\x12\x04\x9d\x10\x02\x08\n\r\n\x05\x04)\x02\x01\x01\
    \x12\x04\x9d\x10\t\r\n\r\n\x05\x04)\x02\x01\x03\x12\x04\x9d\x10\x10\x11\
    \n\x0f\n\x05\x04)\x02\x01\x08\x12\x06\x9d\x10\x12\xa0\x10\x03\n\x0e\n\
    \x06\x04)\x02\x01\x08\x03\x12\x04\x9e\x10\x04\x15\n\x10\n\x08\x04)\x02\
    \x01\x08\x9c\x08\0\x12\x04\x9f\x10\x04*\n\x82\x01\n\x04\x04)\x02\x02\x12\
    \x06\xa4\x10\x02\xa7\x10\x04\x1ar\x20Required.\x20Deprecated.\x20The\x20\
    name\x20of\x20the\x20cluster.\n\x20This\x20field\x20has\x20been\x20depre\
    cated\x20and\x20replaced\x20by\x20the\x20parent\x20field.\n\n\r\n\x05\
    \x04)\x02\x02\x05\x12\x04\xa4\x10\x02\x08\n\r\n\x05\x04)\x02\x02\x01\x12\
    \x04\xa4\x10\t\x13\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xa4\x10\x16\x17\n\
    \x0f\n\x05\x04)\x02\x02\x08\x12\x06\xa4\x10\x18\xa7\x10\x03\n\x0e\n\x06\
    \x04)\x02\x02\x08\x03\x12\x04\xa5\x10\x04\x15\n\x10\n\x08\x04)\x02\x02\
    \x08\x9c\x08\0\x12\x04\xa6\x10\x04*\n2\n\x04\x04)\x02\x03\x12\x04\xaa\
    \x10\x02B\x1a$\x20Required.\x20The\x20node\x20pool\x20to\x20create.\n\n\
    \r\n\x05\x04)\x02\x03\x06\x12\x04\xaa\x10\x02\n\n\r\n\x05\x04)\x02\x03\
    \x01\x12\x04\xaa\x10\x0b\x14\n\r\n\x05\x04)\x02\x03\x03\x12\x04\xaa\x10\
    \x17\x18\n\r\n\x05\x04)\x02\x03\x08\x12\x04\xaa\x10\x19A\n\x10\n\x08\x04\
    )\x02\x03\x08\x9c\x08\0\x12\x04\xaa\x10\x1a@\n\x9f\x01\n\x04\x04)\x02\
    \x04\x12\x04\xaf\x10\x02\x14\x1a\x90\x01\x20The\x20parent\x20(project,\
    \x20location,\x20cluster\x20id)\x20where\x20the\x20node\x20pool\x20will\
    \x20be\n\x20created.\x20Specified\x20in\x20the\x20format\n\x20'projects/\
    */locations/*/clusters/*'.\n\n\r\n\x05\x04)\x02\x04\x05\x12\x04\xaf\x10\
    \x02\x08\n\r\n\x05\x04)\x02\x04\x01\x12\x04\xaf\x10\t\x0f\n\r\n\x05\x04)\
    \x02\x04\x03\x12\x04\xaf\x10\x12\x13\nH\n\x02\x04*\x12\x06\xb3\x10\0\xd7\
    \x10\x01\x1a:\x20DeleteNodePoolRequest\x20deletes\x20a\x20node\x20pool\
    \x20for\x20a\x20cluster.\n\n\x0b\n\x03\x04*\x01\x12\x04\xb3\x10\x08\x1d\
    \n\xe6\x01\n\x04\x04*\x02\0\x12\x06\xb7\x10\x02\xba\x10\x04\x1a\xd5\x01\
    \x20Required.\x20Deprecated.\x20The\x20Google\x20Developers\x20Console\
    \x20[project\x20ID\x20or\x20project\n\x20number](https://developers.goog\
    le.com/console/help/new/#projectnumber).\n\x20This\x20field\x20has\x20be\
    en\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\
    \n\x05\x04*\x02\0\x05\x12\x04\xb7\x10\x02\x08\n\r\n\x05\x04*\x02\0\x01\
    \x12\x04\xb7\x10\t\x13\n\r\n\x05\x04*\x02\0\x03\x12\x04\xb7\x10\x16\x17\
    \n\x0f\n\x05\x04*\x02\0\x08\x12\x06\xb7\x10\x18\xba\x10\x03\n\x0e\n\x06\
    \x04*\x02\0\x08\x03\x12\x04\xb8\x10\x04\x15\n\x10\n\x08\x04*\x02\0\x08\
    \x9c\x08\0\x12\x04\xb9\x10\x04*\n\xd4\x01\n\x04\x04*\x02\x01\x12\x06\xc0\
    \x10\x02\xc3\x10\x04\x1a\xc3\x01\x20Required.\x20Deprecated.\x20The\x20n\
    ame\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/doc\
    s/zones#available)\x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20T\
    his\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20th\
    e\x20name\x20field.\n\n\r\n\x05\x04*\x02\x01\x05\x12\x04\xc0\x10\x02\x08\
    \n\r\n\x05\x04*\x02\x01\x01\x12\x04\xc0\x10\t\r\n\r\n\x05\x04*\x02\x01\
    \x03\x12\x04\xc0\x10\x10\x11\n\x0f\n\x05\x04*\x02\x01\x08\x12\x06\xc0\
    \x10\x12\xc3\x10\x03\n\x0e\n\x06\x04*\x02\x01\x08\x03\x12\x04\xc1\x10\
    \x04\x15\n\x10\n\x08\x04*\x02\x01\x08\x9c\x08\0\x12\x04\xc2\x10\x04*\n\
    \x80\x01\n\x04\x04*\x02\x02\x12\x06\xc7\x10\x02\xca\x10\x04\x1ap\x20Requ\
    ired.\x20Deprecated.\x20The\x20name\x20of\x20the\x20cluster.\n\x20This\
    \x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\
    \x20name\x20field.\n\n\r\n\x05\x04*\x02\x02\x05\x12\x04\xc7\x10\x02\x08\
    \n\r\n\x05\x04*\x02\x02\x01\x12\x04\xc7\x10\t\x13\n\r\n\x05\x04*\x02\x02\
    \x03\x12\x04\xc7\x10\x16\x17\n\x0f\n\x05\x04*\x02\x02\x08\x12\x06\xc7\
    \x10\x18\xca\x10\x03\n\x0e\n\x06\x04*\x02\x02\x08\x03\x12\x04\xc8\x10\
    \x04\x15\n\x10\n\x08\x04*\x02\x02\x08\x9c\x08\0\x12\x04\xc9\x10\x04*\n\
    \x8c\x01\n\x04\x04*\x02\x03\x12\x06\xce\x10\x02\xd1\x10\x04\x1a|\x20Requ\
    ired.\x20Deprecated.\x20The\x20name\x20of\x20the\x20node\x20pool\x20to\
    \x20delete.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20re\
    placed\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04*\x02\x03\x05\x12\
    \x04\xce\x10\x02\x08\n\r\n\x05\x04*\x02\x03\x01\x12\x04\xce\x10\t\x15\n\
    \r\n\x05\x04*\x02\x03\x03\x12\x04\xce\x10\x18\x19\n\x0f\n\x05\x04*\x02\
    \x03\x08\x12\x06\xce\x10\x1a\xd1\x10\x03\n\x0e\n\x06\x04*\x02\x03\x08\
    \x03\x12\x04\xcf\x10\x04\x15\n\x10\n\x08\x04*\x02\x03\x08\x9c\x08\0\x12\
    \x04\xd0\x10\x04*\n\xab\x01\n\x04\x04*\x02\x04\x12\x04\xd6\x10\x02\x12\
    \x1a\x9c\x01\x20The\x20name\x20(project,\x20location,\x20cluster,\x20nod\
    e\x20pool\x20id)\x20of\x20the\x20node\x20pool\x20to\n\x20delete.\x20Spec\
    ified\x20in\x20the\x20format\n\x20'projects/*/locations/*/clusters/*/nod\
    ePools/*'.\n\n\r\n\x05\x04*\x02\x04\x05\x12\x04\xd6\x10\x02\x08\n\r\n\
    \x05\x04*\x02\x04\x01\x12\x04\xd6\x10\t\r\n\r\n\x05\x04*\x02\x04\x03\x12\
    \x04\xd6\x10\x10\x11\nJ\n\x02\x04+\x12\x06\xda\x10\0\xf6\x10\x01\x1a<\
    \x20ListNodePoolsRequest\x20lists\x20the\x20node\x20pool(s)\x20for\x20a\
    \x20cluster.\n\n\x0b\n\x03\x04+\x01\x12\x04\xda\x10\x08\x1c\n\xe8\x01\n\
    \x04\x04+\x02\0\x12\x06\xde\x10\x02\xe1\x10\x04\x1a\xd7\x01\x20Required.\
    \x20Deprecated.\x20The\x20Google\x20Developers\x20Console\x20[project\
    \x20ID\x20or\x20project\n\x20number](https://developers.google.com/conso\
    le/help/new/#projectnumber).\n\x20This\x20field\x20has\x20been\x20deprec\
    ated\x20and\x20replaced\x20by\x20the\x20parent\x20field.\n\n\r\n\x05\x04\
    +\x02\0\x05\x12\x04\xde\x10\x02\x08\n\r\n\x05\x04+\x02\0\x01\x12\x04\xde\
    \x10\t\x13\n\r\n\x05\x04+\x02\0\x03\x12\x04\xde\x10\x16\x17\n\x0f\n\x05\
    \x04+\x02\0\x08\x12\x06\xde\x10\x18\xe1\x10\x03\n\x0e\n\x06\x04+\x02\0\
    \x08\x03\x12\x04\xdf\x10\x04\x15\n\x10\n\x08\x04+\x02\0\x08\x9c\x08\0\
    \x12\x04\xe0\x10\x04*\n\xd6\x01\n\x04\x04+\x02\x01\x12\x06\xe7\x10\x02\
    \xea\x10\x04\x1a\xc5\x01\x20Required.\x20Deprecated.\x20The\x20name\x20o\
    f\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/docs/zones#\
    available)\x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20This\x20f\
    ield\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20par\
    ent\x20field.\n\n\r\n\x05\x04+\x02\x01\x05\x12\x04\xe7\x10\x02\x08\n\r\n\
    \x05\x04+\x02\x01\x01\x12\x04\xe7\x10\t\r\n\r\n\x05\x04+\x02\x01\x03\x12\
    \x04\xe7\x10\x10\x11\n\x0f\n\x05\x04+\x02\x01\x08\x12\x06\xe7\x10\x12\
    \xea\x10\x03\n\x0e\n\x06\x04+\x02\x01\x08\x03\x12\x04\xe8\x10\x04\x15\n\
    \x10\n\x08\x04+\x02\x01\x08\x9c\x08\0\x12\x04\xe9\x10\x04*\n\x82\x01\n\
    \x04\x04+\x02\x02\x12\x06\xee\x10\x02\xf1\x10\x04\x1ar\x20Required.\x20D\
    eprecated.\x20The\x20name\x20of\x20the\x20cluster.\n\x20This\x20field\
    \x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20parent\
    \x20field.\n\n\r\n\x05\x04+\x02\x02\x05\x12\x04\xee\x10\x02\x08\n\r\n\
    \x05\x04+\x02\x02\x01\x12\x04\xee\x10\t\x13\n\r\n\x05\x04+\x02\x02\x03\
    \x12\x04\xee\x10\x16\x17\n\x0f\n\x05\x04+\x02\x02\x08\x12\x06\xee\x10\
    \x18\xf1\x10\x03\n\x0e\n\x06\x04+\x02\x02\x08\x03\x12\x04\xef\x10\x04\
    \x15\n\x10\n\x08\x04+\x02\x02\x08\x9c\x08\0\x12\x04\xf0\x10\x04*\n\x9e\
    \x01\n\x04\x04+\x02\x03\x12\x04\xf5\x10\x02\x14\x1a\x8f\x01\x20The\x20pa\
    rent\x20(project,\x20location,\x20cluster\x20id)\x20where\x20the\x20node\
    \x20pools\x20will\x20be\n\x20listed.\x20Specified\x20in\x20the\x20format\
    \x20'projects/*/locations/*/clusters/*'.\n\n\r\n\x05\x04+\x02\x03\x05\
    \x12\x04\xf5\x10\x02\x08\n\r\n\x05\x04+\x02\x03\x01\x12\x04\xf5\x10\t\
    \x0f\n\r\n\x05\x04+\x02\x03\x03\x12\x04\xf5\x10\x12\x13\nG\n\x02\x04,\
    \x12\x06\xf9\x10\0\x9d\x11\x01\x1a9\x20GetNodePoolRequest\x20retrieves\
    \x20a\x20node\x20pool\x20for\x20a\x20cluster.\n\n\x0b\n\x03\x04,\x01\x12\
    \x04\xf9\x10\x08\x1a\n\xe6\x01\n\x04\x04,\x02\0\x12\x06\xfd\x10\x02\x80\
    \x11\x04\x1a\xd5\x01\x20Required.\x20Deprecated.\x20The\x20Google\x20Dev\
    elopers\x20Console\x20[project\x20ID\x20or\x20project\n\x20number](https\
    ://developers.google.com/console/help/new/#projectnumber).\n\x20This\x20\
    field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20na\
    me\x20field.\n\n\r\n\x05\x04,\x02\0\x05\x12\x04\xfd\x10\x02\x08\n\r\n\
    \x05\x04,\x02\0\x01\x12\x04\xfd\x10\t\x13\n\r\n\x05\x04,\x02\0\x03\x12\
    \x04\xfd\x10\x16\x17\n\x0f\n\x05\x04,\x02\0\x08\x12\x06\xfd\x10\x18\x80\
    \x11\x03\n\x0e\n\x06\x04,\x02\0\x08\x03\x12\x04\xfe\x10\x04\x15\n\x10\n\
    \x08\x04,\x02\0\x08\x9c\x08\0\x12\x04\xff\x10\x04*\n\xd4\x01\n\x04\x04,\
    \x02\x01\x12\x06\x86\x11\x02\x89\x11\x04\x1a\xc3\x01\x20Required.\x20Dep\
    recated.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Engine\n\
    \x20[zone](/compute/docs/zones#available)\x20in\x20which\x20the\x20clust\
    er\n\x20resides.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\
    \x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04,\x02\x01\x05\
    \x12\x04\x86\x11\x02\x08\n\r\n\x05\x04,\x02\x01\x01\x12\x04\x86\x11\t\r\
    \n\r\n\x05\x04,\x02\x01\x03\x12\x04\x86\x11\x10\x11\n\x0f\n\x05\x04,\x02\
    \x01\x08\x12\x06\x86\x11\x12\x89\x11\x03\n\x0e\n\x06\x04,\x02\x01\x08\
    \x03\x12\x04\x87\x11\x04\x15\n\x10\n\x08\x04,\x02\x01\x08\x9c\x08\0\x12\
    \x04\x88\x11\x04*\n\x80\x01\n\x04\x04,\x02\x02\x12\x06\x8d\x11\x02\x90\
    \x11\x04\x1ap\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\
    \x20cluster.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20r\
    eplaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04,\x02\x02\x05\x12\
    \x04\x8d\x11\x02\x08\n\r\n\x05\x04,\x02\x02\x01\x12\x04\x8d\x11\t\x13\n\
    \r\n\x05\x04,\x02\x02\x03\x12\x04\x8d\x11\x16\x17\n\x0f\n\x05\x04,\x02\
    \x02\x08\x12\x06\x8d\x11\x18\x90\x11\x03\n\x0e\n\x06\x04,\x02\x02\x08\
    \x03\x12\x04\x8e\x11\x04\x15\n\x10\n\x08\x04,\x02\x02\x08\x9c\x08\0\x12\
    \x04\x8f\x11\x04*\n\x82\x01\n\x04\x04,\x02\x03\x12\x06\x94\x11\x02\x97\
    \x11\x04\x1ar\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\
    \x20node\x20pool.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\
    \x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04,\x02\x03\x05\
    \x12\x04\x94\x11\x02\x08\n\r\n\x05\x04,\x02\x03\x01\x12\x04\x94\x11\t\
    \x15\n\r\n\x05\x04,\x02\x03\x03\x12\x04\x94\x11\x18\x19\n\x0f\n\x05\x04,\
    \x02\x03\x08\x12\x06\x94\x11\x1a\x97\x11\x03\n\x0e\n\x06\x04,\x02\x03\
    \x08\x03\x12\x04\x95\x11\x04\x15\n\x10\n\x08\x04,\x02\x03\x08\x9c\x08\0\
    \x12\x04\x96\x11\x04*\n\xa8\x01\n\x04\x04,\x02\x04\x12\x04\x9c\x11\x02\
    \x12\x1a\x99\x01\x20The\x20name\x20(project,\x20location,\x20cluster,\
    \x20node\x20pool\x20id)\x20of\x20the\x20node\x20pool\x20to\n\x20get.\x20\
    Specified\x20in\x20the\x20format\n\x20'projects/*/locations/*/clusters/*\
    /nodePools/*'.\n\n\r\n\x05\x04,\x02\x04\x05\x12\x04\x9c\x11\x02\x08\n\r\
    \n\x05\x04,\x02\x04\x01\x12\x04\x9c\x11\t\r\n\r\n\x05\x04,\x02\x04\x03\
    \x12\x04\x9c\x11\x10\x11\n\x97\x03\n\x02\x04-\x12\x06\xa5\x11\0\xf3\x11\
    \x01\x1a\x88\x03\x20NodePool\x20contains\x20the\x20name\x20and\x20config\
    uration\x20for\x20a\x20cluster's\x20node\x20pool.\n\x20Node\x20pools\x20\
    are\x20a\x20set\x20of\x20nodes\x20(i.e.\x20VM's),\x20with\x20a\x20common\
    \x20configuration\x20and\n\x20specification,\x20under\x20the\x20control\
    \x20of\x20the\x20cluster\x20master.\x20They\x20may\x20have\x20a\x20set\n\
    \x20of\x20Kubernetes\x20labels\x20applied\x20to\x20them,\x20which\x20may\
    \x20be\x20used\x20to\x20reference\x20them\n\x20during\x20pod\x20scheduli\
    ng.\x20They\x20may\x20also\x20be\x20resized\x20up\x20or\x20down,\x20to\
    \x20accommodate\n\x20the\x20workload.\n\n\x0b\n\x03\x04-\x01\x12\x04\xa5\
    \x11\x08\x10\n?\n\x04\x04-\x04\0\x12\x06\xa7\x11\x02\xc3\x11\x03\x1a/\
    \x20The\x20current\x20status\x20of\x20the\x20node\x20pool\x20instance.\n\
    \n\r\n\x05\x04-\x04\0\x01\x12\x04\xa7\x11\x07\r\n\x1a\n\x06\x04-\x04\0\
    \x02\0\x12\x04\xa9\x11\x04\x1b\x1a\n\x20Not\x20set.\n\n\x0f\n\x07\x04-\
    \x04\0\x02\0\x01\x12\x04\xa9\x11\x04\x16\n\x0f\n\x07\x04-\x04\0\x02\0\
    \x02\x12\x04\xa9\x11\x19\x1a\nR\n\x06\x04-\x04\0\x02\x01\x12\x04\xac\x11\
    \x04\x15\x1aB\x20The\x20PROVISIONING\x20state\x20indicates\x20the\x20nod\
    e\x20pool\x20is\x20being\x20created.\n\n\x0f\n\x07\x04-\x04\0\x02\x01\
    \x01\x12\x04\xac\x11\x04\x10\n\x0f\n\x07\x04-\x04\0\x02\x01\x02\x12\x04\
    \xac\x11\x13\x14\nb\n\x06\x04-\x04\0\x02\x02\x12\x04\xb0\x11\x04\x10\x1a\
    R\x20The\x20RUNNING\x20state\x20indicates\x20the\x20node\x20pool\x20has\
    \x20been\x20created\n\x20and\x20is\x20fully\x20usable.\n\n\x0f\n\x07\x04\
    -\x04\0\x02\x02\x01\x12\x04\xb0\x11\x04\x0b\n\x0f\n\x07\x04-\x04\0\x02\
    \x02\x02\x12\x04\xb0\x11\x0e\x0f\n\xfa\x01\n\x06\x04-\x04\0\x02\x03\x12\
    \x04\xb6\x11\x04\x1b\x1a\xe9\x01\x20The\x20RUNNING_WITH_ERROR\x20state\
    \x20indicates\x20the\x20node\x20pool\x20has\x20been\x20created\n\x20and\
    \x20is\x20partially\x20usable.\x20Some\x20error\x20state\x20has\x20occur\
    red\x20and\x20some\n\x20functionality\x20may\x20be\x20impaired.\x20Custo\
    mer\x20may\x20need\x20to\x20reissue\x20a\x20request\n\x20or\x20trigger\
    \x20a\x20new\x20update.\n\n\x0f\n\x07\x04-\x04\0\x02\x03\x01\x12\x04\xb6\
    \x11\x04\x16\n\x0f\n\x07\x04-\x04\0\x02\x03\x02\x12\x04\xb6\x11\x19\x1a\
    \n\xc0\x01\n\x06\x04-\x04\0\x02\x04\x12\x04\xbb\x11\x04\x14\x1a\xaf\x01\
    \x20The\x20RECONCILING\x20state\x20indicates\x20that\x20some\x20work\x20\
    is\x20actively\x20being\x20done\x20on\n\x20the\x20node\x20pool,\x20such\
    \x20as\x20upgrading\x20node\x20software.\x20Details\x20can\n\x20be\x20fo\
    und\x20in\x20the\x20`statusMessage`\x20field.\n\n\x0f\n\x07\x04-\x04\0\
    \x02\x04\x01\x12\x04\xbb\x11\x04\x0f\n\x0f\n\x07\x04-\x04\0\x02\x04\x02\
    \x12\x04\xbb\x11\x12\x13\nN\n\x06\x04-\x04\0\x02\x05\x12\x04\xbe\x11\x04\
    \x11\x1a>\x20The\x20STOPPING\x20state\x20indicates\x20the\x20node\x20poo\
    l\x20is\x20being\x20deleted.\n\n\x0f\n\x07\x04-\x04\0\x02\x05\x01\x12\
    \x04\xbe\x11\x04\x0c\n\x0f\n\x07\x04-\x04\0\x02\x05\x02\x12\x04\xbe\x11\
    \x0f\x10\n~\n\x06\x04-\x04\0\x02\x06\x12\x04\xc2\x11\x04\x0e\x1an\x20The\
    \x20ERROR\x20state\x20indicates\x20the\x20node\x20pool\x20may\x20be\x20u\
    nusable.\x20Details\n\x20can\x20be\x20found\x20in\x20the\x20`statusMessa\
    ge`\x20field.\n\n\x0f\n\x07\x04-\x04\0\x02\x06\x01\x12\x04\xc2\x11\x04\t\
    \n\x0f\n\x07\x04-\x04\0\x02\x06\x02\x12\x04\xc2\x11\x0c\r\n*\n\x04\x04-\
    \x02\0\x12\x04\xc6\x11\x02\x12\x1a\x1c\x20The\x20name\x20of\x20the\x20no\
    de\x20pool.\n\n\r\n\x05\x04-\x02\0\x05\x12\x04\xc6\x11\x02\x08\n\r\n\x05\
    \x04-\x02\0\x01\x12\x04\xc6\x11\t\r\n\r\n\x05\x04-\x02\0\x03\x12\x04\xc6\
    \x11\x10\x11\n3\n\x04\x04-\x02\x01\x12\x04\xc9\x11\x02\x18\x1a%\x20The\
    \x20node\x20configuration\x20of\x20the\x20pool.\n\n\r\n\x05\x04-\x02\x01\
    \x06\x12\x04\xc9\x11\x02\x0c\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xc9\x11\
    \r\x13\n\r\n\x05\x04-\x02\x01\x03\x12\x04\xc9\x11\x16\x17\n\x80\x02\n\
    \x04\x04-\x02\x02\x12\x04\xcf\x11\x02\x1f\x1a\xf1\x01\x20The\x20initial\
    \x20node\x20count\x20for\x20the\x20pool.\x20You\x20must\x20ensure\x20tha\
    t\x20your\n\x20Compute\x20Engine\x20<a\x20href=\"/compute/docs/resource-\
    quotas\">resource\x20quota</a>\n\x20is\x20sufficient\x20for\x20this\x20n\
    umber\x20of\x20instances.\x20You\x20must\x20also\x20have\x20available\n\
    \x20firewall\x20and\x20routes\x20quota.\n\n\r\n\x05\x04-\x02\x02\x05\x12\
    \x04\xcf\x11\x02\x07\n\r\n\x05\x04-\x02\x02\x01\x12\x04\xcf\x11\x08\x1a\
    \n\r\n\x05\x04-\x02\x02\x03\x12\x04\xcf\x11\x1d\x1e\nB\n\x04\x04-\x02\
    \x03\x12\x04\xd2\x11\x02\x19\x1a4\x20[Output\x20only]\x20Server-defined\
    \x20URL\x20for\x20the\x20resource.\n\n\r\n\x05\x04-\x02\x03\x05\x12\x04\
    \xd2\x11\x02\x08\n\r\n\x05\x04-\x02\x03\x01\x12\x04\xd2\x11\t\x12\n\r\n\
    \x05\x04-\x02\x03\x03\x12\x04\xd2\x11\x15\x18\n;\n\x04\x04-\x02\x04\x12\
    \x04\xd5\x11\x02\x17\x1a-\x20The\x20version\x20of\x20the\x20Kubernetes\
    \x20of\x20this\x20node.\n\n\r\n\x05\x04-\x02\x04\x05\x12\x04\xd5\x11\x02\
    \x08\n\r\n\x05\x04-\x02\x04\x01\x12\x04\xd5\x11\t\x10\n\r\n\x05\x04-\x02\
    \x04\x03\x12\x04\xd5\x11\x13\x16\n\xb7\x01\n\x04\x04-\x02\x05\x12\x04\
    \xda\x11\x02,\x1a\xa8\x01\x20[Output\x20only]\x20The\x20resource\x20URLs\
    \x20of\x20the\x20[managed\x20instance\n\x20groups](/compute/docs/instanc\
    e-groups/creating-groups-of-managed-instances)\n\x20associated\x20with\
    \x20this\x20node\x20pool.\n\n\r\n\x05\x04-\x02\x05\x04\x12\x04\xda\x11\
    \x02\n\n\r\n\x05\x04-\x02\x05\x05\x12\x04\xda\x11\x0b\x11\n\r\n\x05\x04-\
    \x02\x05\x01\x12\x04\xda\x11\x12%\n\r\n\x05\x04-\x02\x05\x03\x12\x04\xda\
    \x11(+\nL\n\x04\x04-\x02\x06\x12\x04\xdd\x11\x02\x16\x1a>\x20[Output\x20\
    only]\x20The\x20status\x20of\x20the\x20nodes\x20in\x20this\x20pool\x20in\
    stance.\n\n\r\n\x05\x04-\x02\x06\x06\x12\x04\xdd\x11\x02\x08\n\r\n\x05\
    \x04-\x02\x06\x01\x12\x04\xdd\x11\t\x0f\n\r\n\x05\x04-\x02\x06\x03\x12\
    \x04\xdd\x11\x12\x15\nx\n\x04\x04-\x02\x07\x12\x04\xe1\x11\x02\x1e\x1aj\
    \x20[Output\x20only]\x20Additional\x20information\x20about\x20the\x20cur\
    rent\x20status\x20of\x20this\n\x20node\x20pool\x20instance,\x20if\x20ava\
    ilable.\n\n\r\n\x05\x04-\x02\x07\x05\x12\x04\xe1\x11\x02\x08\n\r\n\x05\
    \x04-\x02\x07\x01\x12\x04\xe1\x11\t\x17\n\r\n\x05\x04-\x02\x07\x03\x12\
    \x04\xe1\x11\x1a\x1d\n|\n\x04\x04-\x02\x08\x12\x04\xe5\x11\x02&\x1an\x20\
    Autoscaler\x20configuration\x20for\x20this\x20NodePool.\x20Autoscaler\
    \x20is\x20enabled\n\x20only\x20if\x20a\x20valid\x20configuration\x20is\
    \x20present.\n\n\r\n\x05\x04-\x02\x08\x06\x12\x04\xe5\x11\x02\x15\n\r\n\
    \x05\x04-\x02\x08\x01\x12\x04\xe5\x11\x16!\n\r\n\x05\x04-\x02\x08\x03\
    \x12\x04\xe5\x11$%\n?\n\x04\x04-\x02\t\x12\x04\xe8\x11\x02\x20\x1a1\x20N\
    odeManagement\x20configuration\x20for\x20this\x20NodePool.\n\n\r\n\x05\
    \x04-\x02\t\x06\x12\x04\xe8\x11\x02\x10\n\r\n\x05\x04-\x02\t\x01\x12\x04\
    \xe8\x11\x11\x1b\n\r\n\x05\x04-\x02\t\x03\x12\x04\xe8\x11\x1e\x1f\nx\n\
    \x04\x04-\x02\n\x12\x04\xec\x11\x02,\x1aj\x20The\x20constraint\x20on\x20\
    the\x20maximum\x20number\x20of\x20pods\x20that\x20can\x20be\x20run\n\x20\
    simultaneously\x20on\x20a\x20node\x20in\x20the\x20node\x20pool.\n\n\r\n\
    \x05\x04-\x02\n\x06\x12\x04\xec\x11\x02\x13\n\r\n\x05\x04-\x02\n\x01\x12\
    \x04\xec\x11\x14'\n\r\n\x05\x04-\x02\n\x03\x12\x04\xec\x11*+\nD\n\x04\
    \x04-\x02\x0b\x12\x04\xef\x11\x02,\x1a6\x20Which\x20conditions\x20caused\
    \x20the\x20current\x20node\x20pool\x20state.\n\n\r\n\x05\x04-\x02\x0b\
    \x04\x12\x04\xef\x11\x02\n\n\r\n\x05\x04-\x02\x0b\x06\x12\x04\xef\x11\
    \x0b\x1a\n\r\n\x05\x04-\x02\x0b\x01\x12\x04\xef\x11\x1b%\n\r\n\x05\x04-\
    \x02\x0b\x03\x12\x04\xef\x11(+\nQ\n\x04\x04-\x02\x0c\x12\x04\xf2\x11\x02\
    \x1f\x1aC\x20[Output\x20only]\x20The\x20pod\x20CIDR\x20block\x20size\x20\
    per\x20node\x20in\x20this\x20node\x20pool.\n\n\r\n\x05\x04-\x02\x0c\x05\
    \x12\x04\xf2\x11\x02\x07\n\r\n\x05\x04-\x02\x0c\x01\x12\x04\xf2\x11\x08\
    \x1a\n\r\n\x05\x04-\x02\x0c\x03\x12\x04\xf2\x11\x1d\x1e\nh\n\x02\x04.\
    \x12\x06\xf7\x11\0\x85\x12\x01\x1aZ\x20NodeManagement\x20defines\x20the\
    \x20set\x20of\x20node\x20management\x20services\x20turned\x20on\x20for\
    \x20the\n\x20node\x20pool.\n\n\x0b\n\x03\x04.\x01\x12\x04\xf7\x11\x08\
    \x16\n\xdf\x01\n\x04\x04.\x02\0\x12\x04\xfb\x11\x02\x18\x1a\xd0\x01\x20A\
    \x20flag\x20that\x20specifies\x20whether\x20node\x20auto-upgrade\x20is\
    \x20enabled\x20for\x20the\x20node\n\x20pool.\x20If\x20enabled,\x20node\
    \x20auto-upgrade\x20helps\x20keep\x20the\x20nodes\x20in\x20your\x20node\
    \x20pool\n\x20up\x20to\x20date\x20with\x20the\x20latest\x20release\x20ve\
    rsion\x20of\x20Kubernetes.\n\n\r\n\x05\x04.\x02\0\x05\x12\x04\xfb\x11\
    \x02\x06\n\r\n\x05\x04.\x02\0\x01\x12\x04\xfb\x11\x07\x13\n\r\n\x05\x04.\
    \x02\0\x03\x12\x04\xfb\x11\x16\x17\n\xfc\x01\n\x04\x04.\x02\x01\x12\x04\
    \x81\x12\x02\x17\x1a\xed\x01\x20A\x20flag\x20that\x20specifies\x20whethe\
    r\x20the\x20node\x20auto-repair\x20is\x20enabled\x20for\x20the\x20node\n\
    \x20pool.\x20If\x20enabled,\x20the\x20nodes\x20in\x20this\x20node\x20poo\
    l\x20will\x20be\x20monitored\x20and,\x20if\n\x20they\x20fail\x20health\
    \x20checks\x20too\x20many\x20times,\x20an\x20automatic\x20repair\x20acti\
    on\x20will\x20be\n\x20triggered.\n\n\r\n\x05\x04.\x02\x01\x05\x12\x04\
    \x81\x12\x02\x06\n\r\n\x05\x04.\x02\x01\x01\x12\x04\x81\x12\x07\x12\n\r\
    \n\x05\x04.\x02\x01\x03\x12\x04\x81\x12\x15\x16\nC\n\x04\x04.\x02\x02\
    \x12\x04\x84\x12\x02*\x1a5\x20Specifies\x20the\x20Auto\x20Upgrade\x20kno\
    bs\x20for\x20the\x20node\x20pool.\n\n\r\n\x05\x04.\x02\x02\x06\x12\x04\
    \x84\x12\x02\x14\n\r\n\x05\x04.\x02\x02\x01\x12\x04\x84\x12\x15$\n\r\n\
    \x05\x04.\x02\x02\x03\x12\x04\x84\x12')\nz\n\x02\x04/\x12\x06\x89\x12\0\
    \x92\x12\x01\x1al\x20AutoUpgradeOptions\x20defines\x20the\x20set\x20of\
    \x20options\x20for\x20the\x20user\x20to\x20control\x20how\n\x20the\x20Au\
    to\x20Upgrades\x20will\x20proceed.\n\n\x0b\n\x03\x04/\x01\x12\x04\x89\
    \x12\x08\x1a\n\xc8\x01\n\x04\x04/\x02\0\x12\x04\x8d\x12\x02%\x1a\xb9\x01\
    \x20[Output\x20only]\x20This\x20field\x20is\x20set\x20when\x20upgrades\
    \x20are\x20about\x20to\x20commence\n\x20with\x20the\x20approximate\x20st\
    art\x20time\x20for\x20the\x20upgrades,\x20in\n\x20[RFC3339](https://www.\
    ietf.org/rfc/rfc3339.txt)\x20text\x20format.\n\n\r\n\x05\x04/\x02\0\x05\
    \x12\x04\x8d\x12\x02\x08\n\r\n\x05\x04/\x02\0\x01\x12\x04\x8d\x12\t\x20\
    \n\r\n\x05\x04/\x02\0\x03\x12\x04\x8d\x12#$\ny\n\x04\x04/\x02\x01\x12\
    \x04\x91\x12\x02\x19\x1ak\x20[Output\x20only]\x20This\x20field\x20is\x20\
    set\x20when\x20upgrades\x20are\x20about\x20to\x20commence\n\x20with\x20t\
    he\x20description\x20of\x20the\x20upgrade.\n\n\r\n\x05\x04/\x02\x01\x05\
    \x12\x04\x91\x12\x02\x08\n\r\n\x05\x04/\x02\x01\x01\x12\x04\x91\x12\t\
    \x14\n\r\n\x05\x04/\x02\x01\x03\x12\x04\x91\x12\x17\x18\n\\\n\x02\x040\
    \x12\x06\x95\x12\0\x9f\x12\x01\x1aN\x20MaintenancePolicy\x20defines\x20t\
    he\x20maintenance\x20policy\x20to\x20be\x20used\x20for\x20the\x20cluster\
    .\n\n\x0b\n\x03\x040\x01\x12\x04\x95\x12\x08\x19\nW\n\x04\x040\x02\0\x12\
    \x04\x97\x12\x02\x1f\x1aI\x20Specifies\x20the\x20maintenance\x20window\
    \x20in\x20which\x20maintenance\x20may\x20be\x20performed.\n\n\r\n\x05\
    \x040\x02\0\x06\x12\x04\x97\x12\x02\x13\n\r\n\x05\x040\x02\0\x01\x12\x04\
    \x97\x12\x14\x1a\n\r\n\x05\x040\x02\0\x03\x12\x04\x97\x12\x1d\x1e\n\xfb\
    \x02\n\x04\x040\x02\x01\x12\x04\x9e\x12\x02\x1e\x1a\xec\x02\x20A\x20hash\
    \x20identifying\x20the\x20version\x20of\x20this\x20policy,\x20so\x20that\
    \x20updates\x20to\x20fields\x20of\n\x20the\x20policy\x20won't\x20acciden\
    tally\x20undo\x20intermediate\x20changes\x20(and\x20so\x20that\x20users\
    \n\x20of\x20the\x20API\x20unaware\x20of\x20some\x20fields\x20won't\x20ac\
    cidentally\x20remove\x20other\x20fields).\n\x20Make\x20a\x20<code>get()<\
    /code>\x20request\x20to\x20the\x20cluster\x20to\x20get\x20the\x20current\
    \n\x20resource\x20version\x20and\x20include\x20it\x20with\x20requests\
    \x20to\x20set\x20the\x20policy.\n\n\r\n\x05\x040\x02\x01\x05\x12\x04\x9e\
    \x12\x02\x08\n\r\n\x05\x040\x02\x01\x01\x12\x04\x9e\x12\t\x19\n\r\n\x05\
    \x040\x02\x01\x03\x12\x04\x9e\x12\x1c\x1d\n\\\n\x02\x041\x12\x06\xa2\x12\
    \0\xb0\x12\x01\x1aN\x20MaintenanceWindow\x20defines\x20the\x20maintenanc\
    e\x20window\x20to\x20be\x20used\x20for\x20the\x20cluster.\n\n\x0b\n\x03\
    \x041\x01\x12\x04\xa2\x12\x08\x19\n\x0e\n\x04\x041\x08\0\x12\x06\xa3\x12\
    \x02\xab\x12\x03\n\r\n\x05\x041\x08\0\x01\x12\x04\xa3\x12\x08\x0e\nV\n\
    \x04\x041\x02\0\x12\x04\xa5\x12\x048\x1aH\x20DailyMaintenanceWindow\x20s\
    pecifies\x20a\x20daily\x20maintenance\x20operation\x20window.\n\n\r\n\
    \x05\x041\x02\0\x06\x12\x04\xa5\x12\x04\x1a\n\r\n\x05\x041\x02\0\x01\x12\
    \x04\xa5\x12\x1b3\n\r\n\x05\x041\x02\0\x03\x12\x04\xa5\x1267\n\xd7\x01\n\
    \x04\x041\x02\x01\x12\x04\xaa\x12\x04-\x1a\xc8\x01\x20RecurringWindow\
    \x20specifies\x20some\x20number\x20of\x20recurring\x20time\x20periods\
    \x20for\n\x20maintenance\x20to\x20occur.\x20The\x20time\x20windows\x20ma\
    y\x20be\x20overlapping.\x20If\x20no\n\x20maintenance\x20windows\x20are\
    \x20set,\x20maintenance\x20can\x20occur\x20at\x20any\x20time.\n\n\r\n\
    \x05\x041\x02\x01\x06\x12\x04\xaa\x12\x04\x17\n\r\n\x05\x041\x02\x01\x01\
    \x12\x04\xaa\x12\x18(\n\r\n\x05\x041\x02\x01\x03\x12\x04\xaa\x12+,\no\n\
    \x04\x041\x02\x02\x12\x04\xaf\x12\x025\x1aa\x20Exceptions\x20to\x20maint\
    enance\x20window.\x20Non-emergency\x20maintenance\x20should\x20not\n\x20\
    occur\x20in\x20these\x20windows.\n\n\r\n\x05\x041\x02\x02\x06\x12\x04\
    \xaf\x12\x02\x19\n\r\n\x05\x041\x02\x02\x01\x12\x04\xaf\x12\x1a0\n\r\n\
    \x05\x041\x02\x02\x03\x12\x04\xaf\x1234\n7\n\x02\x042\x12\x06\xb3\x12\0\
    \xba\x12\x01\x1a)\x20Represents\x20an\x20arbitrary\x20window\x20of\x20ti\
    me.\n\n\x0b\n\x03\x042\x01\x12\x04\xb3\x12\x08\x12\n6\n\x04\x042\x02\0\
    \x12\x04\xb5\x12\x02+\x1a(\x20The\x20time\x20that\x20the\x20window\x20fi\
    rst\x20starts.\n\n\r\n\x05\x042\x02\0\x06\x12\x04\xb5\x12\x02\x1b\n\r\n\
    \x05\x042\x02\0\x01\x12\x04\xb5\x12\x1c&\n\r\n\x05\x042\x02\0\x03\x12\
    \x04\xb5\x12)*\nd\n\x04\x042\x02\x01\x12\x04\xb9\x12\x02)\x1aV\x20The\
    \x20time\x20that\x20the\x20window\x20ends.\x20The\x20end\x20time\x20shou\
    ld\x20take\x20place\x20after\x20the\n\x20start\x20time.\n\n\r\n\x05\x042\
    \x02\x01\x06\x12\x04\xb9\x12\x02\x1b\n\r\n\x05\x042\x02\x01\x01\x12\x04\
    \xb9\x12\x1c$\n\r\n\x05\x042\x02\x01\x03\x12\x04\xb9\x12'(\nC\n\x02\x043\
    \x12\x06\xbd\x12\0\xdd\x12\x01\x1a5\x20Represents\x20an\x20arbitrary\x20\
    window\x20of\x20time\x20that\x20recurs.\n\n\x0b\n\x03\x043\x01\x12\x04\
    \xbd\x12\x08\x1b\n3\n\x04\x043\x02\0\x12\x04\xbf\x12\x02\x18\x1a%\x20The\
    \x20window\x20of\x20the\x20first\x20recurrence.\n\n\r\n\x05\x043\x02\0\
    \x06\x12\x04\xbf\x12\x02\x0c\n\r\n\x05\x043\x02\0\x01\x12\x04\xbf\x12\r\
    \x13\n\r\n\x05\x043\x02\0\x03\x12\x04\xbf\x12\x16\x17\n\xd3\t\n\x04\x043\
    \x02\x01\x12\x04\xdc\x12\x02\x18\x1a\xc4\t\x20An\x20RRULE\x20(https://to\
    ols.ietf.org/html/rfc5545#section-3.8.5.3)\x20for\x20how\n\x20this\x20wi\
    ndow\x20reccurs.\x20They\x20go\x20on\x20for\x20the\x20span\x20of\x20time\
    \x20between\x20the\x20start\x20and\n\x20end\x20time.\n\n\x20For\x20examp\
    le,\x20to\x20have\x20something\x20repeat\x20every\x20weekday,\x20you'd\
    \x20use:\n\x20\x20\x20<code>FREQ=WEEKLY;BYDAY=MO,TU,WE,TH,FR</code>\n\
    \x20To\x20repeat\x20some\x20window\x20daily\x20(equivalent\x20to\x20the\
    \x20DailyMaintenanceWindow):\n\x20\x20\x20<code>FREQ=DAILY</code>\n\x20F\
    or\x20the\x20first\x20weekend\x20of\x20every\x20month:\n\x20\x20\x20<cod\
    e>FREQ=MONTHLY;BYSETPOS=1;BYDAY=SA,SU</code>\n\x20This\x20specifies\x20h\
    ow\x20frequently\x20the\x20window\x20starts.\x20Eg,\x20if\x20you\x20want\
    ed\x20to\x20have\n\x20a\x209-5\x20UTC-4\x20window\x20every\x20weekday,\
    \x20you'd\x20use\x20something\x20like:\n\x20<code>\n\x20\x20\x20start\
    \x20time\x20=\x202019-01-01T09:00:00-0400\n\x20\x20\x20end\x20time\x20=\
    \x202019-01-01T17:00:00-0400\n\x20\x20\x20recurrence\x20=\x20FREQ=WEEKLY\
    ;BYDAY=MO,TU,WE,TH,FR\n\x20</code>\n\x20Windows\x20can\x20span\x20multip\
    le\x20days.\x20Eg,\x20to\x20make\x20the\x20window\x20encompass\x20every\
    \n\x20weekend\x20from\x20midnight\x20Saturday\x20till\x20the\x20last\x20\
    minute\x20of\x20Sunday\x20UTC:\n\x20<code>\n\x20\x20\x20start\x20time\
    \x20=\x202019-01-05T00:00:00Z\n\x20\x20\x20end\x20time\x20=\x202019-01-0\
    7T23:59:00Z\n\x20\x20\x20recurrence\x20=\x20FREQ=WEEKLY;BYDAY=SA\n\x20</\
    code>\n\x20Note\x20the\x20start\x20and\x20end\x20time's\x20specific\x20d\
    ates\x20are\x20largely\x20arbitrary\x20except\n\x20to\x20specify\x20dura\
    tion\x20of\x20the\x20window\x20and\x20when\x20it\x20first\x20starts.\n\
    \x20The\x20FREQ\x20values\x20of\x20HOURLY,\x20MINUTELY,\x20and\x20SECOND\
    LY\x20are\x20not\x20supported.\n\n\r\n\x05\x043\x02\x01\x05\x12\x04\xdc\
    \x12\x02\x08\n\r\n\x05\x043\x02\x01\x01\x12\x04\xdc\x12\t\x13\n\r\n\x05\
    \x043\x02\x01\x03\x12\x04\xdc\x12\x16\x17\nG\n\x02\x044\x12\x06\xe0\x12\
    \0\xeb\x12\x01\x1a9\x20Time\x20window\x20specified\x20for\x20daily\x20ma\
    intenance\x20operations.\n\n\x0b\n\x03\x044\x01\x12\x04\xe0\x12\x08\x1e\
    \n\xdc\x01\n\x04\x044\x02\0\x12\x04\xe4\x12\x02\x18\x1a\xcd\x01\x20Time\
    \x20within\x20the\x20maintenance\x20window\x20to\x20start\x20the\x20main\
    tenance\x20operations.\n\x20Time\x20format\x20should\x20be\x20in\x20[RFC\
    3339](https://www.ietf.org/rfc/rfc3339.txt)\n\x20format\x20\"HH:MM\",\
    \x20where\x20HH\x20:\x20[00-23]\x20and\x20MM\x20:\x20[00-59]\x20GMT.\n\n\
    \r\n\x05\x044\x02\0\x05\x12\x04\xe4\x12\x02\x08\n\r\n\x05\x044\x02\0\x01\
    \x12\x04\xe4\x12\t\x13\n\r\n\x05\x044\x02\0\x03\x12\x04\xe4\x12\x16\x17\
    \n\xd9\x01\n\x04\x044\x02\x01\x12\x04\xea\x12\x02\x16\x1a\xca\x01\x20[Ou\
    tput\x20only]\x20Duration\x20of\x20the\x20time\x20window,\x20automatical\
    ly\x20chosen\x20to\x20be\n\x20smallest\x20possible\x20in\x20the\x20given\
    \x20scenario.\n\x20Duration\x20will\x20be\x20in\x20[RFC3339](https://www\
    .ietf.org/rfc/rfc3339.txt)\n\x20format\x20\"PTnHnMnS\".\n\n\r\n\x05\x044\
    \x02\x01\x05\x12\x04\xea\x12\x02\x08\n\r\n\x05\x044\x02\x01\x01\x12\x04\
    \xea\x12\t\x11\n\r\n\x05\x044\x02\x01\x03\x12\x04\xea\x12\x14\x15\na\n\
    \x02\x045\x12\x06\xef\x12\0\x96\x13\x01\x1aS\x20SetNodePoolManagementReq\
    uest\x20sets\x20the\x20node\x20management\x20properties\x20of\x20a\x20no\
    de\n\x20pool.\n\n\x0b\n\x03\x045\x01\x12\x04\xef\x12\x08$\n\xd8\x01\n\
    \x04\x045\x02\0\x12\x06\xf3\x12\x02\xf6\x12\x04\x1a\xc7\x01\x20Required.\
    \x20Deprecated.\x20The\x20Google\x20Developers\x20Console\x20[project\
    \x20ID\x20or\x20project\n\x20number](https://support.google.com/cloud/an\
    swer/6158840).\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\
    \x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x045\x02\0\x05\
    \x12\x04\xf3\x12\x02\x08\n\r\n\x05\x045\x02\0\x01\x12\x04\xf3\x12\t\x13\
    \n\r\n\x05\x045\x02\0\x03\x12\x04\xf3\x12\x16\x17\n\x0f\n\x05\x045\x02\0\
    \x08\x12\x06\xf3\x12\x18\xf6\x12\x03\n\x0e\n\x06\x045\x02\0\x08\x03\x12\
    \x04\xf4\x12\x04\x15\n\x10\n\x08\x045\x02\0\x08\x9c\x08\0\x12\x04\xf5\
    \x12\x04*\n\xd4\x01\n\x04\x045\x02\x01\x12\x06\xfc\x12\x02\xff\x12\x04\
    \x1a\xc3\x01\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20\
    Google\x20Compute\x20Engine\n\x20[zone](/compute/docs/zones#available)\
    \x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20This\x20field\x20ha\
    s\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field\
    .\n\n\r\n\x05\x045\x02\x01\x05\x12\x04\xfc\x12\x02\x08\n\r\n\x05\x045\
    \x02\x01\x01\x12\x04\xfc\x12\t\r\n\r\n\x05\x045\x02\x01\x03\x12\x04\xfc\
    \x12\x10\x11\n\x0f\n\x05\x045\x02\x01\x08\x12\x06\xfc\x12\x12\xff\x12\
    \x03\n\x0e\n\x06\x045\x02\x01\x08\x03\x12\x04\xfd\x12\x04\x15\n\x10\n\
    \x08\x045\x02\x01\x08\x9c\x08\0\x12\x04\xfe\x12\x04*\n\x8a\x01\n\x04\x04\
    5\x02\x02\x12\x06\x83\x13\x02\x86\x13\x04\x1az\x20Required.\x20Deprecate\
    d.\x20The\x20name\x20of\x20the\x20cluster\x20to\x20update.\n\x20This\x20\
    field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20na\
    me\x20field.\n\n\r\n\x05\x045\x02\x02\x05\x12\x04\x83\x13\x02\x08\n\r\n\
    \x05\x045\x02\x02\x01\x12\x04\x83\x13\t\x13\n\r\n\x05\x045\x02\x02\x03\
    \x12\x04\x83\x13\x16\x17\n\x0f\n\x05\x045\x02\x02\x08\x12\x06\x83\x13\
    \x18\x86\x13\x03\n\x0e\n\x06\x045\x02\x02\x08\x03\x12\x04\x84\x13\x04\
    \x15\n\x10\n\x08\x045\x02\x02\x08\x9c\x08\0\x12\x04\x85\x13\x04*\n\x8c\
    \x01\n\x04\x045\x02\x03\x12\x06\x8a\x13\x02\x8d\x13\x04\x1a|\x20Required\
    .\x20Deprecated.\x20The\x20name\x20of\x20the\x20node\x20pool\x20to\x20up\
    date.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\
    \x20by\x20the\x20name\x20field.\n\n\r\n\x05\x045\x02\x03\x05\x12\x04\x8a\
    \x13\x02\x08\n\r\n\x05\x045\x02\x03\x01\x12\x04\x8a\x13\t\x15\n\r\n\x05\
    \x045\x02\x03\x03\x12\x04\x8a\x13\x18\x19\n\x0f\n\x05\x045\x02\x03\x08\
    \x12\x06\x8a\x13\x1a\x8d\x13\x03\n\x0e\n\x06\x045\x02\x03\x08\x03\x12\
    \x04\x8b\x13\x04\x15\n\x10\n\x08\x045\x02\x03\x08\x9c\x08\0\x12\x04\x8c\
    \x13\x04*\nI\n\x04\x045\x02\x04\x12\x04\x90\x13\x02I\x1a;\x20Required.\
    \x20NodeManagement\x20configuration\x20for\x20the\x20node\x20pool.\n\n\r\
    \n\x05\x045\x02\x04\x06\x12\x04\x90\x13\x02\x10\n\r\n\x05\x045\x02\x04\
    \x01\x12\x04\x90\x13\x11\x1b\n\r\n\x05\x045\x02\x04\x03\x12\x04\x90\x13\
    \x1e\x1f\n\r\n\x05\x045\x02\x04\x08\x12\x04\x90\x13\x20H\n\x10\n\x08\x04\
    5\x02\x04\x08\x9c\x08\0\x12\x04\x90\x13!G\n\xbe\x01\n\x04\x045\x02\x05\
    \x12\x04\x95\x13\x02\x12\x1a\xaf\x01\x20The\x20name\x20(project,\x20loca\
    tion,\x20cluster,\x20node\x20pool\x20id)\x20of\x20the\x20node\x20pool\
    \x20to\x20set\n\x20management\x20properties.\x20Specified\x20in\x20the\
    \x20format\n\x20'projects/*/locations/*/clusters/*/nodePools/*'.\n\n\r\n\
    \x05\x045\x02\x05\x05\x12\x04\x95\x13\x02\x08\n\r\n\x05\x045\x02\x05\x01\
    \x12\x04\x95\x13\t\r\n\r\n\x05\x045\x02\x05\x03\x12\x04\x95\x13\x10\x11\
    \nB\n\x02\x046\x12\x06\x9a\x13\0\xc1\x13\x01\x1a4\x20SetNodePoolSizeRequ\
    est\x20sets\x20the\x20size\x20a\x20node\n\x20pool.\n\n\x0b\n\x03\x046\
    \x01\x12\x04\x9a\x13\x08\x1e\n\xd8\x01\n\x04\x046\x02\0\x12\x06\x9e\x13\
    \x02\xa1\x13\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20Googl\
    e\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\n\x20numbe\
    r](https://support.google.com/cloud/answer/6158840).\n\x20This\x20field\
    \x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\
    \x20field.\n\n\r\n\x05\x046\x02\0\x05\x12\x04\x9e\x13\x02\x08\n\r\n\x05\
    \x046\x02\0\x01\x12\x04\x9e\x13\t\x13\n\r\n\x05\x046\x02\0\x03\x12\x04\
    \x9e\x13\x16\x17\n\x0f\n\x05\x046\x02\0\x08\x12\x06\x9e\x13\x18\xa1\x13\
    \x03\n\x0e\n\x06\x046\x02\0\x08\x03\x12\x04\x9f\x13\x04\x15\n\x10\n\x08\
    \x046\x02\0\x08\x9c\x08\0\x12\x04\xa0\x13\x04*\n\xd4\x01\n\x04\x046\x02\
    \x01\x12\x06\xa7\x13\x02\xaa\x13\x04\x1a\xc3\x01\x20Required.\x20Depreca\
    ted.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zo\
    ne](/compute/docs/zones#available)\x20in\x20which\x20the\x20cluster\n\
    \x20resides.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20r\
    eplaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x046\x02\x01\x05\x12\
    \x04\xa7\x13\x02\x08\n\r\n\x05\x046\x02\x01\x01\x12\x04\xa7\x13\t\r\n\r\
    \n\x05\x046\x02\x01\x03\x12\x04\xa7\x13\x10\x11\n\x0f\n\x05\x046\x02\x01\
    \x08\x12\x06\xa7\x13\x12\xaa\x13\x03\n\x0e\n\x06\x046\x02\x01\x08\x03\
    \x12\x04\xa8\x13\x04\x15\n\x10\n\x08\x046\x02\x01\x08\x9c\x08\0\x12\x04\
    \xa9\x13\x04*\n\x8a\x01\n\x04\x046\x02\x02\x12\x06\xae\x13\x02\xb1\x13\
    \x04\x1az\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20clu\
    ster\x20to\x20update.\n\x20This\x20field\x20has\x20been\x20deprecated\
    \x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x046\x02\
    \x02\x05\x12\x04\xae\x13\x02\x08\n\r\n\x05\x046\x02\x02\x01\x12\x04\xae\
    \x13\t\x13\n\r\n\x05\x046\x02\x02\x03\x12\x04\xae\x13\x16\x17\n\x0f\n\
    \x05\x046\x02\x02\x08\x12\x06\xae\x13\x18\xb1\x13\x03\n\x0e\n\x06\x046\
    \x02\x02\x08\x03\x12\x04\xaf\x13\x04\x15\n\x10\n\x08\x046\x02\x02\x08\
    \x9c\x08\0\x12\x04\xb0\x13\x04*\n\x8c\x01\n\x04\x046\x02\x03\x12\x06\xb5\
    \x13\x02\xb8\x13\x04\x1a|\x20Required.\x20Deprecated.\x20The\x20name\x20\
    of\x20the\x20node\x20pool\x20to\x20update.\n\x20This\x20field\x20has\x20\
    been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\
    \r\n\x05\x046\x02\x03\x05\x12\x04\xb5\x13\x02\x08\n\r\n\x05\x046\x02\x03\
    \x01\x12\x04\xb5\x13\t\x15\n\r\n\x05\x046\x02\x03\x03\x12\x04\xb5\x13\
    \x18\x19\n\x0f\n\x05\x046\x02\x03\x08\x12\x06\xb5\x13\x1a\xb8\x13\x03\n\
    \x0e\n\x06\x046\x02\x03\x08\x03\x12\x04\xb6\x13\x04\x15\n\x10\n\x08\x046\
    \x02\x03\x08\x9c\x08\0\x12\x04\xb7\x13\x04*\n>\n\x04\x046\x02\x04\x12\
    \x04\xbb\x13\x02@\x1a0\x20Required.\x20The\x20desired\x20node\x20count\
    \x20for\x20the\x20pool.\n\n\r\n\x05\x046\x02\x04\x05\x12\x04\xbb\x13\x02\
    \x07\n\r\n\x05\x046\x02\x04\x01\x12\x04\xbb\x13\x08\x12\n\r\n\x05\x046\
    \x02\x04\x03\x12\x04\xbb\x13\x15\x16\n\r\n\x05\x046\x02\x04\x08\x12\x04\
    \xbb\x13\x17?\n\x10\n\x08\x046\x02\x04\x08\x9c\x08\0\x12\x04\xbb\x13\x18\
    >\n\xad\x01\n\x04\x046\x02\x05\x12\x04\xc0\x13\x02\x12\x1a\x9e\x01\x20Th\
    e\x20name\x20(project,\x20location,\x20cluster,\x20node\x20pool\x20id)\
    \x20of\x20the\x20node\x20pool\x20to\x20set\n\x20size.\n\x20Specified\x20\
    in\x20the\x20format\x20'projects/*/locations/*/clusters/*/nodePools/*'.\
    \n\n\r\n\x05\x046\x02\x05\x05\x12\x04\xc0\x13\x02\x08\n\r\n\x05\x046\x02\
    \x05\x01\x12\x04\xc0\x13\t\r\n\r\n\x05\x046\x02\x05\x03\x12\x04\xc0\x13\
    \x10\x11\n\xb0\x01\n\x02\x047\x12\x06\xc6\x13\0\xea\x13\x01\x1a\xa1\x01\
    \x20RollbackNodePoolUpgradeRequest\x20rollbacks\x20the\x20previously\x20\
    Aborted\x20or\x20Failed\n\x20NodePool\x20upgrade.\x20This\x20will\x20be\
    \x20an\x20no-op\x20if\x20the\x20last\x20upgrade\x20successfully\n\x20com\
    pleted.\n\n\x0b\n\x03\x047\x01\x12\x04\xc6\x13\x08&\n\xd8\x01\n\x04\x047\
    \x02\0\x12\x06\xca\x13\x02\xcd\x13\x04\x1a\xc7\x01\x20Required.\x20Depre\
    cated.\x20The\x20Google\x20Developers\x20Console\x20[project\x20ID\x20or\
    \x20project\n\x20number](https://support.google.com/cloud/answer/6158840\
    ).\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\
    \x20by\x20the\x20name\x20field.\n\n\r\n\x05\x047\x02\0\x05\x12\x04\xca\
    \x13\x02\x08\n\r\n\x05\x047\x02\0\x01\x12\x04\xca\x13\t\x13\n\r\n\x05\
    \x047\x02\0\x03\x12\x04\xca\x13\x16\x17\n\x0f\n\x05\x047\x02\0\x08\x12\
    \x06\xca\x13\x18\xcd\x13\x03\n\x0e\n\x06\x047\x02\0\x08\x03\x12\x04\xcb\
    \x13\x04\x15\n\x10\n\x08\x047\x02\0\x08\x9c\x08\0\x12\x04\xcc\x13\x04*\n\
    \xd4\x01\n\x04\x047\x02\x01\x12\x06\xd3\x13\x02\xd6\x13\x04\x1a\xc3\x01\
    \x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20Google\x20Co\
    mpute\x20Engine\n\x20[zone](/compute/docs/zones#available)\x20in\x20whic\
    h\x20the\x20cluster\n\x20resides.\n\x20This\x20field\x20has\x20been\x20d\
    eprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\
    \x047\x02\x01\x05\x12\x04\xd3\x13\x02\x08\n\r\n\x05\x047\x02\x01\x01\x12\
    \x04\xd3\x13\t\r\n\r\n\x05\x047\x02\x01\x03\x12\x04\xd3\x13\x10\x11\n\
    \x0f\n\x05\x047\x02\x01\x08\x12\x06\xd3\x13\x12\xd6\x13\x03\n\x0e\n\x06\
    \x047\x02\x01\x08\x03\x12\x04\xd4\x13\x04\x15\n\x10\n\x08\x047\x02\x01\
    \x08\x9c\x08\0\x12\x04\xd5\x13\x04*\n\x8c\x01\n\x04\x047\x02\x02\x12\x06\
    \xda\x13\x02\xdd\x13\x04\x1a|\x20Required.\x20Deprecated.\x20The\x20name\
    \x20of\x20the\x20cluster\x20to\x20rollback.\n\x20This\x20field\x20has\
    \x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\
    \n\n\r\n\x05\x047\x02\x02\x05\x12\x04\xda\x13\x02\x08\n\r\n\x05\x047\x02\
    \x02\x01\x12\x04\xda\x13\t\x13\n\r\n\x05\x047\x02\x02\x03\x12\x04\xda\
    \x13\x16\x17\n\x0f\n\x05\x047\x02\x02\x08\x12\x06\xda\x13\x18\xdd\x13\
    \x03\n\x0e\n\x06\x047\x02\x02\x08\x03\x12\x04\xdb\x13\x04\x15\n\x10\n\
    \x08\x047\x02\x02\x08\x9c\x08\0\x12\x04\xdc\x13\x04*\n\x8e\x01\n\x04\x04\
    7\x02\x03\x12\x06\xe1\x13\x02\xe4\x13\x04\x1a~\x20Required.\x20Deprecate\
    d.\x20The\x20name\x20of\x20the\x20node\x20pool\x20to\x20rollback.\n\x20T\
    his\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20th\
    e\x20name\x20field.\n\n\r\n\x05\x047\x02\x03\x05\x12\x04\xe1\x13\x02\x08\
    \n\r\n\x05\x047\x02\x03\x01\x12\x04\xe1\x13\t\x15\n\r\n\x05\x047\x02\x03\
    \x03\x12\x04\xe1\x13\x18\x19\n\x0f\n\x05\x047\x02\x03\x08\x12\x06\xe1\
    \x13\x1a\xe4\x13\x03\n\x0e\n\x06\x047\x02\x03\x08\x03\x12\x04\xe2\x13\
    \x04\x15\n\x10\n\x08\x047\x02\x03\x08\x9c\x08\0\x12\x04\xe3\x13\x04*\n\
    \xb5\x01\n\x04\x047\x02\x04\x12\x04\xe9\x13\x02\x12\x1a\xa6\x01\x20The\
    \x20name\x20(project,\x20location,\x20cluster,\x20node\x20pool\x20id)\
    \x20of\x20the\x20node\x20poll\x20to\n\x20rollback\x20upgrade.\n\x20Speci\
    fied\x20in\x20the\x20format\x20'projects/*/locations/*/clusters/*/nodePo\
    ols/*'.\n\n\r\n\x05\x047\x02\x04\x05\x12\x04\xe9\x13\x02\x08\n\r\n\x05\
    \x047\x02\x04\x01\x12\x04\xe9\x13\t\r\n\r\n\x05\x047\x02\x04\x03\x12\x04\
    \xe9\x13\x10\x11\nL\n\x02\x048\x12\x06\xed\x13\0\xf0\x13\x01\x1a>\x20Lis\
    tNodePoolsResponse\x20is\x20the\x20result\x20of\x20ListNodePoolsRequest.\
    \n\n\x0b\n\x03\x048\x01\x12\x04\xed\x13\x08\x1d\n3\n\x04\x048\x02\0\x12\
    \x04\xef\x13\x02#\x1a%\x20A\x20list\x20of\x20node\x20pools\x20for\x20a\
    \x20cluster.\n\n\r\n\x05\x048\x02\0\x04\x12\x04\xef\x13\x02\n\n\r\n\x05\
    \x048\x02\0\x06\x12\x04\xef\x13\x0b\x13\n\r\n\x05\x048\x02\0\x01\x12\x04\
    \xef\x13\x14\x1e\n\r\n\x05\x048\x02\0\x03\x12\x04\xef\x13!\"\n\xd7\x01\n\
    \x02\x049\x12\x06\xf6\x13\0\x85\x14\x01\x1a\xc8\x01\x20ClusterAutoscalin\
    g\x20contains\x20global,\x20per-cluster\x20information\n\x20required\x20\
    by\x20Cluster\x20Autoscaler\x20to\x20automatically\x20adjust\n\x20the\
    \x20size\x20of\x20the\x20cluster\x20and\x20create/delete\n\x20node\x20po\
    ols\x20based\x20on\x20the\x20current\x20needs.\n\n\x0b\n\x03\x049\x01\
    \x12\x04\xf6\x13\x08\x1a\nB\n\x04\x049\x02\0\x12\x04\xf8\x13\x02(\x1a4\
    \x20Enables\x20automatic\x20node\x20pool\x20creation\x20and\x20deletion.\
    \n\n\r\n\x05\x049\x02\0\x05\x12\x04\xf8\x13\x02\x06\n\r\n\x05\x049\x02\0\
    \x01\x12\x04\xf8\x13\x07#\n\r\n\x05\x049\x02\0\x03\x12\x04\xf8\x13&'\nn\
    \n\x04\x049\x02\x01\x12\x04\xfc\x13\x02-\x1a`\x20Contains\x20global\x20c\
    onstraints\x20regarding\x20minimum\x20and\x20maximum\n\x20amount\x20of\
    \x20resources\x20in\x20the\x20cluster.\n\n\r\n\x05\x049\x02\x01\x04\x12\
    \x04\xfc\x13\x02\n\n\r\n\x05\x049\x02\x01\x06\x12\x04\xfc\x13\x0b\x18\n\
    \r\n\x05\x049\x02\x01\x01\x12\x04\xfc\x13\x19(\n\r\n\x05\x049\x02\x01\
    \x03\x12\x04\xfc\x13+,\nc\n\x04\x049\x02\x02\x12\x04\x80\x14\x02K\x1aU\
    \x20AutoprovisioningNodePoolDefaults\x20contains\x20defaults\x20for\x20a\
    \x20node\x20pool\n\x20created\x20by\x20NAP.\n\n\r\n\x05\x049\x02\x02\x06\
    \x12\x04\x80\x14\x02\"\n\r\n\x05\x049\x02\x02\x01\x12\x04\x80\x14#F\n\r\
    \n\x05\x049\x02\x02\x03\x12\x04\x80\x14IJ\n\x8f\x01\n\x04\x049\x02\x03\
    \x12\x04\x84\x14\x021\x1a\x80\x01\x20The\x20list\x20of\x20Google\x20Comp\
    ute\x20Engine\x20[zones](/compute/docs/zones#available)\n\x20in\x20which\
    \x20the\x20NodePool's\x20nodes\x20can\x20be\x20created\x20by\x20NAP.\n\n\
    \r\n\x05\x049\x02\x03\x04\x12\x04\x84\x14\x02\n\n\r\n\x05\x049\x02\x03\
    \x05\x12\x04\x84\x14\x0b\x11\n\r\n\x05\x049\x02\x03\x01\x12\x04\x84\x14\
    \x12,\n\r\n\x05\x049\x02\x03\x03\x12\x04\x84\x14/0\nc\n\x02\x04:\x12\x06\
    \x89\x14\0\x91\x14\x01\x1aU\x20AutoprovisioningNodePoolDefaults\x20conta\
    ins\x20defaults\x20for\x20a\x20node\x20pool\x20created\n\x20by\x20NAP.\n\
    \n\x0b\n\x03\x04:\x01\x12\x04\x89\x14\x08(\n\x86\x01\n\x04\x04:\x02\0\
    \x12\x04\x8c\x14\x02#\x1ax\x20Scopes\x20that\x20are\x20used\x20by\x20NAP\
    \x20when\x20creating\x20node\x20pools.\x20If\x20oauth_scopes\x20are\n\
    \x20specified,\x20service_account\x20should\x20be\x20empty.\n\n\r\n\x05\
    \x04:\x02\0\x04\x12\x04\x8c\x14\x02\n\n\r\n\x05\x04:\x02\0\x05\x12\x04\
    \x8c\x14\x0b\x11\n\r\n\x05\x04:\x02\0\x01\x12\x04\x8c\x14\x12\x1e\n\r\n\
    \x05\x04:\x02\0\x03\x12\x04\x8c\x14!\"\n\x90\x01\n\x04\x04:\x02\x01\x12\
    \x04\x90\x14\x02\x1d\x1a\x81\x01\x20The\x20Google\x20Cloud\x20Platform\
    \x20Service\x20Account\x20to\x20be\x20used\x20by\x20the\x20node\x20VMs.\
    \x20If\n\x20service_account\x20is\x20specified,\x20scopes\x20should\x20b\
    e\x20empty.\n\n\r\n\x05\x04:\x02\x01\x05\x12\x04\x90\x14\x02\x08\n\r\n\
    \x05\x04:\x02\x01\x01\x12\x04\x90\x14\t\x18\n\r\n\x05\x04:\x02\x01\x03\
    \x12\x04\x90\x14\x1b\x1c\nv\n\x02\x04;\x12\x06\x95\x14\0\x9e\x14\x01\x1a\
    h\x20Contains\x20information\x20about\x20amount\x20of\x20some\x20resourc\
    e\x20in\x20the\x20cluster.\n\x20For\x20memory,\x20value\x20should\x20be\
    \x20in\x20GB.\n\n\x0b\n\x03\x04;\x01\x12\x04\x95\x14\x08\x15\nE\n\x04\
    \x04;\x02\0\x12\x04\x97\x14\x02\x1b\x1a7\x20Resource\x20name\x20\"cpu\",\
    \x20\"memory\"\x20or\x20gpu-specific\x20string.\n\n\r\n\x05\x04;\x02\0\
    \x05\x12\x04\x97\x14\x02\x08\n\r\n\x05\x04;\x02\0\x01\x12\x04\x97\x14\t\
    \x16\n\r\n\x05\x04;\x02\0\x03\x12\x04\x97\x14\x19\x1a\n>\n\x04\x04;\x02\
    \x01\x12\x04\x9a\x14\x02\x14\x1a0\x20Minimum\x20amount\x20of\x20the\x20r\
    esource\x20in\x20the\x20cluster.\n\n\r\n\x05\x04;\x02\x01\x05\x12\x04\
    \x9a\x14\x02\x07\n\r\n\x05\x04;\x02\x01\x01\x12\x04\x9a\x14\x08\x0f\n\r\
    \n\x05\x04;\x02\x01\x03\x12\x04\x9a\x14\x12\x13\n>\n\x04\x04;\x02\x02\
    \x12\x04\x9d\x14\x02\x14\x1a0\x20Maximum\x20amount\x20of\x20the\x20resou\
    rce\x20in\x20the\x20cluster.\n\n\r\n\x05\x04;\x02\x02\x05\x12\x04\x9d\
    \x14\x02\x07\n\r\n\x05\x04;\x02\x02\x01\x12\x04\x9d\x14\x08\x0f\n\r\n\
    \x05\x04;\x02\x02\x03\x12\x04\x9d\x14\x12\x13\n\x9b\x01\n\x02\x04<\x12\
    \x06\xa2\x14\0\xb0\x14\x01\x1a\x8c\x01\x20NodePoolAutoscaling\x20contain\
    s\x20information\x20required\x20by\x20cluster\x20autoscaler\x20to\n\x20a\
    djust\x20the\x20size\x20of\x20the\x20node\x20pool\x20to\x20the\x20curren\
    t\x20cluster\x20usage.\n\n\x0b\n\x03\x04<\x01\x12\x04\xa2\x14\x08\x1b\n:\
    \n\x04\x04<\x02\0\x12\x04\xa4\x14\x02\x13\x1a,\x20Is\x20autoscaling\x20e\
    nabled\x20for\x20this\x20node\x20pool.\n\n\r\n\x05\x04<\x02\0\x05\x12\
    \x04\xa4\x14\x02\x06\n\r\n\x05\x04<\x02\0\x01\x12\x04\xa4\x14\x07\x0e\n\
    \r\n\x05\x04<\x02\0\x03\x12\x04\xa4\x14\x11\x12\n]\n\x04\x04<\x02\x01\
    \x12\x04\xa8\x14\x02\x1b\x1aO\x20Minimum\x20number\x20of\x20nodes\x20in\
    \x20the\x20NodePool.\x20Must\x20be\x20>=\x201\x20and\x20<=\n\x20max_node\
    _count.\n\n\r\n\x05\x04<\x02\x01\x05\x12\x04\xa8\x14\x02\x07\n\r\n\x05\
    \x04<\x02\x01\x01\x12\x04\xa8\x14\x08\x16\n\r\n\x05\x04<\x02\x01\x03\x12\
    \x04\xa8\x14\x19\x1a\n\x87\x01\n\x04\x04<\x02\x02\x12\x04\xac\x14\x02\
    \x1b\x1ay\x20Maximum\x20number\x20of\x20nodes\x20in\x20the\x20NodePool.\
    \x20Must\x20be\x20>=\x20min_node_count.\x20There\n\x20has\x20to\x20enoug\
    h\x20quota\x20to\x20scale\x20up\x20the\x20cluster.\n\n\r\n\x05\x04<\x02\
    \x02\x05\x12\x04\xac\x14\x02\x07\n\r\n\x05\x04<\x02\x02\x01\x12\x04\xac\
    \x14\x08\x16\n\r\n\x05\x04<\x02\x02\x03\x12\x04\xac\x14\x19\x1a\n<\n\x04\
    \x04<\x02\x03\x12\x04\xaf\x14\x02\x1b\x1a.\x20Can\x20this\x20node\x20poo\
    l\x20be\x20deleted\x20automatically.\n\n\r\n\x05\x04<\x02\x03\x05\x12\
    \x04\xaf\x14\x02\x06\n\r\n\x05\x04<\x02\x03\x01\x12\x04\xaf\x14\x07\x16\
    \n\r\n\x05\x04<\x02\x03\x03\x12\x04\xaf\x14\x19\x1a\n\xc4\x01\n\x02\x04=\
    \x12\x06\xb5\x14\0\xdc\x14\x01\x1a\xb5\x01\x20SetLabelsRequest\x20sets\
    \x20the\x20Google\x20Cloud\x20Platform\x20labels\x20on\x20a\x20Google\
    \x20Container\n\x20Engine\x20cluster,\x20which\x20will\x20in\x20turn\x20\
    set\x20them\x20for\x20Google\x20Compute\x20Engine\n\x20resources\x20used\
    \x20by\x20that\x20cluster\n\n\x0b\n\x03\x04=\x01\x12\x04\xb5\x14\x08\x18\
    \n\xe6\x01\n\x04\x04=\x02\0\x12\x06\xb9\x14\x02\xbc\x14\x04\x1a\xd5\x01\
    \x20Required.\x20Deprecated.\x20The\x20Google\x20Developers\x20Console\
    \x20[project\x20ID\x20or\x20project\n\x20number](https://developers.goog\
    le.com/console/help/new/#projectnumber).\n\x20This\x20field\x20has\x20be\
    en\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\
    \n\x05\x04=\x02\0\x05\x12\x04\xb9\x14\x02\x08\n\r\n\x05\x04=\x02\0\x01\
    \x12\x04\xb9\x14\t\x13\n\r\n\x05\x04=\x02\0\x03\x12\x04\xb9\x14\x16\x17\
    \n\x0f\n\x05\x04=\x02\0\x08\x12\x06\xb9\x14\x18\xbc\x14\x03\n\x0e\n\x06\
    \x04=\x02\0\x08\x03\x12\x04\xba\x14\x04\x15\n\x10\n\x08\x04=\x02\0\x08\
    \x9c\x08\0\x12\x04\xbb\x14\x04*\n\xd4\x01\n\x04\x04=\x02\x01\x12\x06\xc2\
    \x14\x02\xc5\x14\x04\x1a\xc3\x01\x20Required.\x20Deprecated.\x20The\x20n\
    ame\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zone](/compute/doc\
    s/zones#available)\x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20T\
    his\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20th\
    e\x20name\x20field.\n\n\r\n\x05\x04=\x02\x01\x05\x12\x04\xc2\x14\x02\x08\
    \n\r\n\x05\x04=\x02\x01\x01\x12\x04\xc2\x14\t\r\n\r\n\x05\x04=\x02\x01\
    \x03\x12\x04\xc2\x14\x10\x11\n\x0f\n\x05\x04=\x02\x01\x08\x12\x06\xc2\
    \x14\x12\xc5\x14\x03\n\x0e\n\x06\x04=\x02\x01\x08\x03\x12\x04\xc3\x14\
    \x04\x15\n\x10\n\x08\x04=\x02\x01\x08\x9c\x08\0\x12\x04\xc4\x14\x04*\n\
    \x80\x01\n\x04\x04=\x02\x02\x12\x06\xc9\x14\x02\xcc\x14\x04\x1ap\x20Requ\
    ired.\x20Deprecated.\x20The\x20name\x20of\x20the\x20cluster.\n\x20This\
    \x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\
    \x20name\x20field.\n\n\r\n\x05\x04=\x02\x02\x05\x12\x04\xc9\x14\x02\x08\
    \n\r\n\x05\x04=\x02\x02\x01\x12\x04\xc9\x14\t\x13\n\r\n\x05\x04=\x02\x02\
    \x03\x12\x04\xc9\x14\x16\x17\n\x0f\n\x05\x04=\x02\x02\x08\x12\x06\xc9\
    \x14\x18\xcc\x14\x03\n\x0e\n\x06\x04=\x02\x02\x08\x03\x12\x04\xca\x14\
    \x04\x15\n\x10\n\x08\x04=\x02\x02\x08\x9c\x08\0\x12\x04\xcb\x14\x04*\n=\
    \n\x04\x04=\x02\x03\x12\x04\xcf\x14\x02S\x1a/\x20Required.\x20The\x20lab\
    els\x20to\x20set\x20for\x20that\x20cluster.\n\n\r\n\x05\x04=\x02\x03\x06\
    \x12\x04\xcf\x14\x02\x15\n\r\n\x05\x04=\x02\x03\x01\x12\x04\xcf\x14\x16%\
    \n\r\n\x05\x04=\x02\x03\x03\x12\x04\xcf\x14()\n\r\n\x05\x04=\x02\x03\x08\
    \x12\x04\xcf\x14*R\n\x10\n\x08\x04=\x02\x03\x08\x9c\x08\0\x12\x04\xcf\
    \x14+Q\n\x9c\x03\n\x04\x04=\x02\x04\x12\x04\xd7\x14\x02H\x1a\x8d\x03\x20\
    Required.\x20The\x20fingerprint\x20of\x20the\x20previous\x20set\x20of\
    \x20labels\x20for\x20this\x20resource,\n\x20used\x20to\x20detect\x20conf\
    licts.\x20The\x20fingerprint\x20is\x20initially\x20generated\x20by\n\x20\
    Kubernetes\x20Engine\x20and\x20changes\x20after\x20every\x20request\x20t\
    o\x20modify\x20or\x20update\n\x20labels.\x20You\x20must\x20always\x20pro\
    vide\x20an\x20up-to-date\x20fingerprint\x20hash\x20when\n\x20updating\
    \x20or\x20changing\x20labels.\x20Make\x20a\x20<code>get()</code>\x20requ\
    est\x20to\x20the\n\x20resource\x20to\x20get\x20the\x20latest\x20fingerpr\
    int.\n\n\r\n\x05\x04=\x02\x04\x05\x12\x04\xd7\x14\x02\x08\n\r\n\x05\x04=\
    \x02\x04\x01\x12\x04\xd7\x14\t\x1a\n\r\n\x05\x04=\x02\x04\x03\x12\x04\
    \xd7\x14\x1d\x1e\n\r\n\x05\x04=\x02\x04\x08\x12\x04\xd7\x14\x1fG\n\x10\n\
    \x08\x04=\x02\x04\x08\x9c\x08\0\x12\x04\xd7\x14\x20F\n\x95\x01\n\x04\x04\
    =\x02\x05\x12\x04\xdb\x14\x02\x12\x1a\x86\x01\x20The\x20name\x20(project\
    ,\x20location,\x20cluster\x20id)\x20of\x20the\x20cluster\x20to\x20set\
    \x20labels.\n\x20Specified\x20in\x20the\x20format\x20'projects/*/locatio\
    ns/*/clusters/*'.\n\n\r\n\x05\x04=\x02\x05\x05\x12\x04\xdb\x14\x02\x08\n\
    \r\n\x05\x04=\x02\x05\x01\x12\x04\xdb\x14\t\r\n\r\n\x05\x04=\x02\x05\x03\
    \x12\x04\xdb\x14\x10\x11\ni\n\x02\x04>\x12\x06\xe0\x14\0\xff\x14\x01\x1a\
    [\x20SetLegacyAbacRequest\x20enables\x20or\x20disables\x20the\x20ABAC\
    \x20authorization\x20mechanism\x20for\n\x20a\x20cluster.\n\n\x0b\n\x03\
    \x04>\x01\x12\x04\xe0\x14\x08\x1c\n\xd8\x01\n\x04\x04>\x02\0\x12\x06\xe4\
    \x14\x02\xe7\x14\x04\x1a\xc7\x01\x20Required.\x20Deprecated.\x20The\x20G\
    oogle\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\n\x20n\
    umber](https://support.google.com/cloud/answer/6158840).\n\x20This\x20fi\
    eld\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\
    \x20field.\n\n\r\n\x05\x04>\x02\0\x05\x12\x04\xe4\x14\x02\x08\n\r\n\x05\
    \x04>\x02\0\x01\x12\x04\xe4\x14\t\x13\n\r\n\x05\x04>\x02\0\x03\x12\x04\
    \xe4\x14\x16\x17\n\x0f\n\x05\x04>\x02\0\x08\x12\x06\xe4\x14\x18\xe7\x14\
    \x03\n\x0e\n\x06\x04>\x02\0\x08\x03\x12\x04\xe5\x14\x04\x15\n\x10\n\x08\
    \x04>\x02\0\x08\x9c\x08\0\x12\x04\xe6\x14\x04*\n\xd4\x01\n\x04\x04>\x02\
    \x01\x12\x06\xed\x14\x02\xf0\x14\x04\x1a\xc3\x01\x20Required.\x20Depreca\
    ted.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zo\
    ne](/compute/docs/zones#available)\x20in\x20which\x20the\x20cluster\n\
    \x20resides.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20r\
    eplaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04>\x02\x01\x05\x12\
    \x04\xed\x14\x02\x08\n\r\n\x05\x04>\x02\x01\x01\x12\x04\xed\x14\t\r\n\r\
    \n\x05\x04>\x02\x01\x03\x12\x04\xed\x14\x10\x11\n\x0f\n\x05\x04>\x02\x01\
    \x08\x12\x06\xed\x14\x12\xf0\x14\x03\n\x0e\n\x06\x04>\x02\x01\x08\x03\
    \x12\x04\xee\x14\x04\x15\n\x10\n\x08\x04>\x02\x01\x08\x9c\x08\0\x12\x04\
    \xef\x14\x04*\n\x8a\x01\n\x04\x04>\x02\x02\x12\x06\xf4\x14\x02\xf7\x14\
    \x04\x1az\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20clu\
    ster\x20to\x20update.\n\x20This\x20field\x20has\x20been\x20deprecated\
    \x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04>\x02\
    \x02\x05\x12\x04\xf4\x14\x02\x08\n\r\n\x05\x04>\x02\x02\x01\x12\x04\xf4\
    \x14\t\x13\n\r\n\x05\x04>\x02\x02\x03\x12\x04\xf4\x14\x16\x17\n\x0f\n\
    \x05\x04>\x02\x02\x08\x12\x06\xf4\x14\x18\xf7\x14\x03\n\x0e\n\x06\x04>\
    \x02\x02\x08\x03\x12\x04\xf5\x14\x04\x15\n\x10\n\x08\x04>\x02\x02\x08\
    \x9c\x08\0\x12\x04\xf6\x14\x04*\nT\n\x04\x04>\x02\x03\x12\x04\xfa\x14\
    \x02<\x1aF\x20Required.\x20Whether\x20ABAC\x20authorization\x20will\x20b\
    e\x20enabled\x20in\x20the\x20cluster.\n\n\r\n\x05\x04>\x02\x03\x05\x12\
    \x04\xfa\x14\x02\x06\n\r\n\x05\x04>\x02\x03\x01\x12\x04\xfa\x14\x07\x0e\
    \n\r\n\x05\x04>\x02\x03\x03\x12\x04\xfa\x14\x11\x12\n\r\n\x05\x04>\x02\
    \x03\x08\x12\x04\xfa\x14\x13;\n\x10\n\x08\x04>\x02\x03\x08\x9c\x08\0\x12\
    \x04\xfa\x14\x14:\n\x9a\x01\n\x04\x04>\x02\x04\x12\x04\xfe\x14\x02\x12\
    \x1a\x8b\x01\x20The\x20name\x20(project,\x20location,\x20cluster\x20id)\
    \x20of\x20the\x20cluster\x20to\x20set\x20legacy\x20abac.\n\x20Specified\
    \x20in\x20the\x20format\x20'projects/*/locations/*/clusters/*'.\n\n\r\n\
    \x05\x04>\x02\x04\x05\x12\x04\xfe\x14\x02\x08\n\r\n\x05\x04>\x02\x04\x01\
    \x12\x04\xfe\x14\t\r\n\r\n\x05\x04>\x02\x04\x03\x12\x04\xfe\x14\x10\x11\
    \n\x94\x01\n\x02\x04?\x12\x06\x83\x15\0\xa2\x15\x01\x1a\x85\x01\x20Start\
    IPRotationRequest\x20creates\x20a\x20new\x20IP\x20for\x20the\x20cluster\
    \x20and\x20then\x20performs\n\x20a\x20node\x20upgrade\x20on\x20each\x20n\
    ode\x20pool\x20to\x20point\x20to\x20the\x20new\x20IP.\n\n\x0b\n\x03\x04?\
    \x01\x12\x04\x83\x15\x08\x1e\n\xe6\x01\n\x04\x04?\x02\0\x12\x06\x87\x15\
    \x02\x8a\x15\x04\x1a\xd5\x01\x20Required.\x20Deprecated.\x20The\x20Googl\
    e\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\n\x20numbe\
    r](https://developers.google.com/console/help/new/#projectnumber).\n\x20\
    This\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20t\
    he\x20name\x20field.\n\n\r\n\x05\x04?\x02\0\x05\x12\x04\x87\x15\x02\x08\
    \n\r\n\x05\x04?\x02\0\x01\x12\x04\x87\x15\t\x13\n\r\n\x05\x04?\x02\0\x03\
    \x12\x04\x87\x15\x16\x17\n\x0f\n\x05\x04?\x02\0\x08\x12\x06\x87\x15\x18\
    \x8a\x15\x03\n\x0e\n\x06\x04?\x02\0\x08\x03\x12\x04\x88\x15\x04\x15\n\
    \x10\n\x08\x04?\x02\0\x08\x9c\x08\0\x12\x04\x89\x15\x04*\n\xd4\x01\n\x04\
    \x04?\x02\x01\x12\x06\x90\x15\x02\x93\x15\x04\x1a\xc3\x01\x20Required.\
    \x20Deprecated.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Engi\
    ne\n\x20[zone](/compute/docs/zones#available)\x20in\x20which\x20the\x20c\
    luster\n\x20resides.\n\x20This\x20field\x20has\x20been\x20deprecated\x20\
    and\x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04?\x02\x01\
    \x05\x12\x04\x90\x15\x02\x08\n\r\n\x05\x04?\x02\x01\x01\x12\x04\x90\x15\
    \t\r\n\r\n\x05\x04?\x02\x01\x03\x12\x04\x90\x15\x10\x11\n\x0f\n\x05\x04?\
    \x02\x01\x08\x12\x06\x90\x15\x12\x93\x15\x03\n\x0e\n\x06\x04?\x02\x01\
    \x08\x03\x12\x04\x91\x15\x04\x15\n\x10\n\x08\x04?\x02\x01\x08\x9c\x08\0\
    \x12\x04\x92\x15\x04*\n\x80\x01\n\x04\x04?\x02\x02\x12\x06\x97\x15\x02\
    \x9a\x15\x04\x1ap\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20th\
    e\x20cluster.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20\
    replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04?\x02\x02\x05\x12\
    \x04\x97\x15\x02\x08\n\r\n\x05\x04?\x02\x02\x01\x12\x04\x97\x15\t\x13\n\
    \r\n\x05\x04?\x02\x02\x03\x12\x04\x97\x15\x16\x17\n\x0f\n\x05\x04?\x02\
    \x02\x08\x12\x06\x97\x15\x18\x9a\x15\x03\n\x0e\n\x06\x04?\x02\x02\x08\
    \x03\x12\x04\x98\x15\x04\x15\n\x10\n\x08\x04?\x02\x02\x08\x9c\x08\0\x12\
    \x04\x99\x15\x04*\n\x9c\x01\n\x04\x04?\x02\x03\x12\x04\x9e\x15\x02\x12\
    \x1a\x8d\x01\x20The\x20name\x20(project,\x20location,\x20cluster\x20id)\
    \x20of\x20the\x20cluster\x20to\x20start\x20IP\n\x20rotation.\x20Specifie\
    d\x20in\x20the\x20format\x20'projects/*/locations/*/clusters/*'.\n\n\r\n\
    \x05\x04?\x02\x03\x05\x12\x04\x9e\x15\x02\x08\n\r\n\x05\x04?\x02\x03\x01\
    \x12\x04\x9e\x15\t\r\n\r\n\x05\x04?\x02\x03\x03\x12\x04\x9e\x15\x10\x11\
    \nA\n\x04\x04?\x02\x04\x12\x04\xa1\x15\x02\x1e\x1a3\x20Whether\x20to\x20\
    rotate\x20credentials\x20during\x20IP\x20rotation.\n\n\r\n\x05\x04?\x02\
    \x04\x05\x12\x04\xa1\x15\x02\x06\n\r\n\x05\x04?\x02\x04\x01\x12\x04\xa1\
    \x15\x07\x19\n\r\n\x05\x04?\x02\x04\x03\x12\x04\xa1\x15\x1c\x1d\n\\\n\
    \x02\x04@\x12\x06\xa5\x15\0\xc1\x15\x01\x1aN\x20CompleteIPRotationReques\
    t\x20moves\x20the\x20cluster\x20master\x20back\x20into\x20single-IP\x20m\
    ode.\n\n\x0b\n\x03\x04@\x01\x12\x04\xa5\x15\x08!\n\xe6\x01\n\x04\x04@\
    \x02\0\x12\x06\xa9\x15\x02\xac\x15\x04\x1a\xd5\x01\x20Required.\x20Depre\
    cated.\x20The\x20Google\x20Developers\x20Console\x20[project\x20ID\x20or\
    \x20project\n\x20number](https://developers.google.com/console/help/new/\
    #projectnumber).\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\
    \x20replaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04@\x02\0\x05\
    \x12\x04\xa9\x15\x02\x08\n\r\n\x05\x04@\x02\0\x01\x12\x04\xa9\x15\t\x13\
    \n\r\n\x05\x04@\x02\0\x03\x12\x04\xa9\x15\x16\x17\n\x0f\n\x05\x04@\x02\0\
    \x08\x12\x06\xa9\x15\x18\xac\x15\x03\n\x0e\n\x06\x04@\x02\0\x08\x03\x12\
    \x04\xaa\x15\x04\x15\n\x10\n\x08\x04@\x02\0\x08\x9c\x08\0\x12\x04\xab\
    \x15\x04*\n\xd4\x01\n\x04\x04@\x02\x01\x12\x06\xb2\x15\x02\xb5\x15\x04\
    \x1a\xc3\x01\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20\
    Google\x20Compute\x20Engine\n\x20[zone](/compute/docs/zones#available)\
    \x20in\x20which\x20the\x20cluster\n\x20resides.\n\x20This\x20field\x20ha\
    s\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field\
    .\n\n\r\n\x05\x04@\x02\x01\x05\x12\x04\xb2\x15\x02\x08\n\r\n\x05\x04@\
    \x02\x01\x01\x12\x04\xb2\x15\t\r\n\r\n\x05\x04@\x02\x01\x03\x12\x04\xb2\
    \x15\x10\x11\n\x0f\n\x05\x04@\x02\x01\x08\x12\x06\xb2\x15\x12\xb5\x15\
    \x03\n\x0e\n\x06\x04@\x02\x01\x08\x03\x12\x04\xb3\x15\x04\x15\n\x10\n\
    \x08\x04@\x02\x01\x08\x9c\x08\0\x12\x04\xb4\x15\x04*\n\x80\x01\n\x04\x04\
    @\x02\x02\x12\x06\xb9\x15\x02\xbc\x15\x04\x1ap\x20Required.\x20Deprecate\
    d.\x20The\x20name\x20of\x20the\x20cluster.\n\x20This\x20field\x20has\x20\
    been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\x20field.\n\n\
    \r\n\x05\x04@\x02\x02\x05\x12\x04\xb9\x15\x02\x08\n\r\n\x05\x04@\x02\x02\
    \x01\x12\x04\xb9\x15\t\x13\n\r\n\x05\x04@\x02\x02\x03\x12\x04\xb9\x15\
    \x16\x17\n\x0f\n\x05\x04@\x02\x02\x08\x12\x06\xb9\x15\x18\xbc\x15\x03\n\
    \x0e\n\x06\x04@\x02\x02\x08\x03\x12\x04\xba\x15\x04\x15\n\x10\n\x08\x04@\
    \x02\x02\x08\x9c\x08\0\x12\x04\xbb\x15\x04*\n\x9f\x01\n\x04\x04@\x02\x03\
    \x12\x04\xc0\x15\x02\x12\x1a\x90\x01\x20The\x20name\x20(project,\x20loca\
    tion,\x20cluster\x20id)\x20of\x20the\x20cluster\x20to\x20complete\x20IP\
    \n\x20rotation.\x20Specified\x20in\x20the\x20format\x20'projects/*/locat\
    ions/*/clusters/*'.\n\n\r\n\x05\x04@\x02\x03\x05\x12\x04\xc0\x15\x02\x08\
    \n\r\n\x05\x04@\x02\x03\x01\x12\x04\xc0\x15\t\r\n\r\n\x05\x04@\x02\x03\
    \x03\x12\x04\xc0\x15\x10\x11\nL\n\x02\x04A\x12\x06\xc4\x15\0\xcb\x15\x01\
    \x1a>\x20AcceleratorConfig\x20represents\x20a\x20Hardware\x20Accelerator\
    \x20request.\n\n\x0b\n\x03\x04A\x01\x12\x04\xc4\x15\x08\x19\nK\n\x04\x04\
    A\x02\0\x12\x04\xc6\x15\x02\x1e\x1a=\x20The\x20number\x20of\x20the\x20ac\
    celerator\x20cards\x20exposed\x20to\x20an\x20instance.\n\n\r\n\x05\x04A\
    \x02\0\x05\x12\x04\xc6\x15\x02\x07\n\r\n\x05\x04A\x02\0\x01\x12\x04\xc6\
    \x15\x08\x19\n\r\n\x05\x04A\x02\0\x03\x12\x04\xc6\x15\x1c\x1d\nn\n\x04\
    \x04A\x02\x01\x12\x04\xca\x15\x02\x1e\x1a`\x20The\x20accelerator\x20type\
    \x20resource\x20name.\x20List\x20of\x20supported\x20accelerators\n\x20[h\
    ere](/compute/docs/gpus)\n\n\r\n\x05\x04A\x02\x01\x05\x12\x04\xca\x15\
    \x02\x08\n\r\n\x05\x04A\x02\x01\x01\x12\x04\xca\x15\t\x19\n\r\n\x05\x04A\
    \x02\x01\x03\x12\x04\xca\x15\x1c\x1d\nV\n\x02\x04B\x12\x06\xce\x15\0\xed\
    \x15\x01\x1aH\x20SetNetworkPolicyRequest\x20enables/disables\x20network\
    \x20policy\x20for\x20a\x20cluster.\n\n\x0b\n\x03\x04B\x01\x12\x04\xce\
    \x15\x08\x1f\n\xe6\x01\n\x04\x04B\x02\0\x12\x06\xd2\x15\x02\xd5\x15\x04\
    \x1a\xd5\x01\x20Required.\x20Deprecated.\x20The\x20Google\x20Developers\
    \x20Console\x20[project\x20ID\x20or\x20project\n\x20number](https://deve\
    lopers.google.com/console/help/new/#projectnumber).\n\x20This\x20field\
    \x20has\x20been\x20deprecated\x20and\x20replaced\x20by\x20the\x20name\
    \x20field.\n\n\r\n\x05\x04B\x02\0\x05\x12\x04\xd2\x15\x02\x08\n\r\n\x05\
    \x04B\x02\0\x01\x12\x04\xd2\x15\t\x13\n\r\n\x05\x04B\x02\0\x03\x12\x04\
    \xd2\x15\x16\x17\n\x0f\n\x05\x04B\x02\0\x08\x12\x06\xd2\x15\x18\xd5\x15\
    \x03\n\x0e\n\x06\x04B\x02\0\x08\x03\x12\x04\xd3\x15\x04\x15\n\x10\n\x08\
    \x04B\x02\0\x08\x9c\x08\0\x12\x04\xd4\x15\x04*\n\xd4\x01\n\x04\x04B\x02\
    \x01\x12\x06\xdb\x15\x02\xde\x15\x04\x1a\xc3\x01\x20Required.\x20Depreca\
    ted.\x20The\x20name\x20of\x20the\x20Google\x20Compute\x20Engine\n\x20[zo\
    ne](/compute/docs/zones#available)\x20in\x20which\x20the\x20cluster\n\
    \x20resides.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20r\
    eplaced\x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04B\x02\x01\x05\x12\
    \x04\xdb\x15\x02\x08\n\r\n\x05\x04B\x02\x01\x01\x12\x04\xdb\x15\t\r\n\r\
    \n\x05\x04B\x02\x01\x03\x12\x04\xdb\x15\x10\x11\n\x0f\n\x05\x04B\x02\x01\
    \x08\x12\x06\xdb\x15\x12\xde\x15\x03\n\x0e\n\x06\x04B\x02\x01\x08\x03\
    \x12\x04\xdc\x15\x04\x15\n\x10\n\x08\x04B\x02\x01\x08\x9c\x08\0\x12\x04\
    \xdd\x15\x04*\n\x80\x01\n\x04\x04B\x02\x02\x12\x06\xe2\x15\x02\xe5\x15\
    \x04\x1ap\x20Required.\x20Deprecated.\x20The\x20name\x20of\x20the\x20clu\
    ster.\n\x20This\x20field\x20has\x20been\x20deprecated\x20and\x20replaced\
    \x20by\x20the\x20name\x20field.\n\n\r\n\x05\x04B\x02\x02\x05\x12\x04\xe2\
    \x15\x02\x08\n\r\n\x05\x04B\x02\x02\x01\x12\x04\xe2\x15\t\x13\n\r\n\x05\
    \x04B\x02\x02\x03\x12\x04\xe2\x15\x16\x17\n\x0f\n\x05\x04B\x02\x02\x08\
    \x12\x06\xe2\x15\x18\xe5\x15\x03\n\x0e\n\x06\x04B\x02\x02\x08\x03\x12\
    \x04\xe3\x15\x04\x15\n\x10\n\x08\x04B\x02\x02\x08\x9c\x08\0\x12\x04\xe4\
    \x15\x04*\nN\n\x04\x04B\x02\x03\x12\x04\xe8\x15\x02L\x1a@\x20Required.\
    \x20Configuration\x20options\x20for\x20the\x20NetworkPolicy\x20feature.\
    \n\n\r\n\x05\x04B\x02\x03\x06\x12\x04\xe8\x15\x02\x0f\n\r\n\x05\x04B\x02\
    \x03\x01\x12\x04\xe8\x15\x10\x1e\n\r\n\x05\x04B\x02\x03\x03\x12\x04\xe8\
    \x15!\"\n\r\n\x05\x04B\x02\x03\x08\x12\x04\xe8\x15#K\n\x10\n\x08\x04B\
    \x02\x03\x08\x9c\x08\0\x12\x04\xe8\x15$J\n\xa0\x01\n\x04\x04B\x02\x04\
    \x12\x04\xec\x15\x02\x12\x1a\x91\x01\x20The\x20name\x20(project,\x20loca\
    tion,\x20cluster\x20id)\x20of\x20the\x20cluster\x20to\x20set\x20networki\
    ng\n\x20policy.\x20Specified\x20in\x20the\x20format\x20'projects/*/locat\
    ions/*/clusters/*'.\n\n\r\n\x05\x04B\x02\x04\x05\x12\x04\xec\x15\x02\x08\
    \n\r\n\x05\x04B\x02\x04\x01\x12\x04\xec\x15\t\r\n\r\n\x05\x04B\x02\x04\
    \x03\x12\x04\xec\x15\x10\x11\nV\n\x02\x04C\x12\x06\xf0\x15\0\x85\x16\x01\
    \x1aH\x20SetMaintenancePolicyRequest\x20sets\x20the\x20maintenance\x20po\
    licy\x20for\x20a\x20cluster.\n\n\x0b\n\x03\x04C\x01\x12\x04\xf0\x15\x08#\
    \n\x89\x01\n\x04\x04C\x02\0\x12\x04\xf3\x15\x02A\x1a{\x20Required.\x20Th\
    e\x20Google\x20Developers\x20Console\x20[project\x20ID\x20or\x20project\
    \n\x20number](https://support.google.com/cloud/answer/6158840).\n\n\r\n\
    \x05\x04C\x02\0\x05\x12\x04\xf3\x15\x02\x08\n\r\n\x05\x04C\x02\0\x01\x12\
    \x04\xf3\x15\t\x13\n\r\n\x05\x04C\x02\0\x03\x12\x04\xf3\x15\x16\x17\n\r\
    \n\x05\x04C\x02\0\x08\x12\x04\xf3\x15\x18@\n\x10\n\x08\x04C\x02\0\x08\
    \x9c\x08\0\x12\x04\xf3\x15\x19?\n\x85\x01\n\x04\x04C\x02\x01\x12\x04\xf8\
    \x15\x02;\x1aw\x20Required.\x20The\x20name\x20of\x20the\x20Google\x20Com\
    pute\x20Engine\n\x20[zone](/compute/docs/zones#available)\x20in\x20which\
    \x20the\x20cluster\n\x20resides.\n\n\r\n\x05\x04C\x02\x01\x05\x12\x04\
    \xf8\x15\x02\x08\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xf8\x15\t\r\n\r\n\
    \x05\x04C\x02\x01\x03\x12\x04\xf8\x15\x10\x11\n\r\n\x05\x04C\x02\x01\x08\
    \x12\x04\xf8\x15\x12:\n\x10\n\x08\x04C\x02\x01\x08\x9c\x08\0\x12\x04\xf8\
    \x15\x139\n<\n\x04\x04C\x02\x02\x12\x04\xfb\x15\x02A\x1a.\x20Required.\
    \x20The\x20name\x20of\x20the\x20cluster\x20to\x20update.\n\n\r\n\x05\x04\
    C\x02\x02\x05\x12\x04\xfb\x15\x02\x08\n\r\n\x05\x04C\x02\x02\x01\x12\x04\
    \xfb\x15\t\x13\n\r\n\x05\x04C\x02\x02\x03\x12\x04\xfb\x15\x16\x17\n\r\n\
    \x05\x04C\x02\x02\x08\x12\x04\xfb\x15\x18@\n\x10\n\x08\x04C\x02\x02\x08\
    \x9c\x08\0\x12\x04\xfb\x15\x19?\n\x83\x01\n\x04\x04C\x02\x03\x12\x04\xff\
    \x15\x02T\x1au\x20Required.\x20The\x20maintenance\x20policy\x20to\x20be\
    \x20set\x20for\x20the\x20cluster.\x20An\x20empty\x20field\n\x20clears\
    \x20the\x20existing\x20maintenance\x20policy.\n\n\r\n\x05\x04C\x02\x03\
    \x06\x12\x04\xff\x15\x02\x13\n\r\n\x05\x04C\x02\x03\x01\x12\x04\xff\x15\
    \x14&\n\r\n\x05\x04C\x02\x03\x03\x12\x04\xff\x15)*\n\r\n\x05\x04C\x02\
    \x03\x08\x12\x04\xff\x15+S\n\x10\n\x08\x04C\x02\x03\x08\x9c\x08\0\x12\
    \x04\xff\x15,R\n\xa2\x01\n\x04\x04C\x02\x04\x12\x04\x84\x16\x02\x12\x1a\
    \x93\x01\x20The\x20name\x20(project,\x20location,\x20cluster\x20id)\x20o\
    f\x20the\x20cluster\x20to\x20set\x20maintenance\n\x20policy.\n\x20Specif\
    ied\x20in\x20the\x20format\x20'projects/*/locations/*/clusters/*'.\n\n\r\
    \n\x05\x04C\x02\x04\x05\x12\x04\x84\x16\x02\x08\n\r\n\x05\x04C\x02\x04\
    \x01\x12\x04\x84\x16\t\r\n\r\n\x05\x04C\x02\x04\x03\x12\x04\x84\x16\x10\
    \x11\nw\n\x02\x04D\x12\x06\x89\x16\0\xa7\x16\x01\x1ai\x20StatusCondition\
    \x20describes\x20why\x20a\x20cluster\x20or\x20a\x20node\x20pool\x20has\
    \x20a\x20certain\x20status\n\x20(e.g.,\x20ERROR\x20or\x20DEGRADED).\n\n\
    \x0b\n\x03\x04D\x01\x12\x04\x89\x16\x08\x17\n)\n\x04\x04D\x04\0\x12\x06\
    \x8b\x16\x02\xa0\x16\x03\x1a\x19\x20Code\x20for\x20each\x20condition\n\n\
    \r\n\x05\x04D\x04\0\x01\x12\x04\x8b\x16\x07\x0b\n8\n\x06\x04D\x04\0\x02\
    \0\x12\x04\x8d\x16\x04\x10\x1a(\x20UNKNOWN\x20indicates\x20a\x20generic\
    \x20condition.\n\n\x0f\n\x07\x04D\x04\0\x02\0\x01\x12\x04\x8d\x16\x04\
    \x0b\n\x0f\n\x07\x04D\x04\0\x02\0\x02\x12\x04\x8d\x16\x0e\x0f\nJ\n\x06\
    \x04D\x04\0\x02\x01\x12\x04\x90\x16\x04\x15\x1a:\x20GCE_STOCKOUT\x20indi\
    cates\x20a\x20Google\x20Compute\x20Engine\x20stockout.\n\n\x0f\n\x07\x04\
    D\x04\0\x02\x01\x01\x12\x04\x90\x16\x04\x10\n\x0f\n\x07\x04D\x04\0\x02\
    \x01\x02\x12\x04\x90\x16\x13\x14\nk\n\x06\x04D\x04\0\x02\x02\x12\x04\x94\
    \x16\x04$\x1a[\x20GKE_SERVICE_ACCOUNT_DELETED\x20indicates\x20that\x20th\
    e\x20user\x20deleted\x20their\x20robot\n\x20service\x20account.\n\n\x0f\
    \n\x07\x04D\x04\0\x02\x02\x01\x12\x04\x94\x16\x04\x1f\n\x0f\n\x07\x04D\
    \x04\0\x02\x02\x02\x12\x04\x94\x16\"#\n;\n\x06\x04D\x04\0\x02\x03\x12\
    \x04\x97\x16\x04\x1b\x1a+\x20Google\x20Compute\x20Engine\x20quota\x20was\
    \x20exceeded.\n\n\x0f\n\x07\x04D\x04\0\x02\x03\x01\x12\x04\x97\x16\x04\
    \x16\n\x0f\n\x07\x04D\x04\0\x02\x03\x02\x12\x04\x97\x16\x19\x1a\n[\n\x06\
    \x04D\x04\0\x02\x04\x12\x04\x9a\x16\x04\x18\x1aK\x20Cluster\x20state\x20\
    was\x20manually\x20changed\x20by\x20an\x20SRE\x20due\x20to\x20a\x20syste\
    m\x20logic\x20error.\n\n\x0f\n\x07\x04D\x04\0\x02\x04\x01\x12\x04\x9a\
    \x16\x04\x13\n\x0f\n\x07\x04D\x04\0\x02\x04\x02\x12\x04\x9a\x16\x16\x17\
    \n\x82\x01\n\x06\x04D\x04\0\x02\x05\x12\x04\x9f\x16\x04\x1c\x1ar\x20Unab\
    le\x20to\x20perform\x20an\x20encrypt\x20operation\x20against\x20the\x20C\
    loudKMS\x20key\x20used\x20for\n\x20etcd\x20level\x20encryption.\n\x20Mor\
    e\x20codes\x20TBA\n\n\x0f\n\x07\x04D\x04\0\x02\x05\x01\x12\x04\x9f\x16\
    \x04\x17\n\x0f\n\x07\x04D\x04\0\x02\x05\x02\x12\x04\x9f\x16\x1a\x1b\n@\n\
    \x04\x04D\x02\0\x12\x04\xa3\x16\x02\x10\x1a2\x20Machine-friendly\x20repr\
    esentation\x20of\x20the\x20condition\n\n\r\n\x05\x04D\x02\0\x06\x12\x04\
    \xa3\x16\x02\x06\n\r\n\x05\x04D\x02\0\x01\x12\x04\xa3\x16\x07\x0b\n\r\n\
    \x05\x04D\x02\0\x03\x12\x04\xa3\x16\x0e\x0f\n>\n\x04\x04D\x02\x01\x12\
    \x04\xa6\x16\x02\x15\x1a0\x20Human-friendly\x20representation\x20of\x20t\
    he\x20condition\n\n\r\n\x05\x04D\x02\x01\x05\x12\x04\xa6\x16\x02\x08\n\r\
    \n\x05\x04D\x02\x01\x01\x12\x04\xa6\x16\t\x10\n\r\n\x05\x04D\x02\x01\x03\
    \x12\x04\xa6\x16\x13\x14\nQ\n\x02\x04E\x12\x06\xaa\x16\0\xb9\x16\x01\x1a\
    C\x20NetworkConfig\x20reports\x20the\x20relative\x20names\x20of\x20netwo\
    rk\x20&\x20subnetwork.\n\n\x0b\n\x03\x04E\x01\x12\x04\xaa\x16\x08\x15\n\
    \x8e\x02\n\x04\x04E\x02\0\x12\x04\xaf\x16\x02\x15\x1a\xff\x01\x20Output\
    \x20only.\x20The\x20relative\x20name\x20of\x20the\x20Google\x20Compute\
    \x20Engine\n\x20[network][google.container.v1.NetworkConfig.network](/co\
    mpute/docs/networks-and-firewalls#networks)\x20to\x20which\n\x20the\x20c\
    luster\x20is\x20connected.\n\x20Example:\x20projects/my-project/global/n\
    etworks/my-network\n\n\r\n\x05\x04E\x02\0\x05\x12\x04\xaf\x16\x02\x08\n\
    \r\n\x05\x04E\x02\0\x01\x12\x04\xaf\x16\t\x10\n\r\n\x05\x04E\x02\0\x03\
    \x12\x04\xaf\x16\x13\x14\n\xd8\x01\n\x04\x04E\x02\x01\x12\x04\xb4\x16\
    \x02\x18\x1a\xc9\x01\x20Output\x20only.\x20The\x20relative\x20name\x20of\
    \x20the\x20Google\x20Compute\x20Engine\n\x20[subnetwork](/compute/docs/v\
    pc)\x20to\x20which\x20the\x20cluster\x20is\x20connected.\n\x20Example:\
    \x20projects/my-project/regions/us-central1/subnetworks/my-subnet\n\n\r\
    \n\x05\x04E\x02\x01\x05\x12\x04\xb4\x16\x02\x08\n\r\n\x05\x04E\x02\x01\
    \x01\x12\x04\xb4\x16\t\x13\n\r\n\x05\x04E\x02\x01\x03\x12\x04\xb4\x16\
    \x16\x17\n\x8c\x01\n\x04\x04E\x02\x02\x12\x04\xb8\x16\x02(\x1a~\x20Wheth\
    er\x20Intra-node\x20visibility\x20is\x20enabled\x20for\x20this\x20cluste\
    r.\n\x20This\x20makes\x20same\x20node\x20pod\x20to\x20pod\x20traffic\x20\
    visible\x20for\x20VPC\x20network.\n\n\r\n\x05\x04E\x02\x02\x05\x12\x04\
    \xb8\x16\x02\x06\n\r\n\x05\x04E\x02\x02\x01\x12\x04\xb8\x16\x07#\n\r\n\
    \x05\x04E\x02\x02\x03\x12\x04\xb8\x16&'\nt\n\x02\x04F\x12\x06\xbd\x16\0\
    \xc0\x16\x01\x1af\x20IntraNodeVisibilityConfig\x20contains\x20the\x20des\
    ired\x20config\x20of\x20the\x20intra-node\n\x20visibility\x20on\x20this\
    \x20cluster.\n\n\x0b\n\x03\x04F\x01\x12\x04\xbd\x16\x08!\n?\n\x04\x04F\
    \x02\0\x12\x04\xbf\x16\x02\x13\x1a1\x20Enables\x20intra\x20node\x20visib\
    ility\x20for\x20this\x20cluster.\n\n\r\n\x05\x04F\x02\0\x05\x12\x04\xbf\
    \x16\x02\x06\n\r\n\x05\x04F\x02\0\x01\x12\x04\xbf\x16\x07\x0e\n\r\n\x05\
    \x04F\x02\0\x03\x12\x04\xbf\x16\x11\x12\n,\n\x02\x04G\x12\x06\xc3\x16\0\
    \xc6\x16\x01\x1a\x1e\x20Constraints\x20applied\x20to\x20pods.\n\n\x0b\n\
    \x03\x04G\x01\x12\x04\xc3\x16\x08\x19\nD\n\x04\x04G\x02\0\x12\x04\xc5\
    \x16\x02\x1e\x1a6\x20Constraint\x20enforced\x20on\x20the\x20max\x20num\
    \x20of\x20pods\x20per\x20node.\n\n\r\n\x05\x04G\x02\0\x05\x12\x04\xc5\
    \x16\x02\x07\n\r\n\x05\x04G\x02\0\x01\x12\x04\xc5\x16\x08\x19\n\r\n\x05\
    \x04G\x02\0\x03\x12\x04\xc5\x16\x1c\x1d\n1\n\x02\x04H\x12\x06\xc9\x16\0\
    \xdd\x16\x01\x1a#\x20Configuration\x20of\x20etcd\x20encryption.\n\n\x0b\
    \n\x03\x04H\x01\x12\x04\xc9\x16\x08\x1a\n+\n\x04\x04H\x04\0\x12\x06\xcb\
    \x16\x02\xd5\x16\x03\x1a\x1b\x20State\x20of\x20etcd\x20encryption.\n\n\r\
    \n\x05\x04H\x04\0\x01\x12\x04\xcb\x16\x07\x0c\n%\n\x06\x04H\x04\0\x02\0\
    \x12\x04\xcd\x16\x04\x10\x1a\x15\x20Should\x20never\x20be\x20set\n\n\x0f\
    \n\x07\x04H\x04\0\x02\0\x01\x12\x04\xcd\x16\x04\x0b\n\x0f\n\x07\x04H\x04\
    \0\x02\0\x02\x12\x04\xcd\x16\x0e\x0f\n0\n\x06\x04H\x04\0\x02\x01\x12\x04\
    \xd0\x16\x04\x12\x1a\x20\x20Secrets\x20in\x20etcd\x20are\x20encrypted.\n\
    \n\x0f\n\x07\x04H\x04\0\x02\x01\x01\x12\x04\xd0\x16\x04\r\n\x0f\n\x07\
    \x04H\x04\0\x02\x01\x02\x12\x04\xd0\x16\x10\x11\n\x82\x01\n\x06\x04H\x04\
    \0\x02\x02\x12\x04\xd4\x16\x04\x12\x1ar\x20Secrets\x20in\x20etcd\x20are\
    \x20stored\x20in\x20plain\x20text\x20(at\x20etcd\x20level)\x20-\x20this\
    \x20is\n\x20unrelated\x20to\x20GCE\x20level\x20full\x20disk\x20encryptio\
    n.\n\n\x0f\n\x07\x04H\x04\0\x02\x02\x01\x12\x04\xd4\x16\x04\r\n\x0f\n\
    \x07\x04H\x04\0\x02\x02\x02\x12\x04\xd4\x16\x10\x11\n5\n\x04\x04H\x02\0\
    \x12\x04\xd8\x16\x02\x12\x1a'\x20Denotes\x20the\x20state\x20of\x20etcd\
    \x20encryption.\n\n\r\n\x05\x04H\x02\0\x06\x12\x04\xd8\x16\x02\x07\n\r\n\
    \x05\x04H\x02\0\x01\x12\x04\xd8\x16\x08\r\n\r\n\x05\x04H\x02\0\x03\x12\
    \x04\xd8\x16\x10\x11\n\xa0\x01\n\x04\x04H\x02\x01\x12\x04\xdc\x16\x02\
    \x16\x1a\x91\x01\x20Name\x20of\x20CloudKMS\x20key\x20to\x20use\x20for\
    \x20the\x20encryption\x20of\x20secrets\x20in\x20etcd.\n\x20Ex.\x20projec\
    ts/my-project/locations/global/keyRings/my-ring/cryptoKeys/my-key\n\n\r\
    \n\x05\x04H\x02\x01\x05\x12\x04\xdc\x16\x02\x08\n\r\n\x05\x04H\x02\x01\
    \x01\x12\x04\xdc\x16\t\x11\n\r\n\x05\x04H\x02\x01\x03\x12\x04\xdc\x16\
    \x14\x15\n\x80\x01\n\x02\x04I\x12\x06\xe1\x16\0\xf5\x16\x01\x1ar\x20List\
    UsableSubnetworksRequest\x20requests\x20the\x20list\x20of\x20usable\x20s\
    ubnetworks\n\x20available\x20to\x20a\x20user\x20for\x20creating\x20clust\
    ers.\n\n\x0b\n\x03\x04I\x01\x12\x04\xe1\x16\x08$\ng\n\x04\x04I\x02\0\x12\
    \x04\xe4\x16\x02\x14\x1aY\x20The\x20parent\x20project\x20where\x20subnet\
    works\x20are\x20usable.\n\x20Specified\x20in\x20the\x20format\x20'projec\
    ts/*'.\n\n\r\n\x05\x04I\x02\0\x05\x12\x04\xe4\x16\x02\x08\n\r\n\x05\x04I\
    \x02\0\x01\x12\x04\xe4\x16\t\x0f\n\r\n\x05\x04I\x02\0\x03\x12\x04\xe4\
    \x16\x12\x13\n\x82\x02\n\x04\x04I\x02\x01\x12\x04\xea\x16\x02\x14\x1a\
    \xf3\x01\x20Filtering\x20currently\x20only\x20supports\x20equality\x20on\
    \x20the\x20networkProjectId\x20and\x20must\n\x20be\x20in\x20the\x20form:\
    \x20\"networkProjectId=[PROJECTID]\",\x20where\x20`networkProjectId`\n\
    \x20is\x20the\x20project\x20which\x20owns\x20the\x20listed\x20subnetwork\
    s.\x20This\x20defaults\x20to\x20the\n\x20parent\x20project\x20ID.\n\n\r\
    \n\x05\x04I\x02\x01\x05\x12\x04\xea\x16\x02\x08\n\r\n\x05\x04I\x02\x01\
    \x01\x12\x04\xea\x16\t\x0f\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xea\x16\
    \x12\x13\n\xb2\x02\n\x04\x04I\x02\x02\x12\x04\xf0\x16\x02\x16\x1a\xa3\
    \x02\x20The\x20max\x20number\x20of\x20results\x20per\x20page\x20that\x20\
    should\x20be\x20returned.\x20If\x20the\x20number\n\x20of\x20available\
    \x20results\x20is\x20larger\x20than\x20`page_size`,\x20a\x20`next_page_t\
    oken`\x20is\n\x20returned\x20which\x20can\x20be\x20used\x20to\x20get\x20\
    the\x20next\x20page\x20of\x20results\x20in\x20subsequent\n\x20requests.\
    \x20Acceptable\x20values\x20are\x200\x20to\x20500,\x20inclusive.\x20(Def\
    ault:\x20500)\n\n\r\n\x05\x04I\x02\x02\x05\x12\x04\xf0\x16\x02\x07\n\r\n\
    \x05\x04I\x02\x02\x01\x12\x04\xf0\x16\x08\x11\n\r\n\x05\x04I\x02\x02\x03\
    \x12\x04\xf0\x16\x14\x15\n\x92\x01\n\x04\x04I\x02\x03\x12\x04\xf4\x16\
    \x02\x18\x1a\x83\x01\x20Specifies\x20a\x20page\x20token\x20to\x20use.\
    \x20Set\x20this\x20to\x20the\x20nextPageToken\x20returned\x20by\n\x20pre\
    vious\x20list\x20requests\x20to\x20get\x20the\x20next\x20page\x20of\x20r\
    esults.\n\n\r\n\x05\x04I\x02\x03\x05\x12\x04\xf4\x16\x02\x08\n\r\n\x05\
    \x04I\x02\x03\x01\x12\x04\xf4\x16\t\x13\n\r\n\x05\x04I\x02\x03\x03\x12\
    \x04\xf4\x16\x16\x17\n_\n\x02\x04J\x12\x06\xf9\x16\0\x82\x17\x01\x1aQ\
    \x20ListUsableSubnetworksResponse\x20is\x20the\x20response\x20of\n\x20Li\
    stUsableSubnetworksRequest.\n\n\x0b\n\x03\x04J\x01\x12\x04\xf9\x16\x08%\
    \nN\n\x04\x04J\x02\0\x12\x04\xfb\x16\x02,\x1a@\x20A\x20list\x20of\x20usa\
    ble\x20subnetworks\x20in\x20the\x20specified\x20network\x20project.\n\n\
    \r\n\x05\x04J\x02\0\x04\x12\x04\xfb\x16\x02\n\n\r\n\x05\x04J\x02\0\x06\
    \x12\x04\xfb\x16\x0b\x1b\n\r\n\x05\x04J\x02\0\x01\x12\x04\xfb\x16\x1c'\n\
    \r\n\x05\x04J\x02\0\x03\x12\x04\xfb\x16*+\n\xaa\x02\n\x04\x04J\x02\x01\
    \x12\x04\x81\x17\x02\x1d\x1a\x9b\x02\x20This\x20token\x20allows\x20you\
    \x20to\x20get\x20the\x20next\x20page\x20of\x20results\x20for\x20list\x20\
    requests.\n\x20If\x20the\x20number\x20of\x20results\x20is\x20larger\x20t\
    han\x20`page_size`,\x20use\x20the\n\x20`next_page_token`\x20as\x20a\x20v\
    alue\x20for\x20the\x20query\x20parameter\x20`page_token`\x20in\x20the\n\
    \x20next\x20request.\x20The\x20value\x20will\x20become\x20empty\x20when\
    \x20there\x20are\x20no\x20more\x20pages.\n\n\r\n\x05\x04J\x02\x01\x05\
    \x12\x04\x81\x17\x02\x08\n\r\n\x05\x04J\x02\x01\x01\x12\x04\x81\x17\t\
    \x18\n\r\n\x05\x04J\x02\x01\x03\x12\x04\x81\x17\x1b\x1c\n:\n\x02\x04K\
    \x12\x06\x85\x17\0\xa5\x17\x01\x1a,\x20Secondary\x20IP\x20range\x20of\
    \x20a\x20usable\x20subnetwork.\n\n\x0b\n\x03\x04K\x01\x12\x04\x85\x17\
    \x08&\nI\n\x04\x04K\x04\0\x12\x06\x87\x17\x02\x9a\x17\x03\x1a9\x20Status\
    \x20shows\x20the\x20current\x20usage\x20of\x20a\x20secondary\x20IP\x20ra\
    nge.\n\n\r\n\x05\x04K\x04\0\x01\x12\x04\x87\x17\x07\r\nX\n\x06\x04K\x04\
    \0\x02\0\x12\x04\x89\x17\x04\x10\x1aH\x20UNKNOWN\x20is\x20the\x20zero\
    \x20value\x20of\x20the\x20Status\x20enum.\x20It's\x20not\x20a\x20valid\
    \x20status.\n\n\x0f\n\x07\x04K\x04\0\x02\0\x01\x12\x04\x89\x17\x04\x0b\n\
    \x0f\n\x07\x04K\x04\0\x02\0\x02\x12\x04\x89\x17\x0e\x0f\nM\n\x06\x04K\
    \x04\0\x02\x01\x12\x04\x8c\x17\x04\x0f\x1a=\x20UNUSED\x20denotes\x20that\
    \x20this\x20range\x20is\x20unclaimed\x20by\x20any\x20cluster.\n\n\x0f\n\
    \x07\x04K\x04\0\x02\x01\x01\x12\x04\x8c\x17\x04\n\n\x0f\n\x07\x04K\x04\0\
    \x02\x01\x02\x12\x04\x8c\x17\r\x0e\n\x85\x01\n\x06\x04K\x04\0\x02\x02\
    \x12\x04\x90\x17\x04\x17\x1au\x20IN_USE_SERVICE\x20denotes\x20that\x20th\
    is\x20range\x20is\x20claimed\x20by\x20a\x20cluster\x20for\n\x20services.\
    \x20It\x20cannot\x20be\x20used\x20for\x20other\x20clusters.\n\n\x0f\n\
    \x07\x04K\x04\0\x02\x02\x01\x12\x04\x90\x17\x04\x12\n\x0f\n\x07\x04K\x04\
    \0\x02\x02\x02\x12\x04\x90\x17\x15\x16\n\xc3\x01\n\x06\x04K\x04\0\x02\
    \x03\x12\x04\x95\x17\x04\x1d\x1a\xb2\x01\x20IN_USE_SHAREABLE_POD\x20deno\
    tes\x20this\x20range\x20was\x20created\x20by\x20the\x20network\x20admin\
    \n\x20and\x20is\x20currently\x20claimed\x20by\x20a\x20cluster\x20for\x20\
    pods.\x20It\x20can\x20only\x20be\x20used\x20by\n\x20other\x20clusters\
    \x20as\x20a\x20pod\x20range.\n\n\x0f\n\x07\x04K\x04\0\x02\x03\x01\x12\
    \x04\x95\x17\x04\x18\n\x0f\n\x07\x04K\x04\0\x02\x03\x02\x12\x04\x95\x17\
    \x1b\x1c\n\x8a\x01\n\x06\x04K\x04\0\x02\x04\x12\x04\x99\x17\x04\x1b\x1az\
    \x20IN_USE_MANAGED_POD\x20denotes\x20this\x20range\x20was\x20created\x20\
    by\x20GKE\x20and\x20is\x20claimed\n\x20for\x20pods.\x20It\x20cannot\x20b\
    e\x20used\x20for\x20other\x20clusters.\n\n\x0f\n\x07\x04K\x04\0\x02\x04\
    \x01\x12\x04\x99\x17\x04\x16\n\x0f\n\x07\x04K\x04\0\x02\x04\x02\x12\x04\
    \x99\x17\x19\x1a\n\x7f\n\x04\x04K\x02\0\x12\x04\x9e\x17\x02\x18\x1aq\x20\
    The\x20name\x20associated\x20with\x20this\x20subnetwork\x20secondary\x20\
    range,\x20used\x20when\x20adding\n\x20an\x20alias\x20IP\x20range\x20to\
    \x20a\x20VM\x20instance.\n\n\r\n\x05\x04K\x02\0\x05\x12\x04\x9e\x17\x02\
    \x08\n\r\n\x05\x04K\x02\0\x01\x12\x04\x9e\x17\t\x13\n\r\n\x05\x04K\x02\0\
    \x03\x12\x04\x9e\x17\x16\x17\nW\n\x04\x04K\x02\x01\x12\x04\xa1\x17\x02\
    \x1b\x1aI\x20The\x20range\x20of\x20IP\x20addresses\x20belonging\x20to\
    \x20this\x20subnetwork\x20secondary\x20range.\n\n\r\n\x05\x04K\x02\x01\
    \x05\x12\x04\xa1\x17\x02\x08\n\r\n\x05\x04K\x02\x01\x01\x12\x04\xa1\x17\
    \t\x16\n\r\n\x05\x04K\x02\x01\x03\x12\x04\xa1\x17\x19\x1a\nZ\n\x04\x04K\
    \x02\x02\x12\x04\xa4\x17\x02\x14\x1aL\x20This\x20field\x20is\x20to\x20de\
    termine\x20the\x20status\x20of\x20the\x20secondary\x20range\x20programma\
    bly.\n\n\r\n\x05\x04K\x02\x02\x06\x12\x04\xa4\x17\x02\x08\n\r\n\x05\x04K\
    \x02\x02\x01\x12\x04\xa4\x17\t\x0f\n\r\n\x05\x04K\x02\x02\x03\x12\x04\
    \xa4\x17\x12\x13\nz\n\x02\x04L\x12\x06\xa9\x17\0\xbd\x17\x01\x1al\x20Usa\
    bleSubnetwork\x20resource\x20returns\x20the\x20subnetwork\x20name,\x20it\
    s\x20associated\x20network\n\x20and\x20the\x20primary\x20CIDR\x20range.\
    \n\n\x0b\n\x03\x04L\x01\x12\x04\xa9\x17\x08\x18\nh\n\x04\x04L\x02\0\x12\
    \x04\xac\x17\x02\x18\x1aZ\x20Subnetwork\x20Name.\n\x20Example:\x20projec\
    ts/my-project/regions/us-central1/subnetworks/my-subnet\n\n\r\n\x05\x04L\
    \x02\0\x05\x12\x04\xac\x17\x02\x08\n\r\n\x05\x04L\x02\0\x01\x12\x04\xac\
    \x17\t\x13\n\r\n\x05\x04L\x02\0\x03\x12\x04\xac\x17\x16\x17\nV\n\x04\x04\
    L\x02\x01\x12\x04\xb0\x17\x02\x15\x1aH\x20Network\x20Name.\n\x20Example:\
    \x20projects/my-project/global/networks/my-network\n\n\r\n\x05\x04L\x02\
    \x01\x05\x12\x04\xb0\x17\x02\x08\n\r\n\x05\x04L\x02\x01\x01\x12\x04\xb0\
    \x17\t\x10\n\r\n\x05\x04L\x02\x01\x03\x12\x04\xb0\x17\x13\x14\nR\n\x04\
    \x04L\x02\x02\x12\x04\xb3\x17\x02\x1b\x1aD\x20The\x20range\x20of\x20inte\
    rnal\x20addresses\x20that\x20are\x20owned\x20by\x20this\x20subnetwork.\n\
    \n\r\n\x05\x04L\x02\x02\x05\x12\x04\xb3\x17\x02\x08\n\r\n\x05\x04L\x02\
    \x02\x01\x12\x04\xb3\x17\t\x16\n\r\n\x05\x04L\x02\x02\x03\x12\x04\xb3\
    \x17\x19\x1a\n$\n\x04\x04L\x02\x03\x12\x04\xb6\x17\x02B\x1a\x16\x20Secon\
    dary\x20IP\x20ranges.\n\n\r\n\x05\x04L\x02\x03\x04\x12\x04\xb6\x17\x02\n\
    \n\r\n\x05\x04L\x02\x03\x06\x12\x04\xb6\x17\x0b)\n\r\n\x05\x04L\x02\x03\
    \x01\x12\x04\xb6\x17*=\n\r\n\x05\x04L\x02\x03\x03\x12\x04\xb6\x17@A\n\
    \xa8\x02\n\x04\x04L\x02\x04\x12\x04\xbc\x17\x02\x1c\x1a\x99\x02\x20A\x20\
    human\x20readable\x20status\x20message\x20representing\x20the\x20reasons\
    \x20for\x20cases\x20where\n\x20the\x20caller\x20cannot\x20use\x20the\x20\
    secondary\x20ranges\x20under\x20the\x20subnet.\x20For\x20example\x20if\n\
    \x20the\x20secondary_ip_ranges\x20is\x20empty\x20due\x20to\x20a\x20permi\
    ssion\x20issue,\x20an\x20insufficient\n\x20permission\x20message\x20will\
    \x20be\x20given\x20by\x20status_message.\n\n\r\n\x05\x04L\x02\x04\x05\
    \x12\x04\xbc\x17\x02\x08\n\r\n\x05\x04L\x02\x04\x01\x12\x04\xbc\x17\t\
    \x17\n\r\n\x05\x04L\x02\x04\x03\x12\x04\xbc\x17\x1a\x1b\nD\n\x02\x04M\
    \x12\x06\xc0\x17\0\xd8\x17\x01\x1a6\x20Configuration\x20for\x20exporting\
    \x20cluster\x20resource\x20usages.\n\n\x0b\n\x03\x04M\x01\x12\x04\xc0\
    \x17\x08!\n\\\n\x04\x04M\x03\0\x12\x06\xc2\x17\x02\xc5\x17\x03\x1aL\x20P\
    arameters\x20for\x20using\x20BigQuery\x20as\x20the\x20destination\x20of\
    \x20resource\x20usage\x20export.\n\n\r\n\x05\x04M\x03\0\x01\x12\x04\xc2\
    \x17\n\x1d\n/\n\x06\x04M\x03\0\x02\0\x12\x04\xc4\x17\x04\x1a\x1a\x1f\x20\
    The\x20ID\x20of\x20a\x20BigQuery\x20Dataset.\n\n\x0f\n\x07\x04M\x03\0\
    \x02\0\x05\x12\x04\xc4\x17\x04\n\n\x0f\n\x07\x04M\x03\0\x02\0\x01\x12\
    \x04\xc4\x17\x0b\x15\n\x0f\n\x07\x04M\x03\0\x02\0\x03\x12\x04\xc4\x17\
    \x18\x19\nB\n\x04\x04M\x03\x01\x12\x06\xc8\x17\x02\xcd\x17\x03\x1a2\x20P\
    arameters\x20for\x20controlling\x20consumption\x20metering.\n\n\r\n\x05\
    \x04M\x03\x01\x01\x12\x04\xc8\x17\n#\n\xa7\x01\n\x06\x04M\x03\x01\x02\0\
    \x12\x04\xcc\x17\x04\x15\x1a\x96\x01\x20Whether\x20to\x20enable\x20consu\
    mption\x20metering\x20for\x20this\x20cluster.\x20If\x20enabled,\x20a\n\
    \x20second\x20BigQuery\x20table\x20will\x20be\x20created\x20to\x20hold\
    \x20resource\x20consumption\n\x20records.\n\n\x0f\n\x07\x04M\x03\x01\x02\
    \0\x05\x12\x04\xcc\x17\x04\x08\n\x0f\n\x07\x04M\x03\x01\x02\0\x01\x12\
    \x04\xcc\x17\t\x10\n\x0f\n\x07\x04M\x03\x01\x02\0\x03\x12\x04\xcc\x17\
    \x13\x14\nJ\n\x04\x04M\x02\0\x12\x04\xd0\x17\x02/\x1a<\x20Configuration\
    \x20to\x20use\x20BigQuery\x20as\x20usage\x20export\x20destination.\n\n\r\
    \n\x05\x04M\x02\0\x06\x12\x04\xd0\x17\x02\x15\n\r\n\x05\x04M\x02\0\x01\
    \x12\x04\xd0\x17\x16*\n\r\n\x05\x04M\x02\0\x03\x12\x04\xd0\x17-.\n\xa5\
    \x01\n\x04\x04M\x02\x01\x12\x04\xd4\x17\x02*\x1a\x96\x01\x20Whether\x20t\
    o\x20enable\x20network\x20egress\x20metering\x20for\x20this\x20cluster.\
    \x20If\x20enabled,\x20a\n\x20daemonset\x20will\x20be\x20created\x20in\
    \x20the\x20cluster\x20to\x20meter\x20network\x20egress\x20traffic.\n\n\r\
    \n\x05\x04M\x02\x01\x05\x12\x04\xd4\x17\x02\x06\n\r\n\x05\x04M\x02\x01\
    \x01\x12\x04\xd4\x17\x07%\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xd4\x17()\n\
    F\n\x04\x04M\x02\x02\x12\x04\xd7\x17\x02<\x1a8\x20Configuration\x20to\
    \x20enable\x20resource\x20consumption\x20metering.\n\n\r\n\x05\x04M\x02\
    \x02\x06\x12\x04\xd7\x17\x02\x1b\n\r\n\x05\x04M\x02\x02\x01\x12\x04\xd7\
    \x17\x1c7\n\r\n\x05\x04M\x02\x02\x03\x12\x04\xd7\x17:;\n\xb6\x01\n\x02\
    \x04N\x12\x06\xdd\x17\0\xe0\x17\x01\x1a\xa7\x01\x20VerticalPodAutoscalin\
    g\x20contains\x20global,\x20per-cluster\x20information\n\x20required\x20\
    by\x20Vertical\x20Pod\x20Autoscaler\x20to\x20automatically\x20adjust\n\
    \x20the\x20resources\x20of\x20pods\x20controlled\x20by\x20it.\n\n\x0b\n\
    \x03\x04N\x01\x12\x04\xdd\x17\x08\x1e\n1\n\x04\x04N\x02\0\x12\x04\xdf\
    \x17\x02\x13\x1a#\x20Enables\x20vertical\x20pod\x20autoscaling.\n\n\r\n\
    \x05\x04N\x02\0\x05\x12\x04\xdf\x17\x02\x06\n\r\n\x05\x04N\x02\0\x01\x12\
    \x04\xdf\x17\x07\x0e\n\r\n\x05\x04N\x02\0\x03\x12\x04\xdf\x17\x11\x12b\
    \x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
